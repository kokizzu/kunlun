DROP TABLE IF EXISTS t1;
DROP TABLE IF EXISTS t2;
DROP TABLE IF EXISTS t3 CASCADE;
CREATE TABLE t1(A INT PRIMARY KEY, B INT NOT NULL UNIQUE);
CREATE TEMP TABLE t2(A INT PRIMARY KEY, B INT NOT NULL UNIQUE);
CREATE TABLE t3 (A INT PRIMARY KEY, B INT) PARTITION BY RANGE(a);
CREATE TABLE t3p1 PARTITION OF t3 FOR VALUES FROM (0) TO (100);
CREATE TABLE t3p2 PARTITION OF t3 FOR VALUES FROM (100) TO (200);
CREATE TEMP TABLE t4 (A INT PRIMARY KEY, B INT) PARTITION BY RANGE(a);
CREATE TEMP TABLE t4p1 PARTITION OF t4 FOR VALUES FROM (0) TO (100);
CREATE TEMP TABLE t4p2 PARTITION OF t4 FOR VALUES FROM (100) TO (200);

-- insert ignore
INSERT INTO t1 VALUES(1,1), (2,2);
INSERT IGNORE INTO t1 VALUES(1,2);
SELECT * FROM t1;
INSERT IGNORE INTO t1 VALUES(1, NULL); -- should be fail

INSERT INTO t2 SELECT * FROM T1;
INSERT IGNORE INTO t2 VALUES(1,2);
SELECT * FROM t1;
INSERT IGNORE INTO t1 VALUES(1, NULL); -- should be fail

-- insert on duplicate key update
INSERT INTO t1 VALUES(1,1) ON DUPLICATE KEY UPDATE  b=-1;
INSERT INTO t1 VALUES(3,3), (3,4) ON DUPLICATE KEY UPDATE b=excluded.b+1;
SELECT *  FROM t1;

-- The temp table is stored in kunlun's postgres and does not allow more than two updates to a tuple.
INSERT INTO t2 VALUES(3,3), (3,4) ON DUPLICATE KEY UPDATE b=excluded.b+1; -- should be fail

INSERT INTO t3 SELECT GENERATE_SERIES(0,400) % 200, 0 ON DUPLICATE KEY UPDATE b=t3.b+1;

-- update partition key is not allowed
INSERT INTO t3 SELECT GENERATE_SERIES(0,400) % 200, 0 ON DUPLICATE KEY UPDATE a=200-t3.a; -- should be fail


--- replace
DELETE  FROM t1;
INSERT INTO t1 VALUES(1,1), (1,2);
REPLACE INTO t1 VALUES(1,2);
SELECT * FROM t1;

REPLACE INTO t1 VALUES (3,3), (3,4), (3,5);
SELECT * FROM t1;

DELETE FROM t2;
REPLACE INTO t1 VALUES (3,3), (3,4), (3,5); -- should be fail

DELETE FROM t3;
REPLACE INTO t3 SELECT GENERATE_SERIES(0,400) % 200, GENERATE_SERIES(0,400);
SELECT count(1) FROM t3;

DELETE FROM t4;
REPLACE INTO t4 SELECT GENERATE_SERIES(0,400) % 200, GENERATE_SERIES(0,400); -- should be fail

-- update limit
DELETE FROM t1;
INSERT INTO t1 SELECT GENERATE_SERIES(0,20), GENERATE_SERIES(0,20);
UPDATE t1 SET b=-b ORDER BY a LIMIT 1;
SELECT * FROM t1 WHERE b < 0;

UPDATE t1 SET b=-b ORDER BY a DESC LIMIT 1;
SELECT * FROM t1 WHERE b < 0;

UPDATE t3 SET b=-b ORDER BY a LIMIT 1; -- should be fail, global order is not supported

UPDATE t3 SET b=-b WHERE a<100 ORDER BY a LIMIT 1 RETURNING *;

WITH foo as (UPDATE t3 SET b=-b WHERE b > 0 LIMIT 10 RETURNING *) SELECT count(1) FROM foo;
SELECT count(1) FROM t3 where b<0;

INSERT INTO t4 SELECT GENERATE_SERIES(0,100);
UPDATE t4 SET a=a+10 ORDER BY a; -- should be fail
UPDATE t4 SET a=a+10 ORDER BY a DESC LIMIT 30 RETURNING *;
