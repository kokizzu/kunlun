-- regression test cases from all bug reports in trac.
-- bug 17 The command does not return the number of affected records 
create table tx1(id int primary key, c char(50));
insert into tx1 values(1,'1');
insert into tx1 values(2, '2');
insert into tx1 values(3, '3');
delete from tx1;
drop table tx1;
-- bug 30
create table uv_iocu_tab (a serial primary key, b varchar(50));
insert into uv_iocu_tab (b) values('abc'),('bcd'),('xyz');
create view uv_iocu_view as select b as bb, a as aa, uv_iocu_tab::varchar(50) as cc from uv_iocu_tab;
select * from uv_iocu_view;
ERROR:  Kunlun-db: Must specify whole-row target left-most.
drop view uv_iocu_view;
create view uv_iocu_view as select a as aa, b as bb, uv_iocu_tab::varchar(50) as cc from uv_iocu_tab;
select * from uv_iocu_view;
 aa | bb  |   cc    
----+-----+---------
  1 | abc | (1,abc)
  2 | bcd | (2,bcd)
  3 | xyz | (3,xyz)
(3 rows)

drop table uv_iocu_tab cascade;
NOTICE:  drop cascades to view uv_iocu_view
-- bug 31
CREATE TABLE base_tbl(id serial primary key, a float);
INSERT INTO base_tbl (a) SELECT i/10.0 FROM generate_series(1,10) g(i);
CREATE VIEW rw_view1 AS SELECT ctid, sin(a) s, a, cos(a) c FROM base_tbl WHERE a != 0 ORDER BY abs(a);
select*from rw_view1;
ERROR:  Kunlun-db: Can't access system attribute(ctid) from remote relation base_tbl.
drop view rw_view1;
CREATE VIEW rw_view1 AS SELECT sin(a) s, a, cos(a) c FROM base_tbl WHERE a != 0 ORDER BY abs(a);
select*from rw_view1;
         s          |  a  |         c         
--------------------+-----+-------------------
 0.0998334166468282 | 0.1 | 0.995004165278026
  0.198669330795061 | 0.2 | 0.980066577841242
   0.29552020666134 | 0.3 | 0.955336489125606
  0.389418342308651 | 0.4 | 0.921060994002885
  0.479425538604203 | 0.5 | 0.877582561890373
  0.564642473395035 | 0.6 | 0.825335614909678
  0.644217687237691 | 0.7 | 0.764842187284488
  0.717356090899523 | 0.8 | 0.696706709347165
  0.783326909627483 | 0.9 | 0.621609968270664
  0.841470984807897 |   1 |  0.54030230586814
(10 rows)

INSERT INTO rw_view1 (a) VALUES (1.1) RETURNING a, s, c;
  a  |         s         |         c         
-----+-------------------+-------------------
 1.1 | 0.891207360061435 | 0.453596121425577
(1 row)

select*from rw_view1;
         s          |  a  |         c         
--------------------+-----+-------------------
 0.0998334166468282 | 0.1 | 0.995004165278026
  0.198669330795061 | 0.2 | 0.980066577841242
   0.29552020666134 | 0.3 | 0.955336489125606
  0.389418342308651 | 0.4 | 0.921060994002885
  0.479425538604203 | 0.5 | 0.877582561890373
  0.564642473395035 | 0.6 | 0.825335614909678
  0.644217687237691 | 0.7 | 0.764842187284488
  0.717356090899523 | 0.8 | 0.696706709347165
  0.783326909627483 | 0.9 | 0.621609968270664
  0.841470984807897 |   1 |  0.54030230586814
  0.891207360061435 | 1.1 | 0.453596121425577
(11 rows)

drop table base_tbl cascade;
NOTICE:  drop cascades to view rw_view1
-- bug 29
CREATE TABLE base_tbl (a int PRIMARY KEY, b varchar(50) DEFAULT 'Unspecified');
INSERT INTO base_tbl SELECT i, 'Row ' i FROM generate_series(-2, 2) g(i);
CREATE VIEW rw_view16 AS SELECT a, b, a AS aa FROM base_tbl;
UPDATE rw_view16 SET aa=-3 WHERE a=3;
UPDATE rw_view16 SET aa=-5 WHERE a=5;
select*from rw_view16;
 a  |  b   | aa 
----+------+----
 -2 | Row  | -2
 -1 | Row  | -1
  0 | Row  |  0
  1 | Row  |  1
  2 | Row  |  2
(5 rows)

delete from rw_view16 where aa=2;
insert into rw_view16 values(4,'new row');
UPDATE rw_view16 SET aa=-4 WHERE a=4;
select*from rw_view16;
 a  |    b    | aa 
----+---------+----
 -4 | new row | -4
 -2 | Row     | -2
 -1 | Row     | -1
  0 | Row     |  0
  1 | Row     |  1
(5 rows)

drop table base_tbl cascade;
NOTICE:  drop cascades to view rw_view16
CREATE TABLE base_tbl(a int primary key, b varchar(50), c float);
CREATE VIEW rw_view2 AS SELECT b AS bb, c AS cc, a AS aa FROM base_tbl;
UPDATE base_tbl SET a=a, c=c;
NOTICE:  Kunlun-db: No target columns found in update statement UPDATE base_tbl SET a=a, c=c;, query execution skipped.
UPDATE rw_view2 SET bb=bb, cc=cc;
NOTICE:  Kunlun-db: No target columns found in update statement UPDATE rw_view2 SET bb=bb, cc=cc;, query execution skipped.
select*from base_tbl;
 a | b | c 
---+---+---
(0 rows)

select*from rw_view2;
 bb | cc | aa 
----+----+----
(0 rows)

drop table base_tbl cascade;
NOTICE:  drop cascades to view rw_view2
-- bug 39
CREATE TABLE SUBSELECT_TBL ( id serial primary key, f1 integer, f2 integer, f3 float );
INSERT INTO SUBSELECT_TBL (f1, f2, f3) VALUES (1, 2, 3), (2, 3, 4), (3, 4, 5), (1, 1, 1), (2, 2, 2), (3, 3, 3), (6, 7, 8), (8, 9, NULL);
SELECT f1 AS "Correlated Field", f2 AS "Second Field" FROM SUBSELECT_TBL upper WHERE f1 IN (SELECT f2 FROM SUBSELECT_TBL WHERE f1 = upper.f1);
 Correlated Field | Second Field 
------------------+--------------
                1 |            2
                2 |            3
                3 |            4
                1 |            1
                2 |            2
                3 |            3
(6 rows)

drop table SUBSELECT_TBL;
create temp table rngfunc(f1 int8, f2 int8);
create function testrngfunc() returns record as $$

    insert into rngfunc values (1,2) returning *;

$$ language sql;
select testrngfunc();
 testrngfunc 
-------------
 (1,2)
(1 row)

select * from testrngfunc() as t(f1 int8,f2 int8);
 f1 | f2 
----+----
  1 |  2
(1 row)

select * from testrngfunc() as t(f1 int8,f2 int8);
 f1 | f2 
----+----
  1 |  2
(1 row)

-- bug 48
create user userw;
ERROR:  role "userw" already exists
SELECT SESSION_USER, CURRENT_USER;
 session_user | current_user 
--------------+--------------
 dzw          | dzw
(1 row)

SET SESSION AUTHORIZATION userw;
create table testu1(id integer primary key, name varchar(50));
insert into testu1 values(1, 'userx');
insert into testu1 values(2, 'userw');
SELECT SESSION_USER, CURRENT_USER;
 session_user | current_user 
--------------+--------------
 userw        | userw
(1 row)

drop table testu1;
SET SESSION AUTHORIZATION dzw;
-- bug 51
CREATE TABLE r1 (id serial primary key, a int);
CREATE TABLE r2 (id serial primary key, a int);
INSERT INTO r1 (a) VALUES (10), (20);
INSERT INTO r2 (a) VALUES (10), (20);
INSERT INTO r1 (a) SELECT a + 1 FROM r2;
INSERT INTO r1 (a) SELECT a + 1 FROM r2 RETURNING *;
 id | a  
----+----
  5 | 11
  6 | 21
(2 rows)

select*from r1;
 id | a  
----+----
  1 | 10
  2 | 20
  3 | 11
  4 | 21
  5 | 11
  6 | 21
(6 rows)

select*from r2;
 id | a  
----+----
  1 | 10
  2 | 20
(2 rows)

drop table r1;
drop table r2;
-- bug 60
create table at_base_table(id int primary key, stuff text);
insert into at_base_table values (23, 'skidoo');
create view at_view_1 as select * from at_base_table bt;
create view at_view_2 as select *, to_json(v1) as j from at_view_1 v1;
explain (verbose, costs off) select * from at_view_2;
                                      QUERY PLAN                                       
---------------------------------------------------------------------------------------
 RemoteScan on public.at_base_table bt
   Output: bt.id, bt.stuff, to_json(ROW(bt.id, bt.stuff))
   Shard: 2      Remote SQL: select id, stuff from regression_$$_public.at_base_table 
(3 rows)

explain (verbose, costs off) select * from at_view_1;
                                      QUERY PLAN                                       
---------------------------------------------------------------------------------------
 RemoteScan on public.at_base_table bt
   Output: bt.id, bt.stuff
   Shard: 2      Remote SQL: select id, stuff from regression_$$_public.at_base_table 
(3 rows)

select * from at_view_2;
 id | stuff  |             j              
----+--------+----------------------------
 23 | skidoo | {"id":23,"stuff":"skidoo"}
(1 row)

select * from at_view_1;
 id | stuff  
----+--------
 23 | skidoo
(1 row)

drop table at_base_table cascade;
NOTICE:  drop cascades to 2 other objects
DETAIL:  drop cascades to view at_view_1
drop cascades to view at_view_2
-- bug 69
drop table if exists pagg_tab_m;
NOTICE:  table "pagg_tab_m" does not exist, skipping
CREATE TABLE pagg_tab_m (id serial , a int, b int, c int, primary key(id, a,b)) PARTITION BY RANGE(a, b);
CREATE TABLE pagg_tab_m_p1 PARTITION OF pagg_tab_m FOR VALUES FROM (0, 0) TO (10, 10);
CREATE TABLE pagg_tab_m_p2 PARTITION OF pagg_tab_m FOR VALUES FROM (10, 10) TO (20, 20);
CREATE TABLE pagg_tab_m_p3 PARTITION OF pagg_tab_m FOR VALUES FROM (20, 20) TO (30, 30);
INSERT INTO pagg_tab_m(a,b,c) SELECT i % 30, i % 40, i % 50 FROM generate_series(0, 2999) i;
EXPLAIN (COSTS OFF)
SELECT a, sum(b), avg(c), count(*) FROM pagg_tab_m GROUP BY a, (a+b)/2 HAVING sum(b) < 50 ORDER BY 1, 2, 3;
                                                          QUERY PLAN                                                          
------------------------------------------------------------------------------------------------------------------------------
 Sort
   Sort Key: pagg_tab_m_p1.a, (sum(pagg_tab_m_p1.b)), (avg(pagg_tab_m_p1.c))
   ->  HashAggregate
         Group Key: pagg_tab_m_p1.a, pagg_tab_m_p1."((a + b) DIV 2)"
         Filter: (sum(pagg_tab_m_p1.b) < 50)
         ->  Append
               ->  Materialize
                     ->  RemoteScan on pagg_tab_m_p1
                           Shard: 2      Remote SQL: select a, ((a + b) DIV 2), b, c from regression_$$_public.pagg_tab_m_p1 
               ->  Materialize
                     ->  RemoteScan on pagg_tab_m_p2
                           Shard: 2      Remote SQL: select a, ((a + b) DIV 2), b, c from regression_$$_public.pagg_tab_m_p2 
               ->  RemoteScan on pagg_tab_m_p3
                     Shard: 2    Remote SQL: select a, ((a + b) DIV 2), b, c from regression_$$_public.pagg_tab_m_p3 
(14 rows)

SELECT a, sum(b), avg(c), count(*) FROM pagg_tab_m GROUP BY a, (a+b)/2 HAVING sum(b) < 50 ORDER BY 1, 2, 3;
 a  | sum |         avg         | count 
----+-----+---------------------+-------
  0 |   0 | 20.0000000000000000 |    25
  1 |  25 | 21.0000000000000000 |    25
 10 |   0 | 20.0000000000000000 |    25
 11 |  25 | 21.0000000000000000 |    25
 20 |   0 | 20.0000000000000000 |    25
 21 |  25 | 21.0000000000000000 |    25
(6 rows)

EXPLAIN (COSTS OFF)
SELECT a, c, sum(b), avg(c), count(*) FROM pagg_tab_m GROUP BY (a+b)/2, 2, 1 HAVING sum(b) = 50 AND avg(c) > 25 ORDER BY 1, 2, 3;
                                                          QUERY PLAN                                                          
------------------------------------------------------------------------------------------------------------------------------
 Sort
   Sort Key: pagg_tab_m_p1.a, pagg_tab_m_p1.c, (sum(pagg_tab_m_p1.b))
   ->  HashAggregate
         Group Key: pagg_tab_m_p1."((a + b) DIV 2)", pagg_tab_m_p1.c, pagg_tab_m_p1.a
         Filter: ((sum(pagg_tab_m_p1.b) = 50) AND (avg(pagg_tab_m_p1.c) > '25'::numeric))
         ->  Append
               ->  Materialize
                     ->  RemoteScan on pagg_tab_m_p1
                           Shard: 2      Remote SQL: select a, c, ((a + b) DIV 2), b from regression_$$_public.pagg_tab_m_p1 
               ->  Materialize
                     ->  RemoteScan on pagg_tab_m_p2
                           Shard: 2      Remote SQL: select a, c, ((a + b) DIV 2), b from regression_$$_public.pagg_tab_m_p2 
               ->  RemoteScan on pagg_tab_m_p3
                     Shard: 2    Remote SQL: select a, c, ((a + b) DIV 2), b from regression_$$_public.pagg_tab_m_p3 
(14 rows)

SELECT a, c, sum(b), avg(c), count(*) FROM pagg_tab_m GROUP BY (a+b)/2, 2, 1 HAVING sum(b) = 50 AND avg(c) > 25 ORDER BY 1, 2, 3;
 a  | c  | sum |         avg         | count 
----+----+-----+---------------------+-------
  0 | 30 |  50 | 30.0000000000000000 |     5
  0 | 40 |  50 | 40.0000000000000000 |     5
 10 | 30 |  50 | 30.0000000000000000 |     5
 10 | 40 |  50 | 40.0000000000000000 |     5
 20 | 30 |  50 | 30.0000000000000000 |     5
 20 | 40 |  50 | 40.0000000000000000 |     5
(6 rows)

SELECT a, sum(b), avg(c), count(*) FROM pagg_tab_m GROUP BY a,b HAVING sum(b) < 2000 and avg(c) > 27;
 a  | sum |         avg         | count 
----+-----+---------------------+-------
 18 | 700 | 28.0000000000000000 |    25
 18 | 950 | 28.0000000000000000 |    25
  8 | 950 | 28.0000000000000000 |    25
 19 | 725 | 29.0000000000000000 |    25
 28 | 950 | 28.0000000000000000 |    25
 18 | 450 | 28.0000000000000000 |    25
  8 | 200 | 28.0000000000000000 |    25
 29 | 975 | 29.0000000000000000 |    25
 28 | 700 | 28.0000000000000000 |    25
 18 | 200 | 28.0000000000000000 |    25
 28 | 450 | 28.0000000000000000 |    25
  9 | 725 | 29.0000000000000000 |    25
  9 | 225 | 29.0000000000000000 |    25
  8 | 700 | 28.0000000000000000 |    25
 28 | 200 | 28.0000000000000000 |    25
  8 | 450 | 28.0000000000000000 |    25
 19 | 475 | 29.0000000000000000 |    25
 29 | 225 | 29.0000000000000000 |    25
 29 | 475 | 29.0000000000000000 |    25
  9 | 975 | 29.0000000000000000 |    25
 29 | 725 | 29.0000000000000000 |    25
 19 | 225 | 29.0000000000000000 |    25
  9 | 475 | 29.0000000000000000 |    25
 19 | 975 | 29.0000000000000000 |    25
(24 rows)

explain (verbose)
SELECT a, sum(b), avg(c), count(*) FROM pagg_tab_m GROUP BY a,b HAVING sum(b) < 2000 and avg(c) > 27;
                                             QUERY PLAN                                              
-----------------------------------------------------------------------------------------------------
 HashAggregate  (cost=0.07..0.13 rows=1 width=56)
   Output: pagg_tab_m_p1.a, sum(pagg_tab_m_p1.b), avg(pagg_tab_m_p1.c), count(*), pagg_tab_m_p1.b
   Group Key: pagg_tab_m_p1.a, pagg_tab_m_p1.b
   Filter: ((sum(pagg_tab_m_p1.b) < 2000) AND (avg(pagg_tab_m_p1.c) > '27'::numeric))
   ->  Append  (cost=0.00..0.01 rows=3 width=12)
         ->  Materialize  (cost=0.00..0.01 rows=1 width=12)
               Output: pagg_tab_m_p1.a, pagg_tab_m_p1.b, pagg_tab_m_p1.c
               ->  RemoteScan on public.pagg_tab_m_p1  (cost=0.00..0.00 rows=1 width=12)
                     Output: pagg_tab_m_p1.a, pagg_tab_m_p1.b, pagg_tab_m_p1.c
                     Shard: 2    Remote SQL: select a, b, c from regression_$$_public.pagg_tab_m_p1 
         ->  Materialize  (cost=0.00..0.01 rows=1 width=12)
               Output: pagg_tab_m_p2.a, pagg_tab_m_p2.b, pagg_tab_m_p2.c
               ->  RemoteScan on public.pagg_tab_m_p2  (cost=0.00..0.00 rows=1 width=12)
                     Output: pagg_tab_m_p2.a, pagg_tab_m_p2.b, pagg_tab_m_p2.c
                     Shard: 2    Remote SQL: select a, b, c from regression_$$_public.pagg_tab_m_p2 
         ->  RemoteScan on public.pagg_tab_m_p3  (cost=0.00..0.00 rows=1 width=12)
               Output: pagg_tab_m_p3.a, pagg_tab_m_p3.b, pagg_tab_m_p3.c
               Shard: 2  Remote SQL: select a, b, c from regression_$$_public.pagg_tab_m_p3 
(18 rows)

-- bug 53
drop table if exists trunc_stats_test1;
NOTICE:  table "trunc_stats_test1" does not exist, skipping
CREATE TABLE trunc_stats_test1(id serial primary key, stuff text);
insert into trunc_stats_test1 (stuff) values('abc'), ('xyz');
select*from trunc_stats_test1;
 id | stuff 
----+-------
  1 | abc
  2 | xyz
(2 rows)

UPDATE trunc_stats_test1 SET id = id + 10 WHERE id IN (1, 2);
select*from trunc_stats_test1;
 id | stuff 
----+-------
 11 | abc
 12 | xyz
(2 rows)

drop table if exists itest1;
NOTICE:  table "itest1" does not exist, skipping
CREATE TABLE itest1 (a int generated by default as identity primary key, b text);
INSERT INTO itest1 DEFAULT VALUES;
insert into itest1 values(DEFAULT, 'bbb');
INSERT INTO itest1 VALUES (2, 'b');
ERROR:  Kunlun-db: MySQL storage node (1, 1) returned error: 1062, Duplicate entry '2' for key 'PRIMARY'.
INSERT INTO itest1 VALUES (10, 'xyz');
UPDATE itest1 SET a = DEFAULT WHERE a = 2;
select*from itest1;
 a  |  b  
----+-----
  1 | 
  3 | bbb
 10 | xyz
(3 rows)

alter table itest1 add column c int default 3;
UPDATE itest1 SET c = DEFAULT WHERE a = 2;
select*from itest1;
 a  |  b  | c 
----+-----+---
  1 |     | 3
  3 | bbb | 3
 10 | xyz | 3
(3 rows)

insert into itest1(b,c) values('aaa', 44);
select*from itest1;
 a  |  b  | c  
----+-----+----
  1 |     |  3
  3 | bbb |  3
  4 | aaa | 44
 10 | xyz |  3
(4 rows)

UPDATE itest1 SET c = DEFAULT WHERE a = 2;
select*from itest1;
 a  |  b  | c  
----+-----+----
  1 |     |  3
  3 | bbb |  3
  4 | aaa | 44
 10 | xyz |  3
(4 rows)

insert into itest1(b,c) values('aaa', 44);
select*from itest1;
 a  |  b  | c  
----+-----+----
  1 |     |  3
  3 | bbb |  3
  4 | aaa | 44
  5 | aaa | 44
 10 | xyz |  3
(5 rows)

UPDATE itest1 SET c = DEFAULT WHERE a = 3;
select*from itest1;
 a  |  b  | c  
----+-----+----
  1 |     |  3
  3 | bbb |  3
  4 | aaa | 44
  5 | aaa | 44
 10 | xyz |  3
(5 rows)

UPDATE itest1 SET a = DEFAULT WHERE a = 3;
select*from itest1;
 a  |  b  | c  
----+-----+----
  1 |     |  3
  4 | aaa | 44
  5 | aaa | 44
  6 | bbb |  3
 10 | xyz |  3
(5 rows)

insert into itest1 values(DEFAULT, 'xxx', 333), (DEFAULT, 'yyy', 444);
select*from itest1;
 a  |  b  |  c  
----+-----+-----
  1 |     |   3
  4 | aaa |  44
  5 | aaa |  44
  6 | bbb |   3
  7 | xxx | 333
  8 | yyy | 444
 10 | xyz |   3
(7 rows)

-- bug 28
CREATE TABLE base_tbl (a int PRIMARY KEY, b varchar(50) DEFAULT 'Unspecified');
INSERT INTO base_tbl SELECT i, 'Row ' i FROM generate_series(-2, 2) g(i);
CREATE VIEW rw_view1 AS SELECT * FROM base_tbl WHERE a>0;
EXPLAIN (costs off) UPDATE rw_view1 SET a=6 WHERE a=5;
                 QUERY PLAN                 
--------------------------------------------
 Update on base_tbl
   ->  RemoteScan on base_tbl
         Filter: ((a > 0) AND (a = 5))
         Shard: 1        Remote SQL: (null)
(4 rows)

EXPLAIN (costs off) DELETE FROM rw_view1 WHERE a=5;
                 QUERY PLAN                 
--------------------------------------------
 Delete on base_tbl
   ->  RemoteScan on base_tbl
         Filter: ((a > 0) AND (a = 5))
         Shard: 1        Remote SQL: (null)
(4 rows)

DROP table if exists T;
NOTICE:  table "t" does not exist, skipping
CREATE TABLE T (pk INT NOT NULL PRIMARY KEY);
INSERT INTO T SELECT * FROM generate_series(1, 10) a;
EXPLAIN (VERBOSE TRUE, COSTS FALSE) DELETE FROM T WHERE pk BETWEEN 10 AND 20 RETURNING *;
                     QUERY PLAN                      
-----------------------------------------------------
 Delete on public.t
   Output: ctid
   ->  RemoteScan on public.t
         Output: t.*
         Filter: ((t.ctid >= 10) AND (t.ctid <= 20))
         Shard: 2        Remote SQL: (null)
(6 rows)

drop table if exists mvtest_t;
NOTICE:  table "mvtest_t" does not exist, skipping
CREATE TABLE mvtest_t (id int NOT NULL PRIMARY KEY, type varchar(50) NOT NULL, amt numeric NOT NULL);
EXPLAIN (costs off)
	CREATE MATERIALIZED VIEW mvtest_tm AS SELECT type, sum(amt) AS totamt FROM mvtest_t GROUP BY type WITH NO DATA;
                                          QUERY PLAN                                          
----------------------------------------------------------------------------------------------
 HashAggregate
   Group Key: type
   ->  RemoteScan on mvtest_t
         Shard: 1        Remote SQL: select id, type, amt from regression_$$_public.mvtest_t 
(4 rows)

-- bug 36
create table parted_conflict (a int primary key, b text) partition by range (a);
create table parted_conflict_1 partition of parted_conflict for values from (0) to (1000) partition by range (a);
create table parted_conflict_1_1 partition of parted_conflict_1 for values from (0) to (500);
insert into parted_conflict values (40, 'forty'), (30, 'thirty');
alter table parted_conflict add column c int default 3;
select*from parted_conflict;
 a  |   b    | c 
----+--------+---
 30 | thirty | 3
 40 | forty  | 3
(2 rows)

delete from parted_conflict where a = 30;
update parted_conflict set c=c+10 where a=40;
select*from parted_conflict;
 a  |   b   | c  
----+-------+----
 40 | forty | 13
(1 row)

drop table parted_conflict;
-- bug 43 
drop table if exists int4_tbl cascade;
NOTICE:  table "int4_tbl" does not exist, skipping
drop table if exists int8_tbl cascade;
NOTICE:  table "int8_tbl" does not exist, skipping
drop table if exists text_tbl cascade;
NOTICE:  table "text_tbl" does not exist, skipping
CREATE TABLE INT4_TBL(id serial primary key, f1 int4);
CREATE TABLE INT8_TBL(id serial primary key, q1 int8, q2 int8);
CREATE TABLE TEXT_TBL (id serial primary key, f1 text);
insert into int4_tbl(f1) values(1),(2),(3),(4);
insert into int8_tbl(q1, q2) values(1,2),(2,3),(3,4),(4,5);
insert into text_tbl(f1) values('1'),('2'),('3'),('4'),('5');
explain (verbose, costs off)
select * from
    text_tbl t1
    left join int8_tbl i8
    on i8.q2 = 2,
    lateral (select i8.q1, t2.f1 from text_tbl t2 limit 1) as ss1,
    lateral (select ss1.* from text_tbl t3 limit 1) as ss2
where t1.f1 = ss2.f1;
                                                    QUERY PLAN                                                    
------------------------------------------------------------------------------------------------------------------
 Nested Loop
   Output: t1.id, t1.f1, i8.id, i8.q1, i8.q2, (i8.q1), t2.q1, ((i8.q1)), (t2.q1)
   Join Filter: (t1.f1 = (t2.q1))
   ->  Nested Loop
         Output: t1.id, t1.f1, i8.id, i8.q1, i8.q2, (i8.q1), t2.q1
         ->  Nested Loop Left Join
               Output: t1.id, t1.f1, i8.id, i8.q1, i8.q2
               ->  Materialize
                     Output: t1.id, t1.f1
                     ->  RemoteScan on public.text_tbl t1
                           Output: t1.id, t1.f1
                           Shard: 2      Remote SQL: select id, f1 from regression_$$_public.text_tbl 
               ->  RemoteScan on public.int8_tbl i8
                     Output: i8.id, i8.q1, i8.q2
                     Filter: (i8.q2 = 2)
                     Shard: 1    Remote SQL: select id, q1, q2 from regression_$$_public.int8_tbl  where (q2 = 2)
         ->  Materialize
               Output: (i8.q1), t2.q1
               ->  Limit
                     Output: (i8.q1), t2.q1
                     ->  Materialize
                           Output: i8.q1, t2.q1
                           ->  RemoteScan on public.text_tbl t2
                                 Output: i8.q1, t2.q1
                                 Shard: 2        Remote SQL: select f1 from regression_$$_public.text_tbl 
   ->  Materialize
         Output: ((i8.q1)), (t2.q1)
         ->  Limit
               Output: ((i8.q1)), (t2.q1)
               ->  Materialize
                     Output: (i8.q1), t2.q1
                     ->  RemoteScan on public.text_tbl t3
                           Output: (i8.q1), t2.q1
                           Shard: 2      Remote SQL: select f1 from regression_$$_public.text_tbl 
(34 rows)

-- AND no explain--
select * from
    text_tbl t1
    left join int8_tbl i8
    on i8.q2 = 2,
    lateral (select i8.q1, t2.f1 from text_tbl t2 limit 1) as ss1,
    lateral (select ss1.* from text_tbl t3 limit 1) as ss2
where t1.f1 = ss2.f1;
 id | f1 | id | q1 | q2 | q1 | f1 | q1 | f1 
----+----+----+----+----+----+----+----+----
  1 | 1  |  1 |  1 |  2 |  1 | 1  |  1 | 1
(1 row)

-- AND --
explain (verbose)
select ss2.* from
    int4_tbl i41
    left join int8_tbl i8
        join (select i42.f1 as c1, i43.f1 as c2, 42 as c3
            from int4_tbl i42, int4_tbl i43) ss1
        on i8.q1 = ss1.c2
    on i41.f1 = ss1.c1,
    lateral (select i41.*, i8.*, ss1.* from text_tbl limit 1) ss2
where ss1.c2 = 2;
                                                    QUERY PLAN                                                    
------------------------------------------------------------------------------------------------------------------
 Nested Loop  (cost=0.00..0.05 rows=1 width=40)
   Output: (i41.id), (i41.f1), (i8.id), (i8.q1), (i8.q2), (i42.f1), (i43.f1), ((42))
   ->  Nested Loop  (cost=0.00..0.03 rows=1 width=40)
         Output: i41.id, i41.f1, i42.f1, i8.id, i8.q1, i8.q2, i43.f1, 42
         ->  Nested Loop  (cost=0.00..0.02 rows=1 width=32)
               Output: i41.id, i41.f1, i42.f1, i8.id, i8.q1, i8.q2
               ->  Nested Loop  (cost=0.00..0.01 rows=1 width=12)
                     Output: i41.id, i41.f1, i42.f1
                     Join Filter: (i41.f1 = i42.f1)
                     ->  Materialize  (cost=0.00..0.01 rows=1 width=8)
                           Output: i41.id, i41.f1
                           ->  RemoteScan on public.int4_tbl i41  (cost=0.00..0.00 rows=1 width=8)
                                 Output: i41.id, i41.f1
                                 Shard: 2        Remote SQL: select id, f1 from regression_$$_public.int4_tbl 
                     ->  Materialize  (cost=0.00..0.01 rows=1 width=4)
                           Output: i42.id, i42.f1
                           ->  RemoteScan on public.int4_tbl i42  (cost=0.00..0.00 rows=1 width=4)
                                 Output: i42.id, i42.f1
                                 Shard: 2        Remote SQL: select id, f1 from regression_$$_public.int4_tbl 
               ->  RemoteScan on public.int8_tbl i8  (cost=0.00..0.00 rows=1 width=20)
                     Output: i8.id, i8.q1, i8.q2
                     Filter: (i8.q1 = 2)
                     Shard: 1    Remote SQL: select id, q1, q2 from regression_$$_public.int8_tbl  where (q1 = 2)
         ->  Materialize  (cost=0.00..0.01 rows=1 width=4)
               Output: i43.id, i43.f1
               ->  RemoteScan on public.int4_tbl i43  (cost=0.00..0.00 rows=1 width=4)
                     Output: i43.id, i43.f1
                     Filter: (i43.f1 = 2)
                     Shard: 2    Remote SQL: select id, f1 from regression_$$_public.int4_tbl  where (f1 = 2)
   ->  Materialize  (cost=0.00..0.01 rows=1 width=40)
         Output: (i41.id), (i41.f1), (i8.id), (i8.q1), (i8.q2), (i42.f1), (i43.f1), ((42))
         ->  Limit  (cost=0.00..0.00 rows=1 width=40)
               Output: (i41.id), (i41.f1), (i8.id), (i8.q1), (i8.q2), (i42.f1), (i43.f1), ((42))
               ->  Materialize  (cost=0.00..0.01 rows=1 width=40)
                     Output: i41.id, i41.f1, i8.id, i8.q1, i8.q2, i42.f1, i43.f1, (42)
                     ->  RemoteScan on public.text_tbl  (cost=0.00..0.00 rows=1 width=40)
                           Output: i41.id, i41.f1, i8.id, i8.q1, i8.q2, i42.f1, i43.f1, (42)
                           Shard: 2      Remote SQL: select f1 from regression_$$_public.text_tbl 
(38 rows)

select ss2.* from
    int4_tbl i41
    left join int8_tbl i8
        join (select i42.f1 as c1, i43.f1 as c2, 42 as c3
            from int4_tbl i42, int4_tbl i43) ss1
        on i8.q1 = ss1.c2
    on i41.f1 = ss1.c1,
    lateral (select i41.*, i8.*, ss1.* from text_tbl limit 1) ss2
where ss1.c2 = 2;
 id | f1 | id | q1 | q2 | c1 | c2 | c3 
----+----+----+----+----+----+----+----
  1 |  1 |  2 |  2 |  3 |  1 |  2 | 42
  2 |  2 |  2 |  2 |  3 |  2 |  2 | 42
  3 |  3 |  2 |  2 |  3 |  3 |  2 | 42
  4 |  4 |  2 |  2 |  3 |  4 |  2 | 42
(4 rows)

-----------------------------
drop table if exists rngfunc2 cascade;
NOTICE:  table "rngfunc2" does not exist, skipping
CREATE TABLE rngfunc2(id serial primary key, rngfuncid int, f2 int);
INSERT INTO rngfunc2(rngfuncid, f2) VALUES(1, 11);
INSERT INTO rngfunc2(rngfuncid, f2) VALUES(2, 22);
INSERT INTO rngfunc2(rngfuncid, f2) VALUES(1, 111);
drop function if exists rngfunct;
NOTICE:  function rngfunct() does not exist, skipping
CREATE FUNCTION rngfunct(int) returns setof rngfunc2 as 'SELECT * FROM rngfunc2 WHERE rngfuncid = $1 ORDER BY f2;' LANGUAGE SQL;
select * from rngfunc2, rngfunct(rngfunc2.rngfuncid) z where rngfunc2.f2 = z.f2;
 id | rngfuncid | f2  | id | rngfuncid | f2  
----+-----------+-----+----+-----------+-----
  1 |         1 |  11 |  1 |         1 |  11
  2 |         2 |  22 |  2 |         2 |  22
  3 |         1 | 111 |  3 |         1 | 111
(3 rows)

select * from rngfunc2, rngfunct(rngfunc2.rngfuncid) with ordinality as z(rngfuncid,f2,ord) where rngfunc2.f2 = z.f2;
 id | rngfuncid | f2 | rngfuncid | f2 | ord | ordinality 
----+-----------+----+-----------+----+-----+------------
(0 rows)

select * from rngfunc2 where f2 in (select f2 from rngfunct(rngfunc2.rngfuncid) z where z.rngfuncid = rngfunc2.rngfuncid) ORDER BY 1,2;
 id | rngfuncid | f2  
----+-----------+-----
  1 |         1 |  11
  2 |         2 |  22
  3 |         1 | 111
(3 rows)

select * from rngfunc2 where f2 in (select f2 from rngfunct(1) z where z.rngfuncid = rngfunc2.rngfuncid) ORDER BY 1,2;
 id | rngfuncid | f2  
----+-----------+-----
  1 |         1 |  11
  3 |         1 | 111
(2 rows)

select * from rngfunc2 where f2 in (select f2 from rngfunct(rngfunc2.rngfuncid) z where z.rngfuncid = 1) ORDER BY 1,2;
 id | rngfuncid | f2  
----+-----------+-----
  1 |         1 |  11
  3 |         1 | 111
(2 rows)

DROP TABLE if exists prt1_l cascade;
NOTICE:  table "prt1_l" does not exist, skipping
CREATE TABLE prt1_l (a int , b int, c varchar, primary key(a,c,b)) PARTITION BY RANGE(a);
CREATE TABLE prt1_l_p1 PARTITION OF prt1_l FOR VALUES FROM (0) TO (250);
CREATE TABLE prt1_l_p2 PARTITION OF prt1_l FOR VALUES FROM (250) TO (500) PARTITION BY LIST (c);
CREATE TABLE prt1_l_p2_p1 PARTITION OF prt1_l_p2 FOR VALUES IN ('0000', '0001');
CREATE TABLE prt1_l_p2_p2 PARTITION OF prt1_l_p2 FOR VALUES IN ('0002', '0003');
CREATE TABLE prt1_l_p3 PARTITION OF prt1_l FOR VALUES FROM (500) TO (600) PARTITION BY RANGE (b);
CREATE TABLE prt1_l_p3_p1 PARTITION OF prt1_l_p3 FOR VALUES FROM (0) TO (13);
CREATE TABLE prt1_l_p3_p2 PARTITION OF prt1_l_p3 FOR VALUES FROM (13) TO (25);
INSERT INTO prt1_l SELECT i, i % 25, to_char(i % 4, 'FM0000') FROM generate_series(0, 599, 2) i;
DROP TABLE if exists prt2_l;
NOTICE:  table "prt2_l" does not exist, skipping
CREATE TABLE prt2_l (a int, b int , c varchar, primary key(b,c,a)) PARTITION BY RANGE(b);
CREATE TABLE prt2_l_p1 PARTITION OF prt2_l FOR VALUES FROM (0) TO (250);
CREATE TABLE prt2_l_p2 PARTITION OF prt2_l FOR VALUES FROM (250) TO (500) PARTITION BY LIST (c);
CREATE TABLE prt2_l_p2_p1 PARTITION OF prt2_l_p2 FOR VALUES IN ('0000', '0001');
CREATE TABLE prt2_l_p2_p2 PARTITION OF prt2_l_p2 FOR VALUES IN ('0002', '0003');
CREATE TABLE prt2_l_p3 PARTITION OF prt2_l FOR VALUES FROM (500) TO (600) PARTITION BY RANGE (a);
CREATE TABLE prt2_l_p3_p1 PARTITION OF prt2_l_p3 FOR VALUES FROM (0) TO (13);
CREATE TABLE prt2_l_p3_p2 PARTITION OF prt2_l_p3 FOR VALUES FROM (13) TO (25);
INSERT INTO prt2_l SELECT i % 25, i, to_char(i % 4, 'FM0000') FROM generate_series(0, 599, 3) i;
SELECT * FROM prt1_l t1 LEFT JOIN LATERAL (SELECT t2.a AS t2a, t2.c AS t2c, t2.b AS t2b, t3.b AS t3b, least(t1.a,t2.a,t3.b) FROM prt1_l t2 JOIN prt2_l t3 ON (t2.a = t3.b AND t2.c = t3.c)) ss ON t1.a = ss.t2a AND t1.c = ss.t2c WHERE t1.b = 0 ORDER BY t1.a;
  a  | b |  c   | t2a | t2c  | t2b | t3b | least 
-----+---+------+-----+------+-----+-----+-------
   0 | 0 | 0000 |   0 | 0000 |   0 |   0 |     0
  50 | 0 | 0002 |     |      |     |     |      
 100 | 0 | 0000 |     |      |     |     |      
 150 | 0 | 0002 | 150 | 0002 |   0 | 150 |   150
 200 | 0 | 0000 |     |      |     |     |      
 250 | 0 | 0002 |     |      |     |     |      
 300 | 0 | 0000 | 300 | 0000 |   0 | 300 |   300
 350 | 0 | 0002 |     |      |     |     |      
 400 | 0 | 0000 |     |      |     |     |      
 450 | 0 | 0002 | 450 | 0002 |   0 | 450 |   450
 500 | 0 | 0000 |     |      |     |     |      
 550 | 0 | 0002 |     |      |     |     |      
(12 rows)

EXPLAIN(verbose)
SELECT * FROM prt1_l t1 LEFT JOIN LATERAL (SELECT t2.a AS t2a, t2.c AS t2c, t2.b AS t2b, t3.b AS t3b, least(t1.a,t2.a,t3.b) FROM prt1_l t2 JOIN prt2_l t3 ON (t2.a = t3.b AND t2.c = t3.c)) ss ON t1.a = ss.t2a AND t1.c = ss.t2c WHERE t1.b = 0 ORDER BY t1.a;
                                                        QUERY PLAN                                                        
--------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=0.50..0.51 rows=4 width=92)
   Output: t1.a, t1.b, t1.c, t2.a, t2.c, t2.b, , (LEAST(t1.a, t2.a, )), t1.a
   Sort Key: t1.a
   ->  Nested Loop Left Join  (cost=0.10..0.46 rows=4 width=92)
         Output: t1.a, t1.b, t1.c, t2.a, t2.c, t2.b, , (LEAST(t1.a, t2.a, )), t1.a
         ->  Append  (cost=0.00..0.02 rows=4 width=40)
               ->  Materialize  (cost=0.00..0.01 rows=1 width=40)
                     Output: t1.a, t1.b, t1.c
                     ->  RemoteScan on public.prt1_l_p1 t1  (cost=0.00..0.00 rows=1 width=40)
                           Output: t1.a, t1.b, t1.c
                           Filter: (t1.b = 0)
                           Shard: 1      Remote SQL: select a, b, c from regression_$$_public.prt1_l_p1  where (b = 0)
               ->  Materialize  (cost=0.00..0.01 rows=1 width=40)
                     Output: t1_1.a, t1_1.b, t1_1.c
                     ->  RemoteScan on public.prt1_l_p2_p1 t1_1  (cost=0.00..0.00 rows=1 width=40)
                           Output: t1_1.a, t1_1.b, t1_1.c
                           Filter: (t1_1.b = 0)
                           Shard: 2      Remote SQL: select a, b, c from regression_$$_public.prt1_l_p2_p1  where (b = 0)
               ->  Materialize  (cost=0.00..0.01 rows=1 width=40)
                     Output: t1_2.a, t1_2.b, t1_2.c
                     ->  RemoteScan on public.prt1_l_p2_p2 t1_2  (cost=0.00..0.00 rows=1 width=40)
                           Output: t1_2.a, t1_2.b, t1_2.c
                           Filter: (t1_2.b = 0)
                           Shard: 1      Remote SQL: select a, b, c from regression_$$_public.prt1_l_p2_p2  where (b = 0)
               ->  Materialize  (cost=0.00..0.01 rows=1 width=40)
                     Output: t1_3.a, t1_3.b, t1_3.c
                     ->  RemoteScan on public.prt1_l_p3_p1 t1_3  (cost=0.00..0.00 rows=1 width=40)
                           Output: t1_3.a, t1_3.b, t1_3.c
                           Filter: (t1_3.b = 0)
                           Shard: 1      Remote SQL: select a, b, c from regression_$$_public.prt1_l_p3_p1  where (b = 0)
         ->  Materialize  (cost=0.10..0.18 rows=1 width=48)
               Output: t2.a, t2.c, t2.b, , LEAST(t1.a, t2.a, )
               ->  Hash Join  (cost=0.10..0.17 rows=1 width=48)
                     Output: t2.a, t2.c, t2.b, t3.b, LEAST(t1.a, t2.a, t3.b)
                     Hash Cond: ((t2.a = t3.b) AND ((t2.c)::text = (t3.c)::text))
                     ->  Append  (cost=0.00..0.03 rows=5 width=40)
                           ->  Materialize  (cost=0.00..0.01 rows=1 width=40)
                                 Output: t2.a, t2.c, t2.b
                                 ->  RemoteScan on public.prt1_l_p1 t2  (cost=0.00..0.00 rows=1 width=40)
                                       Output: t2.a, t2.c, t2.b
                                       Filter: ((t1.a = t2.a) AND ((t1.c)::text = (t2.c)::text))
                                       Shard: 1  Remote SQL: select a, c, b from regression_$$_public.prt1_l_p1 
                           ->  Materialize  (cost=0.00..0.01 rows=1 width=40)
                                 Output: t2_1.a, t2_1.c, t2_1.b
                                 ->  RemoteScan on public.prt1_l_p2_p1 t2_1  (cost=0.00..0.00 rows=1 width=40)
                                       Output: t2_1.a, t2_1.c, t2_1.b
                                       Filter: ((t1.a = t2_1.a) AND ((t1.c)::text = (t2_1.c)::text))
                                       Shard: 2  Remote SQL: select a, c, b from regression_$$_public.prt1_l_p2_p1 
                           ->  Materialize  (cost=0.00..0.01 rows=1 width=40)
                                 Output: t2_2.a, t2_2.c, t2_2.b
                                 ->  RemoteScan on public.prt1_l_p2_p2 t2_2  (cost=0.00..0.00 rows=1 width=40)
                                       Output: t2_2.a, t2_2.c, t2_2.b
                                       Filter: ((t1.a = t2_2.a) AND ((t1.c)::text = (t2_2.c)::text))
                                       Shard: 1  Remote SQL: select a, c, b from regression_$$_public.prt1_l_p2_p2 
                           ->  Materialize  (cost=0.00..0.01 rows=1 width=40)
                                 Output: t2_3.a, t2_3.c, t2_3.b
                                 ->  RemoteScan on public.prt1_l_p3_p1 t2_3  (cost=0.00..0.00 rows=1 width=40)
                                       Output: t2_3.a, t2_3.c, t2_3.b
                                       Filter: ((t1.a = t2_3.a) AND ((t1.c)::text = (t2_3.c)::text))
                                       Shard: 1  Remote SQL: select a, c, b from regression_$$_public.prt1_l_p3_p1 
                           ->  Materialize  (cost=0.00..0.01 rows=1 width=40)
                                 Output: t2_4.a, t2_4.c, t2_4.b
                                 ->  RemoteScan on public.prt1_l_p3_p2 t2_4  (cost=0.00..0.00 rows=1 width=40)
                                       Output: t2_4.a, t2_4.c, t2_4.b
                                       Filter: ((t1.a = t2_4.a) AND ((t1.c)::text = (t2_4.c)::text))
                                       Shard: 1  Remote SQL: select a, c, b from regression_$$_public.prt1_l_p3_p2 
                     ->  Hash  (cost=0.03..0.03 rows=5 width=36)
                           Output: t3.b, t3.c
                           ->  Append  (cost=0.00..0.03 rows=5 width=36)
                                 ->  Materialize  (cost=0.00..0.01 rows=1 width=36)
                                       Output: t3.b, t3.c
                                       ->  RemoteScan on public.prt2_l_p1 t3  (cost=0.00..0.00 rows=1 width=36)
                                             Output: t3.b, t3.c
                                             Shard: 2    Remote SQL: select b, c from regression_$$_public.prt2_l_p1 
                                 ->  Materialize  (cost=0.00..0.01 rows=1 width=36)
                                       Output: t3_1.b, t3_1.c
                                       ->  RemoteScan on public.prt2_l_p2_p1 t3_1  (cost=0.00..0.00 rows=1 width=36)
                                             Output: t3_1.b, t3_1.c
                                             Shard: 2    Remote SQL: select b, c from regression_$$_public.prt2_l_p2_p1 
                                 ->  Materialize  (cost=0.00..0.01 rows=1 width=36)
                                       Output: t3_2.b, t3_2.c
                                       ->  RemoteScan on public.prt2_l_p2_p2 t3_2  (cost=0.00..0.00 rows=1 width=36)
                                             Output: t3_2.b, t3_2.c
                                             Shard: 1    Remote SQL: select b, c from regression_$$_public.prt2_l_p2_p2 
                                 ->  Materialize  (cost=0.00..0.01 rows=1 width=36)
                                       Output: t3_3.b, t3_3.c
                                       ->  RemoteScan on public.prt2_l_p3_p1 t3_3  (cost=0.00..0.00 rows=1 width=36)
                                             Output: t3_3.b, t3_3.c
                                             Shard: 2    Remote SQL: select b, c from regression_$$_public.prt2_l_p3_p1 
                                 ->  RemoteScan on public.prt2_l_p3_p2 t3_4  (cost=0.00..0.00 rows=1 width=36)
                                       Output: t3_4.b, t3_4.c
                                       Shard: 1  Remote SQL: select b, c from regression_$$_public.prt2_l_p3_p2 
(92 rows)

-- bug 66 
DROP TABLE if exists prt1;
NOTICE:  table "prt1" does not exist, skipping
DROP TABLE if exists prt2;
NOTICE:  table "prt2" does not exist, skipping
CREATE TABLE prt1 (a int primary key, b int, c varchar) PARTITION BY RANGE(a);
CREATE TABLE prt1_p1 PARTITION OF prt1 FOR VALUES FROM (0) TO (250);
CREATE TABLE prt1_p3 PARTITION OF prt1 FOR VALUES FROM (500) TO (600);
CREATE TABLE prt1_p2 PARTITION OF prt1 FOR VALUES FROM (250) TO (500);
INSERT INTO prt1 SELECT i, i % 25, to_char(i, 'FM0000') FROM generate_series(0, 599) i WHERE i % 2 = 0;
CREATE TABLE prt2 (a int, b int primary key, c varchar) PARTITION BY RANGE(b);
CREATE TABLE prt2_p1 PARTITION OF prt2 FOR VALUES FROM (0) TO (250);
CREATE TABLE prt2_p2 PARTITION OF prt2 FOR VALUES FROM (250) TO (500);
CREATE TABLE prt2_p3 PARTITION OF prt2 FOR VALUES FROM (500) TO (600);
INSERT INTO prt2 SELECT i % 25, i, to_char(i, 'FM0000') FROM generate_series(0, 599) i WHERE i % 3 = 0;
SELECT t1, t2 FROM prt1 t1 LEFT JOIN prt2 t2 ON t1.a = t2.b WHERE t1.b = 0 ORDER BY t1.a, t2.b;
      t1      |      t2      
--------------+--------------
 (0,0,0000)   | (0,0,0000)
 (50,0,0050)  | 
 (100,0,0100) | 
 (150,0,0150) | (0,150,0150)
 (200,0,0200) | 
 (250,0,0250) | 
 (300,0,0300) | (0,300,0300)
 (350,0,0350) | 
 (400,0,0400) | 
 (450,0,0450) | (0,450,0450)
 (500,0,0500) | 
 (550,0,0550) | 
(12 rows)

EXPLAIN(verbose)
SELECT t1, t2 FROM prt1 t1 LEFT JOIN prt2 t2 ON t1.a = t2.b WHERE t1.b = 0 ORDER BY t1.a, t2.b;
                                                     QUERY PLAN                                                      
---------------------------------------------------------------------------------------------------------------------
 Sort  (cost=0.13..0.14 rows=3 width=72)
   Output: ((t1.*)::prt1), ((t2.*)::prt2), t1.a, t2.b
   Sort Key: t1.a, t2.b
   ->  Hash Left Join  (cost=0.05..0.11 rows=3 width=72)
         Output: ((t1.*)::prt1), ((t2.*)::prt2), t1.a, t2.b
         Hash Cond: (t1.a = t2.b)
         ->  Append  (cost=0.00..0.01 rows=3 width=36)
               ->  Materialize  (cost=0.00..0.01 rows=1 width=36)
                     Output: t1.*, t1.a
                     ->  RemoteScan on public.prt1_p1 t1  (cost=0.00..0.00 rows=1 width=36)
                           Output: t1.*, t1.a
                           Filter: (t1.b = 0)
                           Shard: 2      Remote SQL: select a, b, c from regression_$$_public.prt1_p1  where (b = 0)
               ->  Materialize  (cost=0.00..0.01 rows=1 width=36)
                     Output: t1_1.*, t1_1.a
                     ->  RemoteScan on public.prt1_p2 t1_1  (cost=0.00..0.00 rows=1 width=36)
                           Output: t1_1.*, t1_1.a
                           Filter: (t1_1.b = 0)
                           Shard: 1      Remote SQL: select a, b, c from regression_$$_public.prt1_p2  where (b = 0)
               ->  RemoteScan on public.prt1_p3 t1_2  (cost=0.00..0.00 rows=1 width=36)
                     Output: t1_2.*, t1_2.a
                     Filter: (t1_2.b = 0)
                     Shard: 1    Remote SQL: select a, b, c from regression_$$_public.prt1_p3  where (b = 0)
         ->  Hash  (cost=0.01..0.01 rows=3 width=36)
               Output: ((t2.*)::prt2), t2.b
               ->  Append  (cost=0.00..0.01 rows=3 width=36)
                     ->  Materialize  (cost=0.00..0.01 rows=1 width=36)
                           Output: t2.*, t2.b
                           ->  RemoteScan on public.prt2_p1 t2  (cost=0.00..0.00 rows=1 width=36)
                                 Output: t2.*, t2.b
                                 Shard: 2        Remote SQL: select a, b, c from regression_$$_public.prt2_p1 
                     ->  Materialize  (cost=0.00..0.01 rows=1 width=36)
                           Output: t2_1.*, t2_1.b
                           ->  RemoteScan on public.prt2_p2 t2_1  (cost=0.00..0.00 rows=1 width=36)
                                 Output: t2_1.*, t2_1.b
                                 Shard: 2        Remote SQL: select a, b, c from regression_$$_public.prt2_p2 
                     ->  RemoteScan on public.prt2_p3 t2_2  (cost=0.00..0.00 rows=1 width=36)
                           Output: t2_2.*, t2_2.b
                           Shard: 2      Remote SQL: select a, b, c from regression_$$_public.prt2_p3 
(39 rows)

SELECT t1.a, t2.b FROM prt1 t1, prt2 t2 WHERE t1::text = t2::text AND t1.a = t2.b ORDER BY t1.a;
ERROR:  Kunlun-db: Must specify whole-row target left-most.
EXPLAIN(verbose)
SELECT t1.a, t2.b FROM prt1 t1, prt2 t2 WHERE t1::text = t2::text AND t1.a = t2.b ORDER BY t1.a;
ERROR:  Kunlun-db: Must specify whole-row target left-most.
SELECT * FROM prt1 t1 LEFT JOIN  (SELECT t2.a AS t2a, t3.a AS t3a, least(t2.a,t3.b) FROM prt1 t2 JOIN prt2 t3 ON (t2.a = t3.b)) ss ON t1.a = ss.t2a WHERE t1.b = 0 ORDER BY t1.a;
  a  | b |  c   | t2a | t3a | least 
-----+---+------+-----+-----+-------
   0 | 0 | 0000 |   0 |   0 |     0
  50 | 0 | 0050 |     |     |      
 100 | 0 | 0100 |     |     |      
 150 | 0 | 0150 | 150 |   0 |   150
 200 | 0 | 0200 |     |     |      
 250 | 0 | 0250 |     |     |      
 300 | 0 | 0300 | 300 |   0 |   300
 350 | 0 | 0350 |     |     |      
 400 | 0 | 0400 |     |     |      
 450 | 0 | 0450 | 450 |   0 |   450
 500 | 0 | 0500 |     |     |      
 550 | 0 | 0550 |     |     |      
(12 rows)

EXPLAIN(verbose)
SELECT * FROM prt1 t1 LEFT JOIN  (SELECT t2.a AS t2a, t3.a AS t3a, least(t2.a,t3.b) FROM prt1 t2 JOIN prt2 t3 ON (t2.a = t3.b)) ss ON t1.a = ss.t2a WHERE t1.b = 0 ORDER BY t1.a;
                                                     QUERY PLAN                                                      
---------------------------------------------------------------------------------------------------------------------
 Merge Left Join  (cost=0.18..0.24 rows=3 width=56)
   Output: t1.a, t1.b, t1.c, t2.a, t3.a, (LEAST(t2.a, t3.b)), t1.a
   Merge Cond: (t1.a = t2.a)
   ->  Sort  (cost=0.04..0.05 rows=3 width=40)
         Output: t1.a, t1.b, t1.c
         Sort Key: t1.a
         ->  Append  (cost=0.00..0.01 rows=3 width=40)
               ->  Materialize  (cost=0.00..0.01 rows=1 width=40)
                     Output: t1.a, t1.b, t1.c
                     ->  RemoteScan on public.prt1_p1 t1  (cost=0.00..0.00 rows=1 width=40)
                           Output: t1.a, t1.b, t1.c
                           Filter: (t1.b = 0)
                           Shard: 2      Remote SQL: select a, b, c from regression_$$_public.prt1_p1  where (b = 0)
               ->  Materialize  (cost=0.00..0.01 rows=1 width=40)
                     Output: t1_1.a, t1_1.b, t1_1.c
                     ->  RemoteScan on public.prt1_p2 t1_1  (cost=0.00..0.00 rows=1 width=40)
                           Output: t1_1.a, t1_1.b, t1_1.c
                           Filter: (t1_1.b = 0)
                           Shard: 1      Remote SQL: select a, b, c from regression_$$_public.prt1_p2  where (b = 0)
               ->  Materialize  (cost=0.00..0.01 rows=1 width=40)
                     Output: t1_2.a, t1_2.b, t1_2.c
                     ->  RemoteScan on public.prt1_p3 t1_2  (cost=0.00..0.00 rows=1 width=40)
                           Output: t1_2.a, t1_2.b, t1_2.c
                           Filter: (t1_2.b = 0)
                           Shard: 1      Remote SQL: select a, b, c from regression_$$_public.prt1_p3  where (b = 0)
   ->  Sort  (cost=0.14..0.15 rows=3 width=12)
         Output: t2.a, t3.a, (LEAST(t2.a, t3.b))
         Sort Key: t2.a
         ->  Hash Join  (cost=0.05..0.12 rows=3 width=12)
               Output: t2.a, t3.a, LEAST(t2.a, t3.b)
               Hash Cond: (t2.a = t3.b)
               ->  Append  (cost=0.00..0.01 rows=3 width=4)
                     ->  Materialize  (cost=0.00..0.01 rows=1 width=4)
                           Output: t2.a
                           ->  RemoteScan on public.prt1_p1 t2  (cost=0.00..0.00 rows=1 width=4)
                                 Output: t2.a
                                 Shard: 2        Remote SQL: select a from regression_$$_public.prt1_p1 
                     ->  Materialize  (cost=0.00..0.01 rows=1 width=4)
                           Output: t2_1.a
                           ->  RemoteScan on public.prt1_p2 t2_1  (cost=0.00..0.00 rows=1 width=4)
                                 Output: t2_1.a
                                 Shard: 1        Remote SQL: select a from regression_$$_public.prt1_p2 
                     ->  RemoteScan on public.prt1_p3 t2_2  (cost=0.00..0.00 rows=1 width=4)
                           Output: t2_2.a
                           Shard: 1      Remote SQL: select a from regression_$$_public.prt1_p3 
               ->  Hash  (cost=0.01..0.01 rows=3 width=8)
                     Output: t3.a, t3.b
                     ->  Append  (cost=0.00..0.01 rows=3 width=8)
                           ->  Materialize  (cost=0.00..0.01 rows=1 width=8)
                                 Output: t3.a, t3.b
                                 ->  RemoteScan on public.prt2_p1 t3  (cost=0.00..0.00 rows=1 width=8)
                                       Output: t3.a, t3.b
                                       Shard: 2  Remote SQL: select a, b from regression_$$_public.prt2_p1 
                           ->  Materialize  (cost=0.00..0.01 rows=1 width=8)
                                 Output: t3_1.a, t3_1.b
                                 ->  RemoteScan on public.prt2_p2 t3_1  (cost=0.00..0.00 rows=1 width=8)
                                       Output: t3_1.a, t3_1.b
                                       Shard: 2  Remote SQL: select a, b from regression_$$_public.prt2_p2 
                           ->  RemoteScan on public.prt2_p3 t3_2  (cost=0.00..0.00 rows=1 width=8)
                                 Output: t3_2.a, t3_2.b
                                 Shard: 2        Remote SQL: select a, b from regression_$$_public.prt2_p3 
(61 rows)

SELECT * FROM prt1 t1 LEFT JOIN LATERAL (SELECT t2.a AS t2a, t3.a AS t3a, least(t1.a,t2.a,t3.b) FROM prt1 t2 JOIN prt2 t3 ON (t2.a = t3.b)) ss ON t1.a = ss.t2a WHERE t1.b = 0 ORDER BY t1.a;
  a  | b |  c   | t2a | t3a | least 
-----+---+------+-----+-----+-------
   0 | 0 | 0000 |   0 |   0 |     0
  50 | 0 | 0050 |     |     |      
 100 | 0 | 0100 |     |     |      
 150 | 0 | 0150 | 150 |   0 |   150
 200 | 0 | 0200 |     |     |      
 250 | 0 | 0250 |     |     |      
 300 | 0 | 0300 | 300 |   0 |   300
 350 | 0 | 0350 |     |     |      
 400 | 0 | 0400 |     |     |      
 450 | 0 | 0450 | 450 |   0 |   450
 500 | 0 | 0500 |     |     |      
 550 | 0 | 0550 |     |     |      
(12 rows)

EXPLAIN(verbose)
SELECT * FROM prt1 t1 LEFT JOIN LATERAL (SELECT t2.a AS t2a, t3.a AS t3a, least(t1.a,t2.a,t3.b) FROM prt1 t2 JOIN prt2 t3 ON (t2.a = t3.b)) ss ON t1.a = ss.t2a WHERE t1.b = 0 ORDER BY t1.a;
                                                     QUERY PLAN                                                      
---------------------------------------------------------------------------------------------------------------------
 Sort  (cost=0.37..0.38 rows=3 width=56)
   Output: t1.a, t1.b, t1.c, t2.a, , (LEAST(t1.a, t2.a, )), t1.a
   Sort Key: t1.a
   ->  Nested Loop Left Join  (cost=0.05..0.35 rows=3 width=56)
         Output: t1.a, t1.b, t1.c, t2.a, , (LEAST(t1.a, t2.a, )), t1.a
         ->  Append  (cost=0.00..0.01 rows=3 width=40)
               ->  Materialize  (cost=0.00..0.01 rows=1 width=40)
                     Output: t1.a, t1.b, t1.c
                     ->  RemoteScan on public.prt1_p1 t1  (cost=0.00..0.00 rows=1 width=40)
                           Output: t1.a, t1.b, t1.c
                           Filter: (t1.b = 0)
                           Shard: 2      Remote SQL: select a, b, c from regression_$$_public.prt1_p1  where (b = 0)
               ->  Materialize  (cost=0.00..0.01 rows=1 width=40)
                     Output: t1_1.a, t1_1.b, t1_1.c
                     ->  RemoteScan on public.prt1_p2 t1_1  (cost=0.00..0.00 rows=1 width=40)
                           Output: t1_1.a, t1_1.b, t1_1.c
                           Filter: (t1_1.b = 0)
                           Shard: 1      Remote SQL: select a, b, c from regression_$$_public.prt1_p2  where (b = 0)
               ->  Materialize  (cost=0.00..0.01 rows=1 width=40)
                     Output: t1_2.a, t1_2.b, t1_2.c
                     ->  RemoteScan on public.prt1_p3 t1_2  (cost=0.00..0.00 rows=1 width=40)
                           Output: t1_2.a, t1_2.b, t1_2.c
                           Filter: (t1_2.b = 0)
                           Shard: 1      Remote SQL: select a, b, c from regression_$$_public.prt1_p3  where (b = 0)
         ->  Materialize  (cost=0.05..0.13 rows=3 width=12)
               Output: t2.a, , LEAST(t1.a, t2.a, )
               ->  Hash Join  (cost=0.05..0.12 rows=3 width=12)
                     Output: t2.a, t3.a, LEAST(t1.a, t2.a, t3.b)
                     Hash Cond: (t2.a = t3.b)
                     ->  Append  (cost=0.00..0.01 rows=3 width=4)
                           ->  Materialize  (cost=0.00..0.01 rows=1 width=4)
                                 Output: t2.a
                                 ->  RemoteScan on public.prt1_p1 t2  (cost=0.00..0.00 rows=1 width=4)
                                       Output: t2.a
                                       Filter: (t1.a = t2.a)
                                       Shard: 2  Remote SQL: select a from regression_$$_public.prt1_p1 
                           ->  Materialize  (cost=0.00..0.01 rows=1 width=4)
                                 Output: t2_1.a
                                 ->  RemoteScan on public.prt1_p2 t2_1  (cost=0.00..0.00 rows=1 width=4)
                                       Output: t2_1.a
                                       Filter: (t1.a = t2_1.a)
                                       Shard: 1  Remote SQL: select a from regression_$$_public.prt1_p2 
                           ->  Materialize  (cost=0.00..0.01 rows=1 width=4)
                                 Output: t2_2.a
                                 ->  RemoteScan on public.prt1_p3 t2_2  (cost=0.00..0.00 rows=1 width=4)
                                       Output: t2_2.a
                                       Filter: (t1.a = t2_2.a)
                                       Shard: 1  Remote SQL: select a from regression_$$_public.prt1_p3 
                     ->  Hash  (cost=0.01..0.01 rows=3 width=8)
                           Output: t3.a, t3.b
                           ->  Append  (cost=0.00..0.01 rows=3 width=8)
                                 ->  Materialize  (cost=0.00..0.01 rows=1 width=8)
                                       Output: t3.a, t3.b
                                       ->  RemoteScan on public.prt2_p1 t3  (cost=0.00..0.00 rows=1 width=8)
                                             Output: t3.a, t3.b
                                             Shard: 2    Remote SQL: select a, b from regression_$$_public.prt2_p1 
                                 ->  Materialize  (cost=0.00..0.01 rows=1 width=8)
                                       Output: t3_1.a, t3_1.b
                                       ->  RemoteScan on public.prt2_p2 t3_1  (cost=0.00..0.00 rows=1 width=8)
                                             Output: t3_1.a, t3_1.b
                                             Shard: 2    Remote SQL: select a, b from regression_$$_public.prt2_p2 
                                 ->  RemoteScan on public.prt2_p3 t3_2  (cost=0.00..0.00 rows=1 width=8)
                                       Output: t3_2.a, t3_2.b
                                       Shard: 2  Remote SQL: select a, b from regression_$$_public.prt2_p3 
(64 rows)

SET enable_partitionwise_join to true;
SELECT t1, t2 FROM prt1 t1 LEFT JOIN prt2 t2 ON t1.a = t2.b WHERE t1.b = 0 ORDER BY t1.a, t2.b;
      t1      |      t2      
--------------+--------------
 (0,0,0000)   | (0,0,0000)
 (50,0,0050)  | 
 (100,0,0100) | 
 (150,0,0150) | (0,150,0150)
 (200,0,0200) | 
 (250,0,0250) | 
 (300,0,0300) | (0,300,0300)
 (350,0,0350) | 
 (400,0,0400) | 
 (450,0,0450) | (0,450,0450)
 (500,0,0500) | 
 (550,0,0550) | 
(12 rows)

EXPLAIN(verbose)
SELECT t1, t2 FROM prt1 t1 LEFT JOIN prt2 t2 ON t1.a = t2.b WHERE t1.b = 0 ORDER BY t1.a, t2.b;
                                                     QUERY PLAN                                                      
---------------------------------------------------------------------------------------------------------------------
 Sort  (cost=0.13..0.14 rows=3 width=72)
   Output: ((t1.*)::prt1), ((t2.*)::prt2), t1.a, t2.b
   Sort Key: t1.a, t2.b
   ->  Hash Left Join  (cost=0.05..0.11 rows=3 width=72)
         Output: ((t1.*)::prt1), ((t2.*)::prt2), t1.a, t2.b
         Hash Cond: (t1.a = t2.b)
         ->  Append  (cost=0.00..0.01 rows=3 width=36)
               ->  Materialize  (cost=0.00..0.01 rows=1 width=36)
                     Output: t1.*, t1.a
                     ->  RemoteScan on public.prt1_p1 t1  (cost=0.00..0.00 rows=1 width=36)
                           Output: t1.*, t1.a
                           Filter: (t1.b = 0)
                           Shard: 2      Remote SQL: select a, b, c from regression_$$_public.prt1_p1  where (b = 0)
               ->  Materialize  (cost=0.00..0.01 rows=1 width=36)
                     Output: t1_1.*, t1_1.a
                     ->  RemoteScan on public.prt1_p2 t1_1  (cost=0.00..0.00 rows=1 width=36)
                           Output: t1_1.*, t1_1.a
                           Filter: (t1_1.b = 0)
                           Shard: 1      Remote SQL: select a, b, c from regression_$$_public.prt1_p2  where (b = 0)
               ->  RemoteScan on public.prt1_p3 t1_2  (cost=0.00..0.00 rows=1 width=36)
                     Output: t1_2.*, t1_2.a
                     Filter: (t1_2.b = 0)
                     Shard: 1    Remote SQL: select a, b, c from regression_$$_public.prt1_p3  where (b = 0)
         ->  Hash  (cost=0.01..0.01 rows=3 width=36)
               Output: ((t2.*)::prt2), t2.b
               ->  Append  (cost=0.00..0.01 rows=3 width=36)
                     ->  Materialize  (cost=0.00..0.01 rows=1 width=36)
                           Output: t2.*, t2.b
                           ->  RemoteScan on public.prt2_p1 t2  (cost=0.00..0.00 rows=1 width=36)
                                 Output: t2.*, t2.b
                                 Shard: 2        Remote SQL: select a, b, c from regression_$$_public.prt2_p1 
                     ->  Materialize  (cost=0.00..0.01 rows=1 width=36)
                           Output: t2_1.*, t2_1.b
                           ->  RemoteScan on public.prt2_p2 t2_1  (cost=0.00..0.00 rows=1 width=36)
                                 Output: t2_1.*, t2_1.b
                                 Shard: 2        Remote SQL: select a, b, c from regression_$$_public.prt2_p2 
                     ->  RemoteScan on public.prt2_p3 t2_2  (cost=0.00..0.00 rows=1 width=36)
                           Output: t2_2.*, t2_2.b
                           Shard: 2      Remote SQL: select a, b, c from regression_$$_public.prt2_p3 
(39 rows)

SELECT t1.a, t2.b FROM prt1 t1, prt2 t2 WHERE t1::text = t2::text AND t1.a = t2.b ORDER BY t1.a;
ERROR:  Kunlun-db: Must specify whole-row target left-most.
EXPLAIN(verbose)
SELECT t1.a, t2.b FROM prt1 t1, prt2 t2 WHERE t1::text = t2::text AND t1.a = t2.b ORDER BY t1.a;
ERROR:  Kunlun-db: Must specify whole-row target left-most.
SELECT * FROM prt1 t1 LEFT JOIN  (SELECT t2.a AS t2a, t3.a AS t3a, least(t2.a,t3.b) FROM prt1 t2 JOIN prt2 t3 ON (t2.a = t3.b)) ss ON t1.a = ss.t2a WHERE t1.b = 0 ORDER BY t1.a;
  a  | b |  c   | t2a | t3a | least 
-----+---+------+-----+-----+-------
   0 | 0 | 0000 |   0 |   0 |     0
  50 | 0 | 0050 |     |     |      
 100 | 0 | 0100 |     |     |      
 150 | 0 | 0150 | 150 |   0 |   150
 200 | 0 | 0200 |     |     |      
 250 | 0 | 0250 |     |     |      
 300 | 0 | 0300 | 300 |   0 |   300
 350 | 0 | 0350 |     |     |      
 400 | 0 | 0400 |     |     |      
 450 | 0 | 0450 | 450 |   0 |   450
 500 | 0 | 0500 |     |     |      
 550 | 0 | 0550 |     |     |      
(12 rows)

EXPLAIN(verbose)
SELECT * FROM prt1 t1 LEFT JOIN  (SELECT t2.a AS t2a, t3.a AS t3a, least(t2.a,t3.b) FROM prt1 t2 JOIN prt2 t3 ON (t2.a = t3.b)) ss ON t1.a = ss.t2a WHERE t1.b = 0 ORDER BY t1.a;
                                                     QUERY PLAN                                                      
---------------------------------------------------------------------------------------------------------------------
 Sort  (cost=0.12..0.13 rows=3 width=56)
   Output: t1.a, t1.b, t1.c, t2.a, , (LEAST(t2.a, )), t1.a
   Sort Key: t1.a
   ->  Append  (cost=0.00..0.10 rows=3 width=56)
         ->  Nested Loop Left Join  (cost=0.00..0.03 rows=1 width=56)
               Output: t1.a, t1.b, t1.c, t2.a, , (LEAST(t2.a, )), t1.a
               Join Filter: (t1.a = t2.a)
               ->  Materialize  (cost=0.00..0.01 rows=1 width=40)
                     Output: t1.a, t1.b, t1.c
                     ->  RemoteScan on public.prt1_p1 t1  (cost=0.00..0.00 rows=1 width=40)
                           Output: t1.a, t1.b, t1.c
                           Filter: (t1.b = 0)
                           Shard: 2      Remote SQL: select a, b, c from regression_$$_public.prt1_p1  where (b = 0)
               ->  Materialize  (cost=0.00..0.02 rows=1 width=12)
                     Output: t2.a, , LEAST(t2.a, )
                     ->  Nested Loop  (cost=0.00..0.02 rows=1 width=12)
                           Output: t2.a, t3.a, LEAST(t2.a, t3.b)
                           Join Filter: (t2.a = t3.b)
                           ->  Materialize  (cost=0.00..0.01 rows=1 width=4)
                                 Output: t2.a
                                 ->  RemoteScan on public.prt1_p1 t2  (cost=0.00..0.00 rows=1 width=4)
                                       Output: t2.a
                                       Shard: 2  Remote SQL: select a from regression_$$_public.prt1_p1 
                           ->  Materialize  (cost=0.00..0.01 rows=1 width=8)
                                 Output: t3.a, t3.b
                                 ->  RemoteScan on public.prt2_p1 t3  (cost=0.00..0.00 rows=1 width=8)
                                       Output: t3.a, t3.b
                                       Shard: 2  Remote SQL: select a, b from regression_$$_public.prt2_p1 
         ->  Nested Loop Left Join  (cost=0.00..0.03 rows=1 width=56)
               Output: t1_1.a, t1_1.b, t1_1.c, t2_1.a, , (LEAST(t2_1.a, )), t1_1.a
               Join Filter: (t1_1.a = t2_1.a)
               ->  Materialize  (cost=0.00..0.01 rows=1 width=40)
                     Output: t1_1.a, t1_1.b, t1_1.c
                     ->  RemoteScan on public.prt1_p2 t1_1  (cost=0.00..0.00 rows=1 width=40)
                           Output: t1_1.a, t1_1.b, t1_1.c
                           Filter: (t1_1.b = 0)
                           Shard: 1      Remote SQL: select a, b, c from regression_$$_public.prt1_p2  where (b = 0)
               ->  Materialize  (cost=0.00..0.02 rows=1 width=12)
                     Output: t2_1.a, , LEAST(t2_1.a, )
                     ->  Nested Loop  (cost=0.00..0.02 rows=1 width=12)
                           Output: t2_1.a, t3_1.a, LEAST(t2_1.a, t3_1.b)
                           Join Filter: (t2_1.a = t3_1.b)
                           ->  RemoteScan on public.prt1_p2 t2_1  (cost=0.00..0.00 rows=1 width=4)
                                 Output: t2_1.a
                                 Shard: 1        Remote SQL: select a from regression_$$_public.prt1_p2 
                           ->  Materialize  (cost=0.00..0.01 rows=1 width=8)
                                 Output: t3_1.a, t3_1.b
                                 ->  RemoteScan on public.prt2_p2 t3_1  (cost=0.00..0.00 rows=1 width=8)
                                       Output: t3_1.a, t3_1.b
                                       Shard: 2  Remote SQL: select a, b from regression_$$_public.prt2_p2 
         ->  Nested Loop Left Join  (cost=0.00..0.03 rows=1 width=56)
               Output: t1_2.a, t1_2.b, t1_2.c, t2_2.a, , (LEAST(t2_2.a, )), t1_2.a
               Join Filter: (t1_2.a = t2_2.a)
               ->  Materialize  (cost=0.00..0.01 rows=1 width=40)
                     Output: t1_2.a, t1_2.b, t1_2.c
                     ->  RemoteScan on public.prt1_p3 t1_2  (cost=0.00..0.00 rows=1 width=40)
                           Output: t1_2.a, t1_2.b, t1_2.c
                           Filter: (t1_2.b = 0)
                           Shard: 1      Remote SQL: select a, b, c from regression_$$_public.prt1_p3  where (b = 0)
               ->  Materialize  (cost=0.00..0.02 rows=1 width=12)
                     Output: t2_2.a, , LEAST(t2_2.a, )
                     ->  Nested Loop  (cost=0.00..0.02 rows=1 width=12)
                           Output: t2_2.a, t3_2.a, LEAST(t2_2.a, t3_2.b)
                           Join Filter: (t2_2.a = t3_2.b)
                           ->  RemoteScan on public.prt1_p3 t2_2  (cost=0.00..0.00 rows=1 width=4)
                                 Output: t2_2.a
                                 Shard: 1        Remote SQL: select a from regression_$$_public.prt1_p3 
                           ->  Materialize  (cost=0.00..0.01 rows=1 width=8)
                                 Output: t3_2.a, t3_2.b
                                 ->  RemoteScan on public.prt2_p3 t3_2  (cost=0.00..0.00 rows=1 width=8)
                                       Output: t3_2.a, t3_2.b
                                       Shard: 2  Remote SQL: select a, b from regression_$$_public.prt2_p3 
(72 rows)

SELECT * FROM prt1 t1 LEFT JOIN LATERAL (SELECT t2.a AS t2a, t3.a AS t3a, least(t1.a,t2.a,t3.b) FROM prt1 t2 JOIN prt2 t3 ON (t2.a = t3.b)) ss ON t1.a = ss.t2a WHERE t1.b = 0 ORDER BY t1.a;
  a  | b |  c   | t2a | t3a | least 
-----+---+------+-----+-----+-------
   0 | 0 | 0000 |   0 |   0 |     0
  50 | 0 | 0050 |     |     |      
 100 | 0 | 0100 |     |     |      
 150 | 0 | 0150 | 150 |   0 |   150
 200 | 0 | 0200 |     |     |      
 250 | 0 | 0250 |     |     |      
 300 | 0 | 0300 | 300 |   0 |   300
 300 | 0 | 0300 | 300 |   0 |   300
 350 | 0 | 0350 |     |     |      
 400 | 0 | 0400 |     |     |      
 450 | 0 | 0450 | 450 |   0 |   450
 450 | 0 | 0450 | 450 |   0 |   450
 500 | 0 | 0500 |     |     |      
 550 | 0 | 0550 |     |     |      
(14 rows)

EXPLAIN(verbose)
SELECT * FROM prt1 t1 LEFT JOIN LATERAL (SELECT t2.a AS t2a, t3.a AS t3a, least(t1.a,t2.a,t3.b) FROM prt1 t2 JOIN prt2 t3 ON (t2.a = t3.b)) ss ON t1.a = ss.t2a WHERE t1.b = 0 ORDER BY t1.a;
                                                     QUERY PLAN                                                      
---------------------------------------------------------------------------------------------------------------------
 Sort  (cost=0.11..0.12 rows=3 width=56)
   Output: t1.a, t1.b, t1.c, t2.a, , (LEAST(t1.a, t2.a, )), t1.a
   Sort Key: t1.a
   ->  Append  (cost=0.00..0.09 rows=3 width=56)
         ->  Nested Loop Left Join  (cost=0.00..0.03 rows=1 width=56)
               Output: t1.a, t1.b, t1.c, t2.a, , (LEAST(t1.a, t2.a, )), t1.a
               ->  Materialize  (cost=0.00..0.01 rows=1 width=40)
                     Output: t1.a, t1.b, t1.c
                     ->  RemoteScan on public.prt1_p1 t1  (cost=0.00..0.00 rows=1 width=40)
                           Output: t1.a, t1.b, t1.c
                           Filter: (t1.b = 0)
                           Shard: 2      Remote SQL: select a, b, c from regression_$$_public.prt1_p1  where (b = 0)
               ->  Materialize  (cost=0.00..0.02 rows=1 width=12)
                     Output: t2.a, , LEAST(t1.a, t2.a, )
                     ->  Nested Loop  (cost=0.00..0.02 rows=1 width=12)
                           Output: t2.a, t3.a, LEAST(t1.a, t2.a, t3.b)
                           Join Filter: (t2.a = t3.b)
                           ->  Materialize  (cost=0.00..0.01 rows=1 width=4)
                                 Output: t2.a
                                 ->  RemoteScan on public.prt1_p1 t2  (cost=0.00..0.00 rows=1 width=4)
                                       Output: t2.a
                                       Filter: (t1.a = t2.a)
                                       Shard: 2  Remote SQL: select a from regression_$$_public.prt1_p1 
                           ->  Materialize  (cost=0.00..0.01 rows=1 width=8)
                                 Output: t3.a, t3.b
                                 ->  RemoteScan on public.prt2_p1 t3  (cost=0.00..0.00 rows=1 width=8)
                                       Output: t3.a, t3.b
                                       Shard: 2  Remote SQL: select a, b from regression_$$_public.prt2_p1 
         ->  Nested Loop Left Join  (cost=0.00..0.03 rows=1 width=56)
               Output: t1_1.a, t1_1.b, t1_1.c, t2_1.a, , (LEAST(t1_1.a, t2_1.a, )), t1_1.a
               ->  Materialize  (cost=0.00..0.01 rows=1 width=40)
                     Output: t1_1.a, t1_1.b, t1_1.c
                     ->  RemoteScan on public.prt1_p2 t1_1  (cost=0.00..0.00 rows=1 width=40)
                           Output: t1_1.a, t1_1.b, t1_1.c
                           Filter: (t1_1.b = 0)
                           Shard: 1      Remote SQL: select a, b, c from regression_$$_public.prt1_p2  where (b = 0)
               ->  Materialize  (cost=0.00..0.02 rows=1 width=12)
                     Output: t2_1.a, , LEAST(t1_1.a, t2_1.a, )
                     ->  Nested Loop  (cost=0.00..0.02 rows=1 width=12)
                           Output: t2_1.a, t3_1.a, LEAST(t1_1.a, t2_1.a, t3_1.b)
                           Join Filter: (t2_1.a = t3_1.b)
                           ->  RemoteScan on public.prt1_p2 t2_1  (cost=0.00..0.00 rows=1 width=4)
                                 Output: t2_1.a
                                 Filter: (t1_1.a = t2_1.a)
                                 Shard: 1        Remote SQL: select a from regression_$$_public.prt1_p2 
                           ->  Materialize  (cost=0.00..0.01 rows=1 width=8)
                                 Output: t3_1.a, t3_1.b
                                 ->  RemoteScan on public.prt2_p2 t3_1  (cost=0.00..0.00 rows=1 width=8)
                                       Output: t3_1.a, t3_1.b
                                       Shard: 2  Remote SQL: select a, b from regression_$$_public.prt2_p2 
         ->  Nested Loop Left Join  (cost=0.00..0.03 rows=1 width=56)
               Output: t1_2.a, t1_2.b, t1_2.c, t2_2.a, , (LEAST(t1_2.a, t2_2.a, )), t1_2.a
               ->  Materialize  (cost=0.00..0.01 rows=1 width=40)
                     Output: t1_2.a, t1_2.b, t1_2.c
                     ->  RemoteScan on public.prt1_p3 t1_2  (cost=0.00..0.00 rows=1 width=40)
                           Output: t1_2.a, t1_2.b, t1_2.c
                           Filter: (t1_2.b = 0)
                           Shard: 1      Remote SQL: select a, b, c from regression_$$_public.prt1_p3  where (b = 0)
               ->  Materialize  (cost=0.00..0.02 rows=1 width=12)
                     Output: t2_2.a, , LEAST(t1_2.a, t2_2.a, )
                     ->  Nested Loop  (cost=0.00..0.02 rows=1 width=12)
                           Output: t2_2.a, t3_2.a, LEAST(t1_2.a, t2_2.a, t3_2.b)
                           Join Filter: (t2_2.a = t3_2.b)
                           ->  RemoteScan on public.prt1_p3 t2_2  (cost=0.00..0.00 rows=1 width=4)
                                 Output: t2_2.a
                                 Filter: (t1_2.a = t2_2.a)
                                 Shard: 1        Remote SQL: select a from regression_$$_public.prt1_p3 
                           ->  Materialize  (cost=0.00..0.01 rows=1 width=8)
                                 Output: t3_2.a, t3_2.b
                                 ->  RemoteScan on public.prt2_p3 t3_2  (cost=0.00..0.00 rows=1 width=8)
                                       Output: t3_2.a, t3_2.b
                                       Shard: 2  Remote SQL: select a, b from regression_$$_public.prt2_p3 
(72 rows)

-- bug 67
SET enable_partitionwise_join to true;
DROP TABLE if exists prt1_l;
CREATE TABLE prt1_l (a int, b int, c varchar, primary key(a,b,c)) PARTITION BY RANGE(a);
CREATE TABLE prt1_l_p1 PARTITION OF prt1_l FOR VALUES FROM (0) TO (250);
CREATE TABLE prt1_l_p2 PARTITION OF prt1_l FOR VALUES FROM (250) TO (500) PARTITION BY LIST (c);
CREATE TABLE prt1_l_p2_p1 PARTITION OF prt1_l_p2 FOR VALUES IN ('0000', '0001');
CREATE TABLE prt1_l_p2_p2 PARTITION OF prt1_l_p2 FOR VALUES IN ('0002', '0003');
CREATE TABLE prt1_l_p3 PARTITION OF prt1_l FOR VALUES FROM (500) TO (600) PARTITION BY RANGE (b);
CREATE TABLE prt1_l_p3_p1 PARTITION OF prt1_l_p3 FOR VALUES FROM (0) TO (13);
CREATE TABLE prt1_l_p3_p2 PARTITION OF prt1_l_p3 FOR VALUES FROM (13) TO (25);
INSERT INTO prt1_l SELECT i, i % 25, to_char(i % 4, 'FM0000') FROM generate_series(0, 599, 2) i;
DROP TABLE if exists prt2_l;
CREATE TABLE prt2_l (a int, b int, c varchar, primary key(a,b,c)) PARTITION BY RANGE(b);
CREATE TABLE prt2_l_p1 PARTITION OF prt2_l FOR VALUES FROM (0) TO (250);
CREATE TABLE prt2_l_p2 PARTITION OF prt2_l FOR VALUES FROM (250) TO (500) PARTITION BY LIST (c);
CREATE TABLE prt2_l_p2_p1 PARTITION OF prt2_l_p2 FOR VALUES IN ('0000', '0001');
CREATE TABLE prt2_l_p2_p2 PARTITION OF prt2_l_p2 FOR VALUES IN ('0002', '0003');
CREATE TABLE prt2_l_p3 PARTITION OF prt2_l FOR VALUES FROM (500) TO (600) PARTITION BY RANGE (a);
CREATE TABLE prt2_l_p3_p1 PARTITION OF prt2_l_p3 FOR VALUES FROM (0) TO (13);
CREATE TABLE prt2_l_p3_p2 PARTITION OF prt2_l_p3 FOR VALUES FROM (13) TO (25);
INSERT INTO prt2_l SELECT i % 25, i, to_char(i % 4, 'FM0000') FROM generate_series(0, 599, 3) i;
EXPLAIN (COSTS OFF) SELECT t1.a, t1.c, t2.b, t2.c FROM prt1_l t1, prt2_l t2 WHERE t1.a = t2.b AND t1.b = 0 ORDER BY t1.a, t2.b;
                                                          QUERY PLAN                                                           
-------------------------------------------------------------------------------------------------------------------------------
 Sort
   Sort Key: t1.a
   ->  Append
         ->  Nested Loop
               Join Filter: (t1.a = t2.b)
               ->  Materialize
                     ->  RemoteScan on prt1_l_p1 t1
                           Filter: (c = 0)
                           Shard: 2      Remote SQL: select a, c from regression_$$_public.prt1_l_p1  where (b = 0)
               ->  Materialize
                     ->  RemoteScan on prt2_l_p1 t2
                           Shard: 1      Remote SQL: select b, c from regression_$$_public.prt2_l_p1 
         ->  Hash Join
               Hash Cond: (t1_1.a = t2_1.b)
               ->  Append
                     ->  Materialize
                           ->  RemoteScan on prt1_l_p2_p1 t1_1
                                 Filter: (c = 0)
                                 Shard: 2        Remote SQL: select a, c from regression_$$_public.prt1_l_p2_p1  where (b = 0)
                     ->  Materialize
                           ->  RemoteScan on prt1_l_p2_p2 t1_2
                                 Filter: (c = 0)
                                 Shard: 2        Remote SQL: select a, c from regression_$$_public.prt1_l_p2_p2  where (b = 0)
               ->  Hash
                     ->  Append
                           ->  RemoteScan on prt2_l_p2_p1 t2_1
                                 Shard: 2        Remote SQL: select b, c from regression_$$_public.prt2_l_p2_p1 
                           ->  Materialize
                                 ->  RemoteScan on prt2_l_p2_p2 t2_2
                                       Shard: 1  Remote SQL: select b, c from regression_$$_public.prt2_l_p2_p2 
         ->  Nested Loop
               Join Filter: (t1_3.a = t2_3.b)
               ->  Append
                     ->  Materialize
                           ->  RemoteScan on prt1_l_p3_p1 t1_3
                                 Filter: (c = 0)
                                 Shard: 1        Remote SQL: select a, c from regression_$$_public.prt1_l_p3_p1  where (b = 0)
               ->  Materialize
                     ->  Append
                           ->  RemoteScan on prt2_l_p3_p1 t2_3
                                 Shard: 1        Remote SQL: select b, c from regression_$$_public.prt2_l_p3_p1 
                           ->  Materialize
                                 ->  RemoteScan on prt2_l_p3_p2 t2_4
                                       Shard: 2  Remote SQL: select b, c from regression_$$_public.prt2_l_p3_p2 
(44 rows)

SELECT t1.a, t1.c, t2.b, t2.c FROM prt1_l t1, prt2_l t2 WHERE t1.a = t2.b AND t1.b = 0 ORDER BY t1.a, t2.b;
  a  |  c   |  b  |  c   
-----+------+-----+------
   0 | 0000 |   0 | 0000
 150 | 0002 | 150 | 0002
 300 | 0000 | 300 | 0000
 450 | 0002 | 450 | 0002
(4 rows)

SET enable_partitionwise_join to false;
EXPLAIN (COSTS OFF) SELECT t1.a, t1.c, t2.b, t2.c FROM prt1_l t1, prt2_l t2 WHERE t1.a = t2.b AND t1.b = 0 ORDER BY t1.a, t2.b;
                                                          QUERY PLAN                                                           
-------------------------------------------------------------------------------------------------------------------------------
 Sort
   Sort Key: t1.a
   ->  Hash Join
         Hash Cond: (t2.b = t1.a)
         ->  Append
               ->  Materialize
                     ->  RemoteScan on prt2_l_p1 t2
                           Shard: 1      Remote SQL: select b, c from regression_$$_public.prt2_l_p1 
               ->  Materialize
                     ->  RemoteScan on prt2_l_p2_p1 t2_1
                           Shard: 2      Remote SQL: select b, c from regression_$$_public.prt2_l_p2_p1 
               ->  Materialize
                     ->  RemoteScan on prt2_l_p2_p2 t2_2
                           Shard: 1      Remote SQL: select b, c from regression_$$_public.prt2_l_p2_p2 
               ->  Materialize
                     ->  RemoteScan on prt2_l_p3_p1 t2_3
                           Shard: 1      Remote SQL: select b, c from regression_$$_public.prt2_l_p3_p1 
               ->  Materialize
                     ->  RemoteScan on prt2_l_p3_p2 t2_4
                           Shard: 2      Remote SQL: select b, c from regression_$$_public.prt2_l_p3_p2 
         ->  Hash
               ->  Append
                     ->  Materialize
                           ->  RemoteScan on prt1_l_p1 t1
                                 Filter: (c = 0)
                                 Shard: 2        Remote SQL: select a, c from regression_$$_public.prt1_l_p1  where (b = 0)
                     ->  Materialize
                           ->  RemoteScan on prt1_l_p2_p1 t1_1
                                 Filter: (c = 0)
                                 Shard: 2        Remote SQL: select a, c from regression_$$_public.prt1_l_p2_p1  where (b = 0)
                     ->  RemoteScan on prt1_l_p2_p2 t1_2
                           Filter: (c = 0)
                           Shard: 2      Remote SQL: select a, c from regression_$$_public.prt1_l_p2_p2  where (b = 0)
                     ->  RemoteScan on prt1_l_p3_p1 t1_3
                           Filter: (c = 0)
                           Shard: 1      Remote SQL: select a, c from regression_$$_public.prt1_l_p3_p1  where (b = 0)
(36 rows)

SELECT t1.a, t1.c, t2.b, t2.c FROM prt1_l t1, prt2_l t2 WHERE t1.a = t2.b AND t1.b = 0 ORDER BY t1.a, t2.b;
  a  |  c   |  b  |  c   
-----+------+-----+------
   0 | 0000 |   0 | 0000
 150 | 0002 | 150 | 0002
 300 | 0000 | 300 | 0000
 450 | 0002 | 450 | 0002
(4 rows)

-- bug 16
create table insertconflicttest1(key1 int4, fruit text);
create index idx1 on insertconflicttest1(fruit);
-- bug 40 
drop table SUBSELECT_TBL cascade;
ERROR:  table "subselect_tbl" does not exist
CREATE TABLE SUBSELECT_TBL ( id serial primary key, f1 integer, f2 integer, f3 float );
INSERT INTO SUBSELECT_TBL (f1, f2, f3) VALUES (1, 2, 3), (2, 3, 4), (3, 4, 5), (1, 1, 1), (2, 2, 2), (3, 3, 3), (6, 7, 8), (8, 9, NULL);
SELECT f1 AS "Correlated Field", f3 AS "Second Field" FROM SUBSELECT_TBL upper WHERE f3 IN (SELECT upper.f1 + f2 FROM SUBSELECT_TBL WHERE f2 = CAST(f3 AS integer));
 Correlated Field | Second Field 
------------------+--------------
                1 |            3
                2 |            4
                3 |            5
                6 |            8
(4 rows)

-- bug 33
begin;
savepoint sa;
release savepoint sa;
commit;
-- bug 42
drop table if exists tenk1;
NOTICE:  table "tenk1" does not exist, skipping
drop table if exists INT4_TBL;
drop table if exists FLOAT8_TBL;
NOTICE:  table "float8_tbl" does not exist, skipping
 CREATE TABLE tenk1 (
    unique1 int4,
    unique2 int4,
    two int4,
    four int4,
    ten int4,
    twenty int4,
    hundred int4,
    thousand int4,
    twothousand int4,
    fivethous int4,
    tenthous int4,
    odd int4,
    even int4,
    stringu1 name,
    stringu2 name,
    string4 name
);
CREATE TABLE INT4_TBL(f1 int4);
CREATE TABLE FLOAT8_TBL(f1 float8);
begin;
select count(*) from tenk1 x where x.unique1 in (select a.f1 from int4_tbl a,float8_tbl b where a.f1=b.f1) and
    x.unique1 = 0 and x.unique1 in (select aa.f1 from int4_tbl aa,float8_tbl bb where aa.f1=bb.f1);
 count 
-------
     0
(1 row)

rollback;
-- bug 81
drop table if exists INT8_TBL;
CREATE TABLE INT8_TBL(id serial primary key, q1 int8, q2 int8);
INSERT INTO INT8_TBL(q1, q2)  VALUES(' 123 ',' 456');
INSERT INTO INT8_TBL(q1, q2)  VALUES('123 ','4567890123456789');
INSERT INTO INT8_TBL(q1, q2)  VALUES('4567890123456789','123');
INSERT INTO INT8_TBL(q1, q2)  VALUES(+4567890123456789,'4567890123456789');
INSERT INTO INT8_TBL(q1, q2)  VALUES('+4567890123456789','-4567890123456789');
select t1.q2, count(t2.*) from int8_tbl t1 left join (select * from int8_tbl) t2 on (t1.q2 = t2.q1) group by t1.q2 order by 1;
        q2         | count 
-------------------+-------
 -4567890123456789 |     0
               123 |     2
               456 |     0
  4567890123456789 |     6
(4 rows)

explain(verbose)
select t1.q2, count(t2.*) from int8_tbl t1 left join (select * from int8_tbl) t2 on (t1.q2 = t2.q1) group by t1.q2 order by 1;
                                                QUERY PLAN                                                 
-----------------------------------------------------------------------------------------------------------
 GroupAggregate  (cost=0.02..0.04 rows=1 width=16)
   Output: t1.q2, count((ROW(int8_tbl.q1, int8_tbl.q1, int8_tbl.q2)))
   Group Key: t1.q2
   ->  Sort  (cost=0.02..0.03 rows=1 width=40)
         Output: t1.q2, (ROW(int8_tbl.q1, int8_tbl.q1, int8_tbl.q2))
         Sort Key: t1.q2
         ->  Nested Loop Left Join  (cost=0.00..0.01 rows=1 width=40)
               Output: t1.q2, (ROW(int8_tbl.q1, int8_tbl.q1, int8_tbl.q2))
               Join Filter: (t1.q2 = int8_tbl.q1)
               ->  Materialize  (cost=0.00..0.01 rows=1 width=8)
                     Output: t1.id, t1.q1, t1.q2
                     ->  RemoteScan on public.int8_tbl t1  (cost=0.00..0.00 rows=1 width=8)
                           Output: t1.id, t1.q1, t1.q2
                           Shard: 1      Remote SQL: select id, q1, q2 from regression_$$_public.int8_tbl 
               ->  Materialize  (cost=0.00..0.01 rows=1 width=40)
                     Output: int8_tbl.q1, ROW(int8_tbl.q1, int8_tbl.q1, int8_tbl.q2)
                     ->  RemoteScan on public.int8_tbl  (cost=0.00..0.00 rows=1 width=40)
                           Output: int8_tbl.q1, ROW(int8_tbl.q1, int8_tbl.q1, int8_tbl.q2)
                           Shard: 1      Remote SQL: select q1, id, q2 from regression_$$_public.int8_tbl 
(19 rows)

select t1.q2, count(t2.*) from int8_tbl t1 left join (select q1, case when q2=1 then 1 else q2 end as q2 from int8_tbl) t2 on (t1.q2 = t2.q1) group by t1.q2 order by 1;
        q2         | count 
-------------------+-------
 -4567890123456789 |     0
               123 |     2
               456 |     0
  4567890123456789 |     6
(4 rows)

explain (verbose)
select t1.q2, count(t2.*) from int8_tbl t1 left join (select q1, case when q2=1 then 1 else q2 end as q2 from int8_tbl) t2 on (t1.q2 = t2.q1) group by t1.q2 order by 1;
                                                             QUERY PLAN                                                             
------------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate  (cost=0.03..0.05 rows=1 width=16)
   Output: t1.q2, count((ROW(int8_tbl.q1, CASE WHEN (int8_tbl.q1 = 1) THEN '1'::bigint ELSE int8_tbl.q1 END)))
   Group Key: t1.q2
   ->  Sort  (cost=0.03..0.03 rows=1 width=40)
         Output: t1.q2, (ROW(int8_tbl.q1, CASE WHEN (int8_tbl.q1 = 1) THEN '1'::bigint ELSE int8_tbl.q1 END))
         Sort Key: t1.q2
         ->  Nested Loop Left Join  (cost=0.00..0.02 rows=1 width=40)
               Output: t1.q2, (ROW(int8_tbl.q1, CASE WHEN (int8_tbl.q1 = 1) THEN '1'::bigint ELSE int8_tbl.q1 END))
               Join Filter: (t1.q2 = int8_tbl.q1)
               ->  Materialize  (cost=0.00..0.01 rows=1 width=8)
                     Output: t1.id, t1.q1, t1.q2
                     ->  RemoteScan on public.int8_tbl t1  (cost=0.00..0.00 rows=1 width=8)
                           Output: t1.id, t1.q1, t1.q2
                           Shard: 1      Remote SQL: select id, q1, q2 from regression_$$_public.int8_tbl 
               ->  Materialize  (cost=0.00..0.01 rows=1 width=40)
                     Output: int8_tbl.q1, ROW(int8_tbl.q1, CASE WHEN (int8_tbl.q1 = 1) THEN '1'::bigint ELSE int8_tbl.q1 END)
                     ->  RemoteScan on public.int8_tbl  (cost=0.00..0.00 rows=1 width=40)
                           Output: int8_tbl.q1, ROW(int8_tbl.q1, CASE WHEN (int8_tbl.q1 = 1) THEN '1'::bigint ELSE int8_tbl.q1 END)
                           Shard: 1      Remote SQL: select q1, q2 from regression_$$_public.int8_tbl 
(19 rows)

select t1.q2, count(t2.*) from int8_tbl t1 left join int8_tbl t2 on (t1.q2 = t2.q1) group by t1.q2 order by 1;
        q2         | count 
-------------------+-------
 -4567890123456789 |     0
               123 |     2
               456 |     0
  4567890123456789 |     6
(4 rows)

explain (verbose)
select t1.q2, count(t2.*) from int8_tbl t1 left join int8_tbl t2 on (t1.q2 = t2.q1) group by t1.q2 order by 1;
                                                QUERY PLAN                                                 
-----------------------------------------------------------------------------------------------------------
 GroupAggregate  (cost=0.02..0.04 rows=1 width=16)
   Output: t1.q2, count(t2.*)
   Group Key: t1.q2
   ->  Sort  (cost=0.02..0.03 rows=1 width=52)
         Output: t1.q2, t2.*
         Sort Key: t1.q2
         ->  Nested Loop Left Join  (cost=0.00..0.01 rows=1 width=52)
               Output: t1.q2, t2.*
               Join Filter: (t1.q2 = t2.q1)
               ->  Materialize  (cost=0.00..0.01 rows=1 width=8)
                     Output: t1.id, t1.q1, t1.q2
                     ->  RemoteScan on public.int8_tbl t1  (cost=0.00..0.00 rows=1 width=8)
                           Output: t1.id, t1.q1, t1.q2
                           Shard: 1      Remote SQL: select id, q1, q2 from regression_$$_public.int8_tbl 
               ->  Materialize  (cost=0.00..0.01 rows=1 width=52)
                     Output: t2.*, t2.q1
                     ->  RemoteScan on public.int8_tbl t2  (cost=0.00..0.00 rows=1 width=52)
                           Output: t2.*, t2.q1
                           Shard: 1      Remote SQL: select id, q1, q2 from regression_$$_public.int8_tbl 
(19 rows)

explain (verbose)
select t1.q2, count(*) from int8_tbl t1 left join int8_tbl t2 on (t1.q2 = t2.q1) group by t1.q2 order by 1;
                                                QUERY PLAN                                                 
-----------------------------------------------------------------------------------------------------------
 GroupAggregate  (cost=0.02..0.04 rows=1 width=16)
   Output: t1.q2, count(*)
   Group Key: t1.q2
   ->  Sort  (cost=0.02..0.03 rows=1 width=8)
         Output: t1.q2
         Sort Key: t1.q2
         ->  Nested Loop Left Join  (cost=0.00..0.01 rows=1 width=8)
               Output: t1.q2
               Join Filter: (t1.q2 = t2.q1)
               ->  Materialize  (cost=0.00..0.01 rows=1 width=8)
                     Output: t1.id, t1.q1, t1.q2
                     ->  RemoteScan on public.int8_tbl t1  (cost=0.00..0.00 rows=1 width=8)
                           Output: t1.id, t1.q1, t1.q2
                           Shard: 1      Remote SQL: select id, q1, q2 from regression_$$_public.int8_tbl 
               ->  Materialize  (cost=0.00..0.01 rows=1 width=8)
                     Output: t2.id, t2.q1, t2.q2
                     ->  RemoteScan on public.int8_tbl t2  (cost=0.00..0.00 rows=1 width=8)
                           Output: t2.id, t2.q1, t2.q2
                           Shard: 1      Remote SQL: select id, q1, q2 from regression_$$_public.int8_tbl 
(19 rows)

select t1.q2, count(*) from int8_tbl t1 left join int8_tbl t2 on (t1.q2 = t2.q1) group by t1.q2 order by 1;
        q2         | count 
-------------------+-------
 -4567890123456789 |     1
               123 |     2
               456 |     1
  4567890123456789 |     6
(4 rows)

select t1.q2, count(*) from int8_tbl t1 left join (select * from int8_tbl) t2 on (t1.q2 = t2.q1) group by t1.q2 order by 1;
        q2         | count 
-------------------+-------
 -4567890123456789 |     1
               123 |     2
               456 |     1
  4567890123456789 |     6
(4 rows)

explain(verbose)
select t1.q2, count(*) from int8_tbl t1 left join (select * from int8_tbl) t2 on (t1.q2 = t2.q1) group by t1.q2 order by 1;
                                                QUERY PLAN                                                 
-----------------------------------------------------------------------------------------------------------
 GroupAggregate  (cost=0.02..0.04 rows=1 width=16)
   Output: t1.q2, count(*)
   Group Key: t1.q2
   ->  Sort  (cost=0.02..0.03 rows=1 width=8)
         Output: t1.q2
         Sort Key: t1.q2
         ->  Nested Loop Left Join  (cost=0.00..0.01 rows=1 width=8)
               Output: t1.q2
               Join Filter: (t1.q2 = int8_tbl.q1)
               ->  Materialize  (cost=0.00..0.01 rows=1 width=8)
                     Output: t1.id, t1.q1, t1.q2
                     ->  RemoteScan on public.int8_tbl t1  (cost=0.00..0.00 rows=1 width=8)
                           Output: t1.id, t1.q1, t1.q2
                           Shard: 1      Remote SQL: select id, q1, q2 from regression_$$_public.int8_tbl 
               ->  Materialize  (cost=0.00..0.01 rows=1 width=8)
                     Output: int8_tbl.id, int8_tbl.q1, int8_tbl.q2
                     ->  RemoteScan on public.int8_tbl  (cost=0.00..0.00 rows=1 width=8)
                           Output: int8_tbl.id, int8_tbl.q1, int8_tbl.q2
                           Shard: 1      Remote SQL: select id, q1, q2 from regression_$$_public.int8_tbl 
(19 rows)

select t1.q2, count(*) from int8_tbl t1 left join (select q1, case when q2=1 then 1 else q2 end as q2 from int8_tbl) t2 on (t1.q2 = t2.q1) group by t1.q2 order by 1;
        q2         | count 
-------------------+-------
 -4567890123456789 |     1
               123 |     2
               456 |     1
  4567890123456789 |     6
(4 rows)

explain (verbose)
select t1.q2, count(*) from int8_tbl t1 left join (select q1, case when q2=1 then 1 else q2 end as q2 from int8_tbl) t2 on (t1.q2 = t2.q1) group by t1.q2 order by 1;
                                                QUERY PLAN                                                 
-----------------------------------------------------------------------------------------------------------
 GroupAggregate  (cost=0.02..0.04 rows=1 width=16)
   Output: t1.q2, count(*)
   Group Key: t1.q2
   ->  Sort  (cost=0.02..0.03 rows=1 width=8)
         Output: t1.q2
         Sort Key: t1.q2
         ->  Nested Loop Left Join  (cost=0.00..0.01 rows=1 width=8)
               Output: t1.q2
               Join Filter: (t1.q2 = int8_tbl.q1)
               ->  Materialize  (cost=0.00..0.01 rows=1 width=8)
                     Output: t1.id, t1.q1, t1.q2
                     ->  RemoteScan on public.int8_tbl t1  (cost=0.00..0.00 rows=1 width=8)
                           Output: t1.id, t1.q1, t1.q2
                           Shard: 1      Remote SQL: select id, q1, q2 from regression_$$_public.int8_tbl 
               ->  Materialize  (cost=0.00..0.01 rows=1 width=8)
                     Output: int8_tbl.id, int8_tbl.q1, int8_tbl.q2
                     ->  RemoteScan on public.int8_tbl  (cost=0.00..0.00 rows=1 width=8)
                           Output: int8_tbl.id, int8_tbl.q1, int8_tbl.q2
                           Shard: 1      Remote SQL: select id, q1, q2 from regression_$$_public.int8_tbl 
(19 rows)

explain (verbose)
select t1.q2, count(*) from int8_tbl t1 left join int8_tbl t2 on (t1.q2 = t2.q1) group by t1.q2 order by 1;
                                                QUERY PLAN                                                 
-----------------------------------------------------------------------------------------------------------
 GroupAggregate  (cost=0.02..0.04 rows=1 width=16)
   Output: t1.q2, count(*)
   Group Key: t1.q2
   ->  Sort  (cost=0.02..0.03 rows=1 width=8)
         Output: t1.q2
         Sort Key: t1.q2
         ->  Nested Loop Left Join  (cost=0.00..0.01 rows=1 width=8)
               Output: t1.q2
               Join Filter: (t1.q2 = t2.q1)
               ->  Materialize  (cost=0.00..0.01 rows=1 width=8)
                     Output: t1.id, t1.q1, t1.q2
                     ->  RemoteScan on public.int8_tbl t1  (cost=0.00..0.00 rows=1 width=8)
                           Output: t1.id, t1.q1, t1.q2
                           Shard: 1      Remote SQL: select id, q1, q2 from regression_$$_public.int8_tbl 
               ->  Materialize  (cost=0.00..0.01 rows=1 width=8)
                     Output: t2.id, t2.q1, t2.q2
                     ->  RemoteScan on public.int8_tbl t2  (cost=0.00..0.00 rows=1 width=8)
                           Output: t2.id, t2.q1, t2.q2
                           Shard: 1      Remote SQL: select id, q1, q2 from regression_$$_public.int8_tbl 
(19 rows)

select t1.q2, count(*) from int8_tbl t1 left join int8_tbl t2 on (t1.q2 = t2.q1) group by t1.q2 order by 1;
        q2         | count 
-------------------+-------
 -4567890123456789 |     1
               123 |     2
               456 |     1
  4567890123456789 |     6
(4 rows)

-- bug 71
DROP table if exists T;
CREATE TABLE T(pk INT NOT NULL PRIMARY KEY);
INSERT INTO T VALUES (1);
ALTER TABLE T ADD COLUMN c1 TIMESTAMP DEFAULT now();
select*from T;
 pk |            c1            
----+--------------------------
  1 | Thu Nov 04 17:54:06 2021
(1 row)

insert into T values(2);
select*from T;
 pk |            c1            
----+--------------------------
  1 | Thu Nov 04 17:54:06 2021
  2 | Thu Nov 04 02:54:06 2021
(2 rows)

 CREATE OR REPLACE FUNCTION foo(a INT) RETURNS TEXT AS $$
DECLARE res TEXT = 'xyz';

    i INT;

BEGIN

    i = 0;
    WHILE (i < a) LOOP

        res = res || chr(ascii('a') + i);

        i = i + 1;

    END LOOP;
    RETURN res;

END; $$ LANGUAGE PLPGSQL STABLE;
DROP table if exists T;
CREATE TABLE T(pk INT NOT NULL PRIMARY KEY, c_int INT DEFAULT LENGTH(foo(6)));
INSERT INTO T VALUES (1), (2);
select*from t;
 pk | c_int 
----+-------
  1 |     9
  2 |     9
(2 rows)

ALTER TABLE T ADD COLUMN c_bpchar BPCHAR(50) DEFAULT foo(4), ALTER COLUMN c_int SET DEFAULT LENGTH(foo(8));
ERROR:  Kunlun-db: MySQL storage node (1, 1) returned error: 1064, You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'foo(4)' at line 1.
select*from t;
 pk | c_int 
----+-------
  1 |     9
  2 |     9
(2 rows)

-- bug 21
drop table if exists mlparted;
NOTICE:  table "mlparted" does not exist, skipping
drop table if exists mlparted1;
NOTICE:  table "mlparted1" does not exist, skipping
create table mlparted(id integer primary key);
create table mlparted1(id integer primary key);
select attrelid::regclass, attname, attnum from pg_attribute where attname = 'a' and (attrelid = 'mlparted'::regclass or attrelid = 'mlparted1'::regclass);
 attrelid | attname | attnum 
----------+---------+--------
(0 rows)

insert into mlparted values(1),(2),(3),(4);
insert into mlparted1 values(5),(2),(3),(4);
select attrelid::regclass, attname, attnum from pg_attribute where attname = 'a' and (attrelid = 'mlparted'::regclass or attrelid = 'mlparted1'::regclass);
 attrelid | attname | attnum 
----------+---------+--------
(0 rows)

-- bug 32
drop table if exists test_missing_target;
NOTICE:  table "test_missing_target" does not exist, skipping
CREATE TABLE test_missing_target (a int primary key, b int, c char(8), d char);
INSERT INTO test_missing_target VALUES (0, 1, 'XXXX', 'A'), (1, 2, 'ABAB', 'b'), (2, 2, 'ABAB', 'c'), (3, 3, 'BBBB', 'D'), (4, 3, 'BBBB', 'e'), (5, 3, 'bbbb', 'F'), (6, 4, 'cccc', 'g'), (7, 4, 'cccc', 'h'), (8, 4, 'CCCC', 'I'), (9, 4, 'CCCC', 'j');
SELECT x.b, count(*) FROM test_missing_target x, test_missing_target y WHERE x.a = y.a GROUP BY x.b ORDER BY x.b;
 b | count 
---+-------
 1 |     1
 2 |     2
 3 |     3
 4 |     4
(4 rows)

explain (verbose)
SELECT x.b, count(*) FROM test_missing_target x, test_missing_target y WHERE x.a = y.a GROUP BY x.b ORDER BY x.b;
                                                      QUERY PLAN                                                      
----------------------------------------------------------------------------------------------------------------------
 GroupAggregate  (cost=0.02..0.04 rows=1 width=12)
   Output: x.b, count(*)
   Group Key: x.b
   ->  Sort  (cost=0.02..0.03 rows=1 width=4)
         Output: x.b
         Sort Key: x.b
         ->  Nested Loop  (cost=0.00..0.01 rows=1 width=4)
               Output: x.b
               Join Filter: (x.a = y.a)
               ->  Materialize  (cost=0.00..0.01 rows=1 width=8)
                     Output: x.a, x.b, x.c, x.d
                     ->  RemoteScan on public.test_missing_target x  (cost=0.00..0.00 rows=1 width=8)
                           Output: x.a, x.b, x.c, x.d
                           Shard: 1      Remote SQL: select a, b, c, d from regression_$$_public.test_missing_target 
               ->  Materialize  (cost=0.00..0.01 rows=1 width=4)
                     Output: y.a, y.b, y.c, y.d
                     ->  RemoteScan on public.test_missing_target y  (cost=0.00..0.00 rows=1 width=4)
                           Output: y.a, y.b, y.c, y.d
                           Shard: 1      Remote SQL: select a, b, c, d from regression_$$_public.test_missing_target 
(19 rows)

SELECT count(*) FROM test_missing_target x, test_missing_target y WHERE x.a = y.a GROUP BY x.b ORDER BY x.b;
 count 
-------
     1
     2
     3
     4
(4 rows)

explain (verbose)
SELECT count(*) FROM test_missing_target x, test_missing_target y WHERE x.a = y.a GROUP BY x.b ORDER BY x.b;
                                                      QUERY PLAN                                                      
----------------------------------------------------------------------------------------------------------------------
 GroupAggregate  (cost=0.02..0.04 rows=1 width=12)
   Output: count(*), x.b
   Group Key: x.b
   ->  Sort  (cost=0.02..0.03 rows=1 width=4)
         Output: x.b
         Sort Key: x.b
         ->  Nested Loop  (cost=0.00..0.01 rows=1 width=4)
               Output: x.b
               Join Filter: (x.a = y.a)
               ->  Materialize  (cost=0.00..0.01 rows=1 width=8)
                     Output: x.a, x.b, x.c, x.d
                     ->  RemoteScan on public.test_missing_target x  (cost=0.00..0.00 rows=1 width=8)
                           Output: x.a, x.b, x.c, x.d
                           Shard: 1      Remote SQL: select a, b, c, d from regression_$$_public.test_missing_target 
               ->  Materialize  (cost=0.00..0.01 rows=1 width=4)
                     Output: y.a, y.b, y.c, y.d
                     ->  RemoteScan on public.test_missing_target y  (cost=0.00..0.00 rows=1 width=4)
                           Output: y.a, y.b, y.c, y.d
                           Shard: 1      Remote SQL: select a, b, c, d from regression_$$_public.test_missing_target 
(19 rows)

SELECT x.b/2, count(x.b) FROM test_missing_target x, test_missing_target y WHERE x.a = y.a GROUP BY x.b/2 ORDER BY x.b/2;
 ?column? | count 
----------+-------
        0 |     1
        1 |     5
        2 |     4
(3 rows)

explain (verbose)
SELECT x.b/2, count(x.b) FROM test_missing_target x, test_missing_target y WHERE x.a = y.a GROUP BY x.b/2 ORDER BY x.b/2;
                                                      QUERY PLAN                                                      
----------------------------------------------------------------------------------------------------------------------
 GroupAggregate  (cost=0.03..0.05 rows=1 width=12)
   Output: ((x.b / 2)), count(x.b)
   Group Key: ((x.b / 2))
   ->  Sort  (cost=0.03..0.03 rows=1 width=8)
         Output: ((x.b / 2)), x.b
         Sort Key: ((x.b / 2))
         ->  Nested Loop  (cost=0.00..0.02 rows=1 width=8)
               Output: (x.b / 2), x.b
               Join Filter: (x.a = y.a)
               ->  Materialize  (cost=0.00..0.01 rows=1 width=8)
                     Output: x.a, x.b, x.c, x.d
                     ->  RemoteScan on public.test_missing_target x  (cost=0.00..0.00 rows=1 width=8)
                           Output: x.a, x.b, x.c, x.d
                           Shard: 1      Remote SQL: select a, b, c, d from regression_$$_public.test_missing_target 
               ->  Materialize  (cost=0.00..0.01 rows=1 width=4)
                     Output: y.a, y.b, y.c, y.d
                     ->  RemoteScan on public.test_missing_target y  (cost=0.00..0.00 rows=1 width=4)
                           Output: y.a, y.b, y.c, y.d
                           Shard: 1      Remote SQL: select a, b, c, d from regression_$$_public.test_missing_target 
(19 rows)

-- bug 64
drop table if exists itest7;
NOTICE:  table "itest7" does not exist, skipping
CREATE TABLE itest7 (id int primary key, a int GENERATED ALWAYS AS IDENTITY);
insert into itest7 (id) values(1),(2),(3);
insert into itest7 values(4, 40),(5, 50);
ERROR:  cannot insert into column "a"
DETAIL:  Column "a" is an identity column defined as GENERATED ALWAYS.
HINT:  Use OVERRIDING SYSTEM VALUE to override.
select*from itest7;
 id | a 
----+---
  1 | 1
  2 | 2
  3 | 3
(3 rows)

ALTER TABLE itest7 ALTER COLUMN a SET GENERATED BY DEFAULT;
insert into itest7 values(6, 60),(7, 70);
select*from itest7;
 id | a  
----+----
  1 |  1
  2 |  2
  3 |  3
  6 | 60
  7 | 70
(5 rows)

-- bug 65
drop table if exists itest13;
NOTICE:  table "itest13" does not exist, skipping
CREATE TABLE itest13 (a int primary key);
ALTER TABLE itest13 ADD COLUMN b int GENERATED BY DEFAULT AS IDENTITY;
INSERT INTO itest13 VALUES (1), (2), (3);
SELECT * FROM itest13;
 a | b 
---+---
 1 | 1
 2 | 2
 3 | 3
(3 rows)

ALTER TABLE itest13 ADD COLUMN c int GENERATED BY DEFAULT AS IDENTITY;
SELECT * FROM itest13;
 a | b | c 
---+---+---
 1 | 1 | 0
 2 | 2 | 0
 3 | 3 | 0
(3 rows)

drop table if exists itest6;
NOTICE:  table "itest6" does not exist, skipping
CREATE TABLE itest6 (a int GENERATED ALWAYS AS IDENTITY primary key, b text);
INSERT INTO itest6 DEFAULT VALUES;
ALTER TABLE itest6 ALTER COLUMN a SET GENERATED BY DEFAULT SET INCREMENT BY 2 SET START WITH 100 RESTART;
SELECT * FROM itest6;
 a | b 
---+---
 1 | 
(1 row)

INSERT INTO itest6 DEFAULT VALUES;
INSERT INTO itest6 DEFAULT VALUES;
SELECT * FROM itest6;
  a  | b 
-----+---
   1 | 
 102 | 
 104 | 
(3 rows)

-- bug 68
drop table  if exists t2;
NOTICE:  table "t2" does not exist, skipping
create table t2(a int);
create index on t2(a,a);
ERROR:  Kunlun-db: MySQL storage node (1, 1) returned error: 1060, Duplicate column name 'a'.
-- bug 83
drop table if exists revalidate_bug cascade;
NOTICE:  table "revalidate_bug" does not exist, skipping
drop function if exists inverse(int);
NOTICE:  function inverse(pg_catalog.int4) does not exist, skipping
create function inverse(int) returns float8 as
$$
begin

    return 1::float8/$1;

exception

    when division_by_zero then return 0;

end$$ language plpgsql volatile;
create table revalidate_bug (id serial primary key, c float8 unique);
insert into revalidate_bug (c) values (1);
insert into revalidate_bug (c) values (inverse(0));
select*from revalidate_bug ;
 id | c 
----+---
  2 | 0
  1 | 1
(2 rows)

-- bug 61
drop schema if exists s1 cascade;
NOTICE:  schema "s1" does not exist, skipping
create schema s1;
create table s1.t1(id int);
alter table s1.t1 set schema s1;
drop schema if exists s1 cascade;
NOTICE:  drop cascades to table s1.t1
--bug 80
drop table if exists SUBSELECT_TBL;
CREATE TABLE SUBSELECT_TBL ( id serial primary key, f1 integer, f2 integer, f3 float );
INSERT INTO SUBSELECT_TBL (f1, f2, f3) VALUES (1, 2, 3), (2, 3, 4), (3, 4, 5), (1, 1, 1), (2, 2, 2), (3, 3, 3), (6, 7, 8), (8, 9, NULL);
SELECT f1, f2 FROM SUBSELECT_TBL WHERE (f1, f2) NOT IN (SELECT f2, CAST(f3 AS int4) FROM SUBSELECT_TBL WHERE f3 IS NOT NULL);
 f1 | f2 
----+----
  1 |  2
  6 |  7
  8 |  9
(3 rows)

-- bug 33
begin;
savepoint sa;
release savepoint sa;
commit;
begin;
savepoint sa;
release savepoint sa;
rollback;
-- bug 13
SELECT SESSION_USER, CURRENT_USER;
 session_user | current_user 
--------------+--------------
 dzw          | dzw
(1 row)

drop schema if exists testschema cascade;
NOTICE:  schema "testschema" does not exist, skipping
CREATE SCHEMA if not exists testschema;
SELECT SESSION_USER, CURRENT_USER;
 session_user | current_user 
--------------+--------------
 dzw          | dzw
(1 row)

CREATE TABLE testschema.foo (i serial primary key, j serial);
insert into testschema.foo default values;
insert into testschema.foo default values;
select*from  testschema.foo;
 i | j 
---+---
 1 | 1
 2 | 2
(2 rows)

create sequence testschema.seq1;
select testschema.seq1.nextval, nextval('testschema.seq1');
 nextval | nextval 
---------+---------
       1 |       2
(1 row)

drop schema testschema cascade;
NOTICE:  drop cascades to 2 other objects
DETAIL:  drop cascades to table testschema.foo
drop cascades to sequence testschema.seq1
-- bug 44 todo
drop table if exists tenk1;
drop table if exists INT4_TBL;
 CREATE TABLE tenk1 (
 	id serial primary key,
    unique1 int4,
    unique2 int4,
    two int4,
    four int4,
    ten int4,
    twenty int4,
    hundred int4,
    thousand int4,
    twothousand int4,
    fivethous int4,
    tenthous int4,
    odd int4,
    even int4,
    stringu1 name,
    stringu2 name,
    string4 name
);
-- unique1, unique2, two, four, ten, twenty, hundred, thousand, twothousand, fivethous, tenthous, odd, even, stringu1 , stringu2 ,string4 
CREATE TABLE INT4_TBL(id serial primary key, f1 int4);
COPY tenk1(unique1, unique2, two, four, ten, twenty, hundred, thousand, twothousand, fivethous, tenthous, odd, even, stringu1 , stringu2 ,string4) FROM '/home/dzw/work/postgresql-11.5/src/test/regress/data/tenk.data';
insert into int4_tbl (f1) select generate_series(1,13);
explain (verbose, costs off)
    select b.unique1 from
        tenk1 a join tenk1 b on a.unique1 = b.unique2
        left join tenk1 c on b.unique1 = 42 and c.thousand = a.thousand
        join int4_tbl i1 on b.thousand = f1
        right join int4_tbl i2 on i2.f1 = b.tenthous
        order by 1;
ERROR:  bogus varattno for OUTER_VAR var: 3
explain (verbose, costs off)
    select b.unique1 from
        tenk1 a join tenk1 b on a.unique1 = b.unique2
        join int4_tbl i1 on b.thousand = f1
        right join int4_tbl i2 on i2.f1 = b.tenthous
        order by 1;
ERROR:  bogus varattno for OUTER_VAR var: 3
set enable_nestloop=false;
    select b.unique1 from
        tenk1 a join tenk1 b on a.unique1 = b.unique2
        left join tenk1 c on b.unique1 = 42 and c.thousand = a.thousand
        join int4_tbl i1 on b.thousand = f1
        right join int4_tbl i2 on i2.f1 = b.tenthous
        order by 1;
 unique1 
---------
       1
       2
       3
       4
       5
       6
       7
       8
       9
      10
      11
      12
      13
(13 rows)

set enable_nestloop=false;
    select b.unique1 from
        tenk1 a join tenk1 b on a.unique1 = b.unique2
        join int4_tbl i1 on b.thousand = f1
        right join int4_tbl i2 on i2.f1 = b.tenthous
        order by 1;
 unique1 
---------
       1
       2
       3
       4
       5
       6
       7
       8
       9
      10
      11
      12
      13
(13 rows)

set enable_remote_join_pushdown = false;
ERROR:  unrecognized mysql configuration parameter "enable_remote_join_pushdown"
explain (costs off)
    select b.unique1 from
        tenk1 a join tenk1 b on a.unique1 = b.unique2
        left join tenk1 c on b.unique1 = 42 and c.thousand = a.thousand
        join int4_tbl i1 on b.thousand = f1
        right join int4_tbl i2 on i2.f1 = b.tenthous
        order by 1;
                                                                                                                  QUERY PLAN                                                                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Sort Key: b.unique1
   ->  Hash Right Join
         Hash Cond: (b.tenthous = i2.f1)
         ->  Hash Join
               Hash Cond: (b.thousand = i1.f1)
               ->  Hash Left Join
                     Hash Cond: (a.thousand = c.thousand)
                     Join Filter: (b.unique1 = 42)
                     ->  Hash Join
                           Hash Cond: (a.unique1 = b.unique2)
                           ->  Materialize
                                 ->  RemoteScan on tenk1 a
                                       Shard: 2  Remote SQL: select id, unique1, unique2, two, four, ten, twenty, hundred, thousand, twothousand, fivethous, tenthous, odd, even, stringu1, stringu2, string4 from regression_$$_public.tenk1 
                           ->  Hash
                                 ->  Materialize
                                       ->  RemoteScan on tenk1 b
                                             Shard: 2    Remote SQL: select unique1, unique2, thousand, tenthous from regression_$$_public.tenk1 
                     ->  Hash
                           ->  RemoteScan on tenk1 c
                                 Shard: 2        Remote SQL: select thousand from regression_$$_public.tenk1 
               ->  Hash
                     ->  Materialize
                           ->  RemoteScan on int4_tbl i1
                                 Shard: 1        Remote SQL: select f1 from regression_$$_public.int4_tbl 
         ->  Hash
               ->  RemoteScan on int4_tbl i2
                     Shard: 1    Remote SQL: select f1 from regression_$$_public.int4_tbl 
(28 rows)

explain (costs off)
    select b.unique1 from
        tenk1 a join tenk1 b on a.unique1 = b.unique2
        join int4_tbl i1 on b.thousand = f1
        right join int4_tbl i2 on i2.f1 = b.tenthous
        order by 1;
                                                                                                                  QUERY PLAN                                                                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Sort Key: b.unique1
   ->  Hash Right Join
         Hash Cond: (b.tenthous = i2.f1)
         ->  Hash Join
               Hash Cond: (b.thousand = i1.f1)
               ->  Hash Join
                     Hash Cond: (a.unique1 = b.unique2)
                     ->  Materialize
                           ->  RemoteScan on tenk1 a
                                 Shard: 2        Remote SQL: select id, unique1, unique2, two, four, ten, twenty, hundred, thousand, twothousand, fivethous, tenthous, odd, even, stringu1, stringu2, string4 from regression_$$_public.tenk1 
                     ->  Hash
                           ->  RemoteScan on tenk1 b
                                 Shard: 2        Remote SQL: select unique1, unique2, thousand, tenthous from regression_$$_public.tenk1 
               ->  Hash
                     ->  Materialize
                           ->  RemoteScan on int4_tbl i1
                                 Shard: 1        Remote SQL: select f1 from regression_$$_public.int4_tbl 
         ->  Hash
               ->  RemoteScan on int4_tbl i2
                     Shard: 1    Remote SQL: select f1 from regression_$$_public.int4_tbl 
(21 rows)

set enable_nestloop=false;
    select b.unique1 from
        tenk1 a join tenk1 b on a.unique1 = b.unique2
        left join tenk1 c on b.unique1 = 42 and c.thousand = a.thousand
        join int4_tbl i1 on b.thousand = f1
        right join int4_tbl i2 on i2.f1 = b.tenthous
        order by 1;
 unique1 
---------
       1
       2
       3
       4
       5
       6
       7
       8
       9
      10
      11
      12
      13
(13 rows)

set enable_nestloop=false;
    select b.unique1 from
        tenk1 a join tenk1 b on a.unique1 = b.unique2
        join int4_tbl i1 on b.thousand = f1
        right join int4_tbl i2 on i2.f1 = b.tenthous
        order by 1;
 unique1 
---------
       1
       2
       3
       4
       5
       6
       7
       8
       9
      10
      11
      12
      13
(13 rows)

-- below portion is fixed, above portion not yet. TODO
 drop table if exists mlparted;
drop table if exists mlparted1;
drop table if exists mlparted11;
NOTICE:  table "mlparted11" does not exist, skipping
create table mlparted (a int, b int) partition by range (a, b);
create table mlparted1 (b int not null, a int not null) partition by range ((b+0));
create table mlparted11 (like mlparted1);
alter table mlparted1 attach partition mlparted11 for values from (2) to (5);
WARNING:  Alter Table command ATTACH PARTITION not supported and skipped.
alter table mlparted attach partition mlparted1 for values from (1, 2) to (1, 10);
WARNING:  Alter Table command ATTACH PARTITION not supported and skipped.
with ins (a, b, c) as (insert into mlparted (b, a) select s.a, 1 from generate_series(2, 39) s(a) returning tableoid::regclass, *) select a, b, min(c), max(c) from ins group by a, b order by 1;
ERROR:  no partition of relation "mlparted" found for row
DETAIL:  Partition key of the failing row contains (a, b) = (1, 2).
with ins (a, b, c) as (insert into mlparted (b, a) select s.a, 1 from generate_series(2, 39) s(a) returning tableoid::regclass, *) select a, b, min(c), max(c) from ins group by a, b order by 1;
ERROR:  no partition of relation "mlparted" found for row
DETAIL:  Partition key of the failing row contains (a, b) = (1, 2).
-- bug 41
 drop table if exists INT8_TBL;
CREATE TABLE INT8_TBL(id serial primary key, q1 int8, q2 int8);
INSERT INTO INT8_TBL (q1, q2) VALUES(' 123 ',' 456');
INSERT INTO INT8_TBL (q1, q2) VALUES('123 ','4567890123456789');
INSERT INTO INT8_TBL (q1, q2) VALUES('4567890123456789','123');
INSERT INTO INT8_TBL (q1, q2) VALUES(+4567890123456789,'4567890123456789');
INSERT INTO INT8_TBL (q1, q2) VALUES('+4567890123456789','-4567890123456789');
select q1, float8(count(*)) / (select count(*) from int8_tbl) from int8_tbl group by q1 order by q1;
        q1        | ?column? 
------------------+----------
              123 |      0.4
 4567890123456789 |      0.6
(2 rows)

explain (verbose)
select q1, float8(count(*)) / (select count(*) from int8_tbl) from int8_tbl group by q1 order by q1;
                                            QUERY PLAN                                             
---------------------------------------------------------------------------------------------------
 GroupAggregate  (cost=0.02..0.05 rows=1 width=16)
   Output: int8_tbl.q1, (float8(count(*)) / ($0)::double precision)
   Group Key: int8_tbl.q1
   InitPlan 1 (returns $0)
     ->  Aggregate  (cost=0.00..0.01 rows=1 width=8)
           Output: count(*)
           ->  Materialize  (cost=0.00..0.01 rows=1 width=0)
                 Output: int8_tbl_1.id, int8_tbl_1.q1, int8_tbl_1.q2
                 ->  RemoteScan on public.int8_tbl int8_tbl_1  (cost=0.00..0.00 rows=1 width=0)
                       Output: int8_tbl_1.id, int8_tbl_1.q1, int8_tbl_1.q2
                       Shard: 2  Remote SQL: select id, q1, q2 from regression_$$_public.int8_tbl 
   ->  Sort  (cost=0.01..0.02 rows=1 width=8)
         Output: int8_tbl.q1
         Sort Key: int8_tbl.q1
         ->  Materialize  (cost=0.00..0.01 rows=1 width=8)
               Output: int8_tbl.q1
               ->  RemoteScan on public.int8_tbl  (cost=0.00..0.00 rows=1 width=8)
                     Output: int8_tbl.q1
                     Shard: 2    Remote SQL: select q1 from regression_$$_public.int8_tbl 
(19 rows)

-- bug 78
create table b1(v box);
ERROR:  Kunlun-db: Not supported type (603).
-- bug 50 THIS BUG Is postponed
create user user1;
ERROR:  role "user1" already exists
SET SESSION AUTHORIZATION user1;
SET row_security = on;
drop table if exists r1;
NOTICE:  table "r1" does not exist, skipping
CREATE TABLE r1 (a int primary key);
INSERT INTO r1 VALUES (10), (20);
CREATE POLICY p1 ON r1 USING (false);
ERROR:  Statement 'CREATE POLICY' is not supported in Kunlun.
ALTER TABLE r1 ENABLE ROW LEVEL SECURITY;
WARNING:  Alter Table command ENABLE ROW SECURITY not supported and skipped.
ALTER TABLE r1 FORCE ROW LEVEL SECURITY;
WARNING:  Alter Table command FORCE ROW SECURITY not supported and skipped.
TABLE r1;
 a  
----
 10
 20
(2 rows)

INSERT INTO r1 VALUES (1);
UPDATE r1 SET a = 1;
ERROR:  Kunlun-db: MySQL storage node (1, 1) returned error: 1062, Duplicate entry '1' for key 'PRIMARY'.
DELETE FROM r1;
SET SESSION AUTHORIZATION dzw;
-- bug 57
drop table if exists temptest1;
NOTICE:  table "temptest1" does not exist, skipping
begin;
CREATE TEMP TABLE temptest1(col int PRIMARY KEY);
insert into temptest1 values (1),(2);
select*from temptest1;
 col 
-----
   1
   2
(2 rows)

commit;
drop table if exists temptest2;
NOTICE:  table "temptest2" does not exist, skipping
begin;
CREATE TEMP TABLE temptest2(col int PRIMARY KEY) ON COMMIT DELETE ROWS;
insert into temptest2 values (1),(2);
select*from temptest2;
 col 
-----
   1
   2
(2 rows)

commit;
-- bug 84
drop table if exists collate_test10;
NOTICE:  table "collate_test10" does not exist, skipping
 CREATE TABLE collate_test10 (
    a int primary key,
    x varchar(50) COLLATE "C",
    y varchar(50) COLLATE "POSIX"
);
INSERT INTO collate_test10 VALUES (1, 'hij', 'hij'), (2, 'HIJ', 'HIJ');
select x < y from collate_test10;
 ?column? 
----------
 f
 f
(2 rows)

drop table if exists collate_test1;
NOTICE:  table "collate_test1" does not exist, skipping
drop table if exists collate_test2;
NOTICE:  table "collate_test2" does not exist, skipping
CREATE TABLE collate_test1 (id serial primary key, a int, b varchar(50) COLLATE "C" NOT NULL);
CREATE TABLE collate_test2 (id serial primary key,  a int, b varchar(50) COLLATE "POSIX" );
INSERT INTO collate_test1 (a,b) VALUES (1, 'abc'), (2, 'Abc'), (3, 'bbc'), (4, 'ABD');
INSERT INTO collate_test2 (a,b) SELECT a,b FROM collate_test1;
SELECT a, b FROM collate_test2 WHERE a < 4 INTERSECT SELECT a, b FROM collate_test2 WHERE a > 1 ORDER BY 2;
 a |  b  
---+-----
 2 | Abc
 3 | bbc
(2 rows)

-- bug 37
CREATE TABLE moneyp (a money) PARTITION BY LIST (a);
CREATE TABLE moneyp_10 PARTITION OF moneyp FOR VALUES IN (10);
ERROR:  specified value cannot be cast to type money for column "a"
LINE 1: ...EATE TABLE moneyp_10 PARTITION OF moneyp FOR VALUES IN (10);
                                                                   ^
DETAIL:  The cast requires a non-immutable conversion.
HINT:  Try putting the literal value in single quotes.
drop table if exists list_parted;
NOTICE:  table "list_parted" does not exist, skipping
CREATE TABLE list_parted (a int) PARTITION BY LIST (a);
CREATE TABLE part_1 PARTITION OF list_parted FOR VALUES IN ('1');
CREATE TABLE fail_part PARTITION OF list_parted FOR VALUES IN (int '1');
ERROR:  syntax error at or near "int"
LINE 1: ... fail_part PARTITION OF list_parted FOR VALUES IN (int '1');
                                                              ^
CREATE TABLE fail_part PARTITION OF list_parted FOR VALUES IN ('1'::int);
ERROR:  syntax error at or near "::"
LINE 1: ...fail_part PARTITION OF list_parted FOR VALUES IN ('1'::int);
                                                                ^
-- bug 72
drop table if exists onek;
NOTICE:  table "onek" does not exist, skipping
CREATE TABLE onek (
    unique1 int4,
    unique2 int4,
    two int4,
    four int4,
    ten int4,
    twenty int4,
    hundred int4,
    thousand int4,
    twothousand int4,
    fivethous int4,
    tenthous int4,
    odd int4,
    even int4,
    stringu1 name,
    stringu2 name,
    string4 name
);
CREATE UNIQUE INDEX onek_idx ON onek (unique2 nulls first,unique1);
-- bug 34
drop table if exists part_attmp cascade;
NOTICE:  table "part_attmp" does not exist, skipping
CREATE TABLE part_attmp (a int primary key) partition by range (a);
CREATE TABLE part_attmp1 PARTITION OF part_attmp FOR VALUES FROM (0) TO (100);
ALTER INDEX part_attmp_pkey RENAME TO part_attmp_index;
ALTER INDEX part_attmp1_pkey RENAME TO part_attmp1_index;
alter table part_attmp add column b int;
create index part_attmp_b_idx on part_attmp(b);
ALTER INDEX part_attmp_b_idx RENAME TO part_attmp_b_index;
ALTER INDEX part_attmp1_b_idx RENAME TO part_attmp1_b_index;
-- bug 14
drop table if exists test_default_tab cascade;
NOTICE:  table "test_default_tab" does not exist, skipping
CREATE TABLE test_default_tab(pk serial primary key, id int);
CREATE INDEX test_index1 on test_default_tab (id);
ALTER TABLE test_default_tab ALTER id TYPE bigint;
drop table if exists anothertab cascade;
NOTICE:  table "anothertab" does not exist, skipping
create table anothertab(f1 int primary key, f2 int unique,f3 int, f4 int, f5 int);
alter table anothertab add unique(f1,f4);
create index on anothertab(f2,f3);
create unique index on anothertab(f4);
alter table anothertab alter column f1 type bigint;
alter table anothertab
    alter column f2 type bigint,
    alter column f3 type bigint,
    alter column f4 type bigint;
create table at_partitioned(id int primary key, name varchar(64), unique (id, name)) partition by hash(id);
create table at_partitioned_1 partition of at_partitioned for values with (modulus 2, remainder 1);
alter table at_partitioned alter column name type varchar(127);
-- bug 24 this doesn't pass now. we have to disable DEFAULT partitions now.
-- drop table if exists range_parted2 cascade;
--  CREATE TABLE range_parted2 (a int primary key) PARTITION BY RANGE (a);
-- CREATE TABLE range2_default PARTITION OF range_parted2 DEFAULT;
-- INSERT INTO range_parted2 VALUES (85);
-- CREATE TABLE fail_part PARTITION OF range_parted2 FOR VALUES FROM (80) TO (90);
-- CREATE TABLE part4 PARTITION OF range_parted2 FOR VALUES FROM (90) TO (100);
-- 
-- 
-- drop table if exists pc_list_parted cascade;
-- create table pc_list_parted (a int primary key) partition by list(a);
-- create table pc_list_part_1 partition of pc_list_parted for values in (1);
-- create table pc_list_part_2 partition of pc_list_parted for values in (2);
-- create table pc_list_part_def partition of pc_list_parted default;
-- create table pc_list_part_3 partition of pc_list_parted for values in (3);
-- 
-- drop table if exists quuux cascade;
-- CREATE TABLE quuux (a int primary key, b text) PARTITION BY LIST (a);
-- CREATE TABLE quuux_default PARTITION OF quuux DEFAULT PARTITION BY LIST (b);
-- CREATE TABLE quuux_default1 PARTITION OF quuux_default FOR VALUES IN ('b');
-- CREATE TABLE quuux1 (a int, b text);
-- ALTER TABLE quuux ATTACH PARTITION quuux1 FOR VALUES IN (1);
-- CREATE TABLE quuux2 (a int, b text);
-- ALTER TABLE quuux ATTACH PARTITION quuux2 FOR VALUES IN (2);
-- DROP TABLE quuux1;
-- DROP TABLE quuux2;
-- CREATE TABLE quuux1 PARTITION OF quuux FOR VALUES IN (1);
-- CREATE TABLE quuux2 PARTITION OF quuux FOR VALUES IN (2);
-- bug 62 this doesn't pass now. we have to disable 'ALTER TABLE ... ATTACH PARTITION' now.
-- CREATE TABLE list_parted2 (a int,b char) PARTITION BY LIST (a);
-- CREATE TABLE part_2 (LIKE list_parted2);
-- INSERT INTO part_2 VALUES (3, 'a');
-- ALTER TABLE list_parted2 ATTACH PARTITION part_2 FOR VALUES IN (2);
--
-- bug 56
drop table if exists pc_list_parted  cascade;
NOTICE:  table "pc_list_parted" does not exist, skipping
create table pc_list_parted (a int primary key) partition by list(a);
create table pc_list_part_null partition of pc_list_parted for values in (null);
create table pc_list_part_1 partition of pc_list_parted for values in (1);
insert into pc_list_part_1 values(2);
ERROR:  new row for relation "pc_list_part_1" violates partition constraint
DETAIL:  Failing row contains (2).
-- bug 25
drop table if exists concur_heap;
NOTICE:  table "concur_heap" does not exist, skipping
CREATE TABLE concur_heap (id serial primary key, f1 int, f2 int);
insert into concur_heap (f1, f2) values(2,3),(3,5),(5,7),(7,11);
CREATE INDEX CONCURRENTLY concur_index1 ON concur_heap(f2,f1);
select*from concur_heap;
 id | f1 | f2 
----+----+----
  1 |  2 |  3
  2 |  3 |  5
  3 |  5 |  7
  4 |  7 | 11
(4 rows)

-- bug 110
drop table if exists INT8_TBL cascade;
CREATE TABLE INT8_TBL(q1 int8, q2 int8);
INSERT INTO INT8_TBL VALUES(' 123 ',' 456');
INSERT INTO INT8_TBL VALUES('123 ','4567890123456789');
INSERT INTO INT8_TBL VALUES('4567890123456789','123');
INSERT INTO INT8_TBL VALUES(+4567890123456789,'4567890123456789');
INSERT INTO INT8_TBL VALUES('+4567890123456789','-4567890123456789');
create view tt17v as select * from int8_tbl i where i in (values(i));
select * from tt17v;
        q1        |        q2         
------------------+-------------------
              123 |               456
              123 |  4567890123456789
 4567890123456789 |               123
 4567890123456789 |  4567890123456789
 4567890123456789 | -4567890123456789
(5 rows)

-- bug 111
drop table if exists persons;
NOTICE:  table "persons" does not exist, skipping
drop type if exists person_type cascade;
NOTICE:  type "person_type" does not exist, skipping
CREATE TYPE person_type AS (id int, name varchar(50));
CREATE TABLE persons OF person_type;
ERROR:  Kunlun-db: The way of creating a table not supported.
-- bug 112
drop table if exists base_tbl cascade;
NOTICE:  drop cascades to view rw_view1
drop view if existrs rw_view1;
ERROR:  syntax error at or near "existrs"
LINE 1: drop view if existrs rw_view1;
                     ^
CREATE TABLE base_tbl (a int, b int DEFAULT 10);
INSERT INTO base_tbl VALUES (1,2), (2,3), (1,-1);
CREATE VIEW rw_view1 AS SELECT * FROM base_tbl WHERE a < b WITH LOCAL CHECK OPTION;
WARNING:  views with CHECK options are not supported, the view will be created but the check constraints will be ignored silently.
INSERT INTO rw_view1 values(3,2),(4,3), (3,4);
-- bug 114
drop table if exists update_test;
NOTICE:  table "update_test" does not exist, skipping
CREATE TABLE update_test (a INT DEFAULT 10, b INT, c TEXT);
INSERT INTO update_test VALUES (5, 10, 'foo');
INSERT INTO update_test(b, a) VALUES (15, 10);
UPDATE update_test t SET (a, b) = (SELECT b, a FROM update_test s WHERE s.a = t.a) WHERE CURRENT_USER = SESSION_USER;
ERROR:  Kunlun-db: Can't access system attribute(ctid) from remote tables.
-- bug 116
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1(pk int not null primary key);
ALTER TABLE t1 ADD COLUMN c_num NUMERIC DEFAULT 1.00000000001;
insert into t1 values(1),(2),(3),(4),(5);
select * from t1;
 pk |         c_num          
----+------------------------
  1 | 1.00000000001000000000
  2 | 1.00000000001000000000
  3 | 1.00000000001000000000
  4 | 1.00000000001000000000
  5 | 1.00000000001000000000
(5 rows)

-- bug 126
drop table if exists t1;
create table t1(a int);
insert into t1 values(1),(2),(3);
update t1 set a=3 returning *;
 a 
---
 3
 3
(2 rows)

delete from t1 returning *;
 a 
---
 3
 3
 3
(3 rows)

-- bug 127
-- TODO: verify the stmt is sent to ddl log after each ddl stmt. so far we don't have such test facility.
DROP SCHEMA if exists testschema cascade;
NOTICE:  schema "testschema" does not exist, skipping
CREATE SCHEMA testschema;
CREATE TABLE testschema.part0 (a int) PARTITION BY LIST (a);
drop table testschema.part0;
CREATE TABLE testschema.part1 (a serial primary key, b int, c varchar(32), unique (b,a)) PARTITION BY LIST (a);
create index part1_b_c2 on testschema.part1(b,c);
create table testschema.part1_0 partition of testschema.part1 for values in (1,2,3,4);
create table testschema.part1_1 partition of testschema.part1 for values in (5,6,7,8);
insert into testschema.part1 (b,c) values(14, 'def'),(15,'efg'),(16,'fgh');
select*from testschema.part1 ;
 a | b  |  c  
---+----+-----
 1 | 14 | def
 2 | 15 | efg
 3 | 16 | fgh
(3 rows)

create index part1_b_c on testschema.part1(b,c);
insert into testschema.part1 (b,c) values(17, 'ghi'),(18,'hij'),(19,'ijk');
select*from testschema.part1 ;
 a | b  |  c  
---+----+-----
 1 | 14 | def
 2 | 15 | efg
 3 | 16 | fgh
 4 | 17 | ghi
 5 | 18 | hij
 6 | 19 | ijk
(6 rows)

drop index testschema.part1_b_c;
insert into testschema.part1 (b,c) values(11, 'abc'),(12,'bcd'),(13,'cde');
ERROR:  no partition of relation "part1" found for row
DETAIL:  Partition key of the failing row contains (a) = (9).
select*from testschema.part1 ;
 a | b  |  c  
---+----+-----
 1 | 14 | def
 2 | 15 | efg
 3 | 16 | fgh
 4 | 17 | ghi
 5 | 18 | hij
 6 | 19 | ijk
(6 rows)

drop schema testschema cascade;
NOTICE:  drop cascades to table testschema.part1
-- bug 121
drop table if exists indext1;
NOTICE:  table "indext1" does not exist, skipping
create table indext1(id integer);
ALTER TABLE indext1 ADD CONSTRAINT oindext1_id_constraint UNIQUE (id);
ALTER TABLE indext1 DROP CONSTRAINT oindext1_id_constraint;
CREATE TABLE part1 (a serial primary key, b int, c varchar(32), unique (b,a)) PARTITION BY LIST (a);
create index part1_b_c2 on part1(b,c);
create table part1_0 partition of part1 for values in (1,2,3,4);
insert into part1 (b,c) values(11, 'abc'),(12,'bcd'),(13,'cde');
select*from part1;
 a | b  |  c  
---+----+-----
 1 | 11 | abc
 2 | 12 | bcd
 3 | 13 | cde
(3 rows)

ALTER TABLE part1 ADD CONSTRAINT opart1_c_constraint UNIQUE (c,a);
create table part1_1 partition of part1 for values in (5,6,7,8);
insert into part1 (b,c) values(14, 'def'),(15,'efg'),(16,'fgh');
alter table part1 add column d int not null;
select*from part1;
 a | b  |  c  | d 
---+----+-----+---
 1 | 11 | abc | 0
 2 | 12 | bcd | 0
 3 | 13 | cde | 0
 4 | 14 | def | 0
 5 | 15 | efg | 0
 6 | 16 | fgh | 0
(6 rows)

create table part1_2 partition of part1 for values in (9,10,11,12);
insert into part1 (b,c,d) values(17, 'ghi', 21),(18,'hij',22),(19,'ijk',23);
select*from part1;
 a | b  |  c  | d  
---+----+-----+----
 1 | 11 | abc |  0
 2 | 12 | bcd |  0
 3 | 13 | cde |  0
 4 | 14 | def |  0
 5 | 15 | efg |  0
 6 | 16 | fgh |  0
 7 | 17 | ghi | 21
 8 | 18 | hij | 22
 9 | 19 | ijk | 23
(9 rows)

ALTER TABLE part1 ADD CONSTRAINT opart1_b_constraint UNIQUE (b,a);
create table part1_3 partition of part1 for values in (13,14,15,16);
insert into part1 (b,c,d) values(20, 'jkl', 24),(21,'klm',25),(22,'lmn',26);
ALTER TABLE part1 ADD CONSTRAINT opart1_d_constraint UNIQUE (d,a);
ALTER TABLE part1 DROP CONSTRAINT opart1_c_constraint;
ALTER TABLE part1 DROP CONSTRAINT opart1_d_constraint;
ALTER TABLE part1 DROP CONSTRAINT opart1_b_constraint;
drop index part1_b_c2;
drop table part1;
-- bug 135
drop table if exists t1 cascade;
create table t1(v1 decimal(10,2));
insert into t1 values(1.1), (2.2);
select*from t1;
  v1  
------
 1.10
 2.20
(2 rows)

update t1 set v1 = v1 + 1;
select*from t1;
  v1  
------
 2.10
 3.20
(2 rows)

PREPARE pq1(int, int) AS SELECT * FROM t1 WHERE v1 between $1 and $2;
EXECUTE pq1(-4, 4);
  v1  
------
 2.10
 3.20
(2 rows)

PREPARE pq2(int) AS update t1 set v1=v1+$1;
EXECUTE pq2(1);
select*from t1;
  v1  
------
 3.10
 4.20
(2 rows)

PREPARE pq3(float) AS update t1 set v1=v1+$1;
EXECUTE pq3(2.0);
PREPARE pq4(float, float) AS SELECT * FROM t1 WHERE v1 between $1 and $2;
EXECUTE pq4(-8.0, 8.0);
  v1  
------
 5.10
 6.20
(2 rows)

-- bug 190
drop table if exists t2 cascade;
create table t2(id int primary key, good boolean);
insert into t2 values(1, true);
insert into t2 values(2, false);
update t2 set good = false where id = 1;
-- bug 199
drop table if exists t4 cascade;
NOTICE:  table "t4" does not exist, skipping
create table t4(a money);
insert into t4 values(999);
insert into t4 values(1000);
insert into t4 values (-92233720368547758.08);
insert into t4 values (+92233720368547758.07);
select*from t4;
              a              
-----------------------------
                     $999.00
                   $1,000.00
 -$92,233,720,368,547,758.08
  $92,233,720,368,547,758.07
(4 rows)

insert into t4 values (-92233720368547758.09); -- bigint out of range
ERROR:  bigint out of range
insert into t4 values (+92233720368547758.08); -- bigint out of range
ERROR:  bigint out of range
insert into t4 values (-1111);
select*from t4;
              a              
-----------------------------
                     $999.00
                   $1,000.00
 -$92,233,720,368,547,758.08
  $92,233,720,368,547,758.07
                  -$1,111.00
(5 rows)

-- bug 94
 drop table if exists FLOAT4_TBL cascade;
NOTICE:  table "float4_tbl" does not exist, skipping
CREATE TABLE FLOAT4_TBL (f1 float4);
INSERT INTO FLOAT4_TBL(f1) VALUES (' 0.0');
INSERT INTO FLOAT4_TBL(f1) VALUES ('1004.30 ');
INSERT INTO FLOAT4_TBL(f1) VALUES (' -34.84 ');
INSERT INTO FLOAT4_TBL(f1) VALUES ('1.2345678901234e+20');
INSERT INTO FLOAT4_TBL(f1) VALUES ('1.2345678901234e-20');
select f1 from float4_tbl;
     f1      
-------------
           0
      1004.3
      -34.84
 1.23457e+20
 1.23457e-20
(5 rows)

SELECT f.* FROM FLOAT4_TBL f WHERE f.f1 = 1004.3;
   f1   
--------
 1004.3
(1 row)

SELECT f.* FROM FLOAT4_TBL f WHERE f.f1 <> '1004.3';
     f1      
-------------
           0
      -34.84
 1.23457e+20
 1.23457e-20
(4 rows)

-- bug 118 Bad results for partition join query when SET enable_partitionwise_join to true
SET enable_partitionwise_join TO true;
drop table if exists pagg_tab1;
NOTICE:  table "pagg_tab1" does not exist, skipping
CREATE TABLE pagg_tab1(x int, y int) PARTITION BY RANGE(x);
CREATE TABLE pagg_tab1_p1 PARTITION OF pagg_tab1 FOR VALUES FROM (0) TO (10);
CREATE TABLE pagg_tab1_p2 PARTITION OF pagg_tab1 FOR VALUES FROM (10) TO (20);
CREATE TABLE pagg_tab1_p3 PARTITION OF pagg_tab1 FOR VALUES FROM (20) TO (30);
drop table if exists pagg_tab2;
NOTICE:  table "pagg_tab2" does not exist, skipping
CREATE TABLE pagg_tab2(x int, y int) PARTITION BY RANGE(y);
CREATE TABLE pagg_tab2_p1 PARTITION OF pagg_tab2 FOR VALUES FROM (0) TO (10);
CREATE TABLE pagg_tab2_p2 PARTITION OF pagg_tab2 FOR VALUES FROM (10) TO (20);
CREATE TABLE pagg_tab2_p3 PARTITION OF pagg_tab2 FOR VALUES FROM (20) TO (30);
INSERT INTO pagg_tab1 SELECT i % 30, i % 20 FROM generate_series(0, 299, 2) i;
INSERT INTO pagg_tab2 SELECT i % 20, i % 30 FROM generate_series(0, 299, 3) i;
DROP TABLE if exists prt1 cascade;
CREATE TABLE prt1 (a int, b int, c varchar) PARTITION BY RANGE(a);
CREATE TABLE prt1_p1 PARTITION OF prt1 FOR VALUES FROM (0) TO (250);
CREATE TABLE prt1_p3 PARTITION OF prt1 FOR VALUES FROM (500) TO (600);
CREATE TABLE prt1_p2 PARTITION OF prt1 FOR VALUES FROM (250) TO (500);
INSERT INTO prt1 SELECT i, i % 25, to_char(i, 'FM0000') FROM generate_series(0, 599) i WHERE i % 2 = 0;
DROP TABLE if exists prt2 cascade;
CREATE TABLE prt2 (a int, b int, c varchar) PARTITION BY RANGE(b);
CREATE TABLE prt2_p1 PARTITION OF prt2 FOR VALUES FROM (0) TO (250);
CREATE TABLE prt2_p2 PARTITION OF prt2 FOR VALUES FROM (250) TO (500);
CREATE TABLE prt2_p3 PARTITION OF prt2 FOR VALUES FROM (500) TO (600);
INSERT INTO prt2 SELECT i % 25, i, to_char(i, 'FM0000') FROM generate_series(0, 599) i WHERE i % 3 = 0;
DROP TABLE if exists prt1_e;
NOTICE:  table "prt1_e" does not exist, skipping
CREATE TABLE prt1_e (a int, b int, c int) PARTITION BY RANGE(((a + b)/2));
CREATE TABLE prt1_e_p1 PARTITION OF prt1_e FOR VALUES FROM (0) TO (250);
CREATE TABLE prt1_e_p2 PARTITION OF prt1_e FOR VALUES FROM (250) TO (500);
CREATE TABLE prt1_e_p3 PARTITION OF prt1_e FOR VALUES FROM (500) TO (600);
INSERT INTO prt1_e SELECT i, i, i % 25 FROM generate_series(0, 599, 2) i;
DROP TABLE if exists prt2_e;
NOTICE:  table "prt2_e" does not exist, skipping
CREATE TABLE prt2_e (a int, b int, c int) PARTITION BY RANGE(((b + a)/2));
CREATE TABLE prt2_e_p1 PARTITION OF prt2_e FOR VALUES FROM (0) TO (250);
CREATE TABLE prt2_e_p2 PARTITION OF prt2_e FOR VALUES FROM (250) TO (500);
CREATE TABLE prt2_e_p3 PARTITION OF prt2_e FOR VALUES FROM (500) TO (600);
INSERT INTO prt2_e SELECT i, i, i % 25 FROM generate_series(0, 599, 3) i;
set enable_hashjoin=false;
set enable_mergejoin=false;
set enable_nestloop=true;
SELECT t1.x, sum(t1.y), count(*) FROM pagg_tab1 t1, pagg_tab2 t2 WHERE t1.x = t2.y GROUP BY t1.x ORDER BY 1, 2, 3;
 x  | sum  | count 
----+------+-------
  0 |  500 |   100
  6 | 1100 |   100
 12 |  700 |   100
 18 | 1300 |   100
 24 |  900 |   100
(5 rows)

EXPLAIN (verbose, COSTS OFF)
SELECT t1.x, sum(t1.y), count(*) FROM pagg_tab1 t1, pagg_tab2 t2 WHERE t1.x = t2.y GROUP BY t1.x ORDER BY 1, 2, 3;
                                                   QUERY PLAN                                                    
-----------------------------------------------------------------------------------------------------------------
 Sort
   Output: t1.x, (sum(t1.y)), (count(*))
   Sort Key: t1.x, (sum(t1.y)), (count(*))
   ->  HashAggregate
         Output: t1.x, sum(t1.y), count(*)
         Group Key: t1.x
         ->  Append
               ->  Nested Loop
                     Output: t1.x, t1.y
                     Join Filter: (t1.x = t2.y)
                     ->  Materialize
                           Output: t1.x, t1.y
                           ->  RemoteScan on public.pagg_tab1_p1 t1
                                 Output: t1.x, t1.y
                                 Shard: 2        Remote SQL: select x, y from regression_$$_public.pagg_tab1_p1 
                     ->  Materialize
                           Output: t2.y
                           ->  RemoteScan on public.pagg_tab2_p1 t2
                                 Output: t2.y
                                 Shard: 1        Remote SQL: select y from regression_$$_public.pagg_tab2_p1 
               ->  Nested Loop
                     Output: t1_1.x, t1_1.y
                     Join Filter: (t1_1.x = t2_1.y)
                     ->  Materialize
                           Output: t1_1.x, t1_1.y
                           ->  RemoteScan on public.pagg_tab1_p2 t1_1
                                 Output: t1_1.x, t1_1.y
                                 Shard: 2        Remote SQL: select x, y from regression_$$_public.pagg_tab1_p2 
                     ->  Materialize
                           Output: t2_1.y
                           ->  RemoteScan on public.pagg_tab2_p2 t2_1
                                 Output: t2_1.y
                                 Shard: 2        Remote SQL: select y from regression_$$_public.pagg_tab2_p2 
               ->  Nested Loop
                     Output: t1_2.x, t1_2.y
                     Join Filter: (t1_2.x = t2_2.y)
                     ->  RemoteScan on public.pagg_tab1_p3 t1_2
                           Output: t1_2.x, t1_2.y
                           Shard: 2      Remote SQL: select x, y from regression_$$_public.pagg_tab1_p3 
                     ->  RemoteScan on public.pagg_tab2_p3 t2_2
                           Output: t2_2.y
                           Shard: 1      Remote SQL: select y from regression_$$_public.pagg_tab2_p3 
(42 rows)

SELECT t1.y, sum(t1.x), count(*) FROM pagg_tab1 t1, pagg_tab2 t2 WHERE t1.x = t2.y GROUP BY t1.y HAVING avg(t1.x) > 10 ORDER BY 1, 2, 3;
 y  | sum  | count 
----+------+-------
  2 |  600 |    50
  4 | 1200 |    50
  8 |  900 |    50
 12 |  600 |    50
 14 | 1200 |    50
 18 |  900 |    50
(6 rows)

EXPLAIN (verbose, COSTS OFF)
SELECT t1.y, sum(t1.x), count(*) FROM pagg_tab1 t1, pagg_tab2 t2 WHERE t1.x = t2.y GROUP BY t1.y HAVING avg(t1.x) > 10 ORDER BY 1, 2, 3;
                                                   QUERY PLAN                                                    
-----------------------------------------------------------------------------------------------------------------
 Sort
   Output: t1.y, (sum(t1.x)), (count(*))
   Sort Key: t1.y, (sum(t1.x)), (count(*))
   ->  HashAggregate
         Output: t1.y, sum(t1.x), count(*)
         Group Key: t1.y
         Filter: (avg(t1.x) > '10'::numeric)
         ->  Append
               ->  Nested Loop
                     Output: t1.y, t1.x
                     Join Filter: (t1.x = t2.y)
                     ->  Materialize
                           Output: t1.y, t1.x
                           ->  RemoteScan on public.pagg_tab1_p1 t1
                                 Output: t1.y, t1.x
                                 Shard: 2        Remote SQL: select y, x from regression_$$_public.pagg_tab1_p1 
                     ->  Materialize
                           Output: t2.y
                           ->  RemoteScan on public.pagg_tab2_p1 t2
                                 Output: t2.y
                                 Shard: 1        Remote SQL: select y from regression_$$_public.pagg_tab2_p1 
               ->  Nested Loop
                     Output: t1_1.y, t1_1.x
                     Join Filter: (t1_1.x = t2_1.y)
                     ->  Materialize
                           Output: t1_1.y, t1_1.x
                           ->  RemoteScan on public.pagg_tab1_p2 t1_1
                                 Output: t1_1.y, t1_1.x
                                 Shard: 2        Remote SQL: select y, x from regression_$$_public.pagg_tab1_p2 
                     ->  Materialize
                           Output: t2_1.y
                           ->  RemoteScan on public.pagg_tab2_p2 t2_1
                                 Output: t2_1.y
                                 Shard: 2        Remote SQL: select y from regression_$$_public.pagg_tab2_p2 
               ->  Nested Loop
                     Output: t1_2.y, t1_2.x
                     Join Filter: (t1_2.x = t2_2.y)
                     ->  RemoteScan on public.pagg_tab1_p3 t1_2
                           Output: t1_2.y, t1_2.x
                           Shard: 2      Remote SQL: select y, x from regression_$$_public.pagg_tab1_p3 
                     ->  RemoteScan on public.pagg_tab2_p3 t2_2
                           Output: t2_2.y
                           Shard: 1      Remote SQL: select y from regression_$$_public.pagg_tab2_p3 
(43 rows)

SELECT b.y, sum(a.y) FROM pagg_tab1 a LEFT JOIN pagg_tab2 b ON a.x = b.y GROUP BY b.y ORDER BY 1 NULLS LAST;
 y  | sum  
----+------
  0 |  500
  6 | 1100
 12 |  700
 18 | 1300
 24 |  900
    |  900
(6 rows)

EXPLAIN (verbose, COSTS OFF)
SELECT b.y, sum(a.y) FROM pagg_tab1 a LEFT JOIN pagg_tab2 b ON a.x = b.y GROUP BY b.y ORDER BY 1 NULLS LAST;
                                                   QUERY PLAN                                                    
-----------------------------------------------------------------------------------------------------------------
 GroupAggregate
   Output: b.y, sum(a.y)
   Group Key: b.y
   ->  Sort
         Output: b.y, a.y
         Sort Key: b.y
         ->  Append
               ->  Nested Loop Left Join
                     Output: b.y, a.y
                     Join Filter: (a.x = b.y)
                     ->  Materialize
                           Output: a.y, a.x
                           ->  RemoteScan on public.pagg_tab1_p1 a
                                 Output: a.y, a.x
                                 Shard: 2        Remote SQL: select y, x from regression_$$_public.pagg_tab1_p1 
                     ->  Materialize
                           Output: b.y
                           ->  RemoteScan on public.pagg_tab2_p1 b
                                 Output: b.y
                                 Shard: 1        Remote SQL: select y from regression_$$_public.pagg_tab2_p1 
               ->  Nested Loop Left Join
                     Output: b_1.y, a_1.y
                     Join Filter: (a_1.x = b_1.y)
                     ->  Materialize
                           Output: a_1.y, a_1.x
                           ->  RemoteScan on public.pagg_tab1_p2 a_1
                                 Output: a_1.y, a_1.x
                                 Shard: 2        Remote SQL: select y, x from regression_$$_public.pagg_tab1_p2 
                     ->  Materialize
                           Output: b_1.y
                           ->  RemoteScan on public.pagg_tab2_p2 b_1
                                 Output: b_1.y
                                 Shard: 2        Remote SQL: select y from regression_$$_public.pagg_tab2_p2 
               ->  Nested Loop Left Join
                     Output: b_2.y, a_2.y
                     Join Filter: (a_2.x = b_2.y)
                     ->  RemoteScan on public.pagg_tab1_p3 a_2
                           Output: a_2.y, a_2.x
                           Shard: 2      Remote SQL: select y, x from regression_$$_public.pagg_tab1_p3 
                     ->  RemoteScan on public.pagg_tab2_p3 b_2
                           Output: b_2.y
                           Shard: 1      Remote SQL: select y from regression_$$_public.pagg_tab2_p3 
(42 rows)

SELECT b.y, sum(a.y) FROM pagg_tab1 a RIGHT JOIN pagg_tab2 b ON a.x = b.y GROUP BY b.y ORDER BY 1 NULLS LAST;
 y  | sum  
----+------
  0 |  500
  3 |     
  6 | 1100
  9 |     
 12 |  700
 15 |     
 18 | 1300
 21 |     
 24 |  900
 27 |     
(10 rows)

EXPLAIN (verbose, COSTS OFF)
SELECT b.y, sum(a.y) FROM pagg_tab1 a RIGHT JOIN pagg_tab2 b ON a.x = b.y GROUP BY b.y ORDER BY 1 NULLS LAST;
                                                   QUERY PLAN                                                    
-----------------------------------------------------------------------------------------------------------------
 GroupAggregate
   Output: b.y, sum(a.y)
   Group Key: b.y
   ->  Sort
         Output: b.y, a.y
         Sort Key: b.y
         ->  Append
               ->  Nested Loop Left Join
                     Output: b.y, a.y
                     Join Filter: (a.x = b.y)
                     ->  Materialize
                           Output: b.y
                           ->  RemoteScan on public.pagg_tab2_p1 b
                                 Output: b.y
                                 Shard: 1        Remote SQL: select y from regression_$$_public.pagg_tab2_p1 
                     ->  Materialize
                           Output: a.y, a.x
                           ->  RemoteScan on public.pagg_tab1_p1 a
                                 Output: a.y, a.x
                                 Shard: 2        Remote SQL: select y, x from regression_$$_public.pagg_tab1_p1 
               ->  Nested Loop Left Join
                     Output: b_1.y, a_1.y
                     Join Filter: (a_1.x = b_1.y)
                     ->  Materialize
                           Output: b_1.y
                           ->  RemoteScan on public.pagg_tab2_p2 b_1
                                 Output: b_1.y
                                 Shard: 2        Remote SQL: select y from regression_$$_public.pagg_tab2_p2 
                     ->  Materialize
                           Output: a_1.y, a_1.x
                           ->  RemoteScan on public.pagg_tab1_p2 a_1
                                 Output: a_1.y, a_1.x
                                 Shard: 2        Remote SQL: select y, x from regression_$$_public.pagg_tab1_p2 
               ->  Nested Loop Left Join
                     Output: b_2.y, a_2.y
                     Join Filter: (a_2.x = b_2.y)
                     ->  RemoteScan on public.pagg_tab2_p3 b_2
                           Output: b_2.y
                           Shard: 1      Remote SQL: select y from regression_$$_public.pagg_tab2_p3 
                     ->  RemoteScan on public.pagg_tab1_p3 a_2
                           Output: a_2.y, a_2.x
                           Shard: 2      Remote SQL: select y, x from regression_$$_public.pagg_tab1_p3 
(42 rows)

SELECT t1.a, t1.c, t2.b, t2.c FROM prt1 t1 RIGHT JOIN prt2 t2 ON t1.a = t2.b WHERE t2.a = 0 ORDER BY t1.a, t2.b;
  a  |  c   |  b  |  c   
-----+------+-----+------
   0 | 0000 |   0 | 0000
 150 | 0150 | 150 | 0150
 300 | 0300 | 300 | 0300
 450 | 0450 | 450 | 0450
     |      |  75 | 0075
     |      | 225 | 0225
     |      | 375 | 0375
     |      | 525 | 0525
(8 rows)

EXPLAIN (verbose, COSTS OFF)
SELECT t1.a, t1.c, t2.b, t2.c FROM prt1 t1 RIGHT JOIN prt2 t2 ON t1.a = t2.b WHERE t2.a = 0 ORDER BY t1.a, t2.b;
                                                    QUERY PLAN                                                    
------------------------------------------------------------------------------------------------------------------
 Sort
   Output: t1.a, t1.c, t2.b, t2.c
   Sort Key: t1.a, t2.b
   ->  Append
         ->  Nested Loop Left Join
               Output: t1.a, t1.c, t2.b, t2.c
               Join Filter: (t1.a = t2.b)
               ->  Materialize
                     Output: t2.b, t2.c
                     ->  RemoteScan on public.prt2_p1 t2
                           Output: t2.b, t2.c
                           Filter: (t2.b = 0)
                           Shard: 1      Remote SQL: select b, c from regression_$$_public.prt2_p1  where (a = 0)
               ->  Materialize
                     Output: t1.a, t1.c
                     ->  RemoteScan on public.prt1_p1 t1
                           Output: t1.a, t1.c
                           Shard: 2      Remote SQL: select a, c from regression_$$_public.prt1_p1 
         ->  Nested Loop Left Join
               Output: t1_1.a, t1_1.c, t2_1.b, t2_1.c
               Join Filter: (t1_1.a = t2_1.b)
               ->  Materialize
                     Output: t2_1.b, t2_1.c
                     ->  RemoteScan on public.prt2_p2 t2_1
                           Output: t2_1.b, t2_1.c
                           Filter: (t2_1.b = 0)
                           Shard: 2      Remote SQL: select b, c from regression_$$_public.prt2_p2  where (a = 0)
               ->  Materialize
                     Output: t1_1.a, t1_1.c
                     ->  RemoteScan on public.prt1_p2 t1_1
                           Output: t1_1.a, t1_1.c
                           Shard: 2      Remote SQL: select a, c from regression_$$_public.prt1_p2 
         ->  Nested Loop Left Join
               Output: t1_2.a, t1_2.c, t2_2.b, t2_2.c
               Join Filter: (t1_2.a = t2_2.b)
               ->  RemoteScan on public.prt2_p3 t2_2
                     Output: t2_2.b, t2_2.c
                     Filter: (t2_2.b = 0)
                     Shard: 1    Remote SQL: select b, c from regression_$$_public.prt2_p3  where (a = 0)
               ->  RemoteScan on public.prt1_p3 t1_2
                     Output: t1_2.a, t1_2.c
                     Shard: 2    Remote SQL: select a, c from regression_$$_public.prt1_p3 
(42 rows)

SELECT sum(t1.a), avg(t1.a), sum(t1.b), avg(t1.b) FROM prt1 t1 WHERE NOT EXISTS (SELECT 1 FROM prt2 t2 WHERE t1.a = t2.b);
  sum  |         avg          | sum  |         avg         
-------+----------------------+------+---------------------
 60000 | 300.0000000000000000 | 2400 | 12.0000000000000000
(1 row)

EXPLAIN (verbose, COSTS OFF)
SELECT sum(t1.a), avg(t1.a), sum(t1.b), avg(t1.b) FROM prt1 t1 WHERE NOT EXISTS (SELECT 1 FROM prt2 t2 WHERE t1.a = t2.b);
                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 Aggregate
   Output: sum(t1.a), avg(t1.a), sum(t1.b), avg(t1.b)
   ->  Append
         ->  Nested Loop Anti Join
               Output: t1.a, t1.b
               Join Filter: (t1.a = t2.b)
               ->  Materialize
                     Output: t1.a, t1.b
                     ->  RemoteScan on public.prt1_p1 t1
                           Output: t1.a, t1.b
                           Shard: 2      Remote SQL: select a, b from regression_$$_public.prt1_p1 
               ->  Materialize
                     Output: t2.b
                     ->  RemoteScan on public.prt2_p1 t2
                           Output: t2.b
                           Shard: 1      Remote SQL: select b from regression_$$_public.prt2_p1 
         ->  Nested Loop Anti Join
               Output: t1_1.a, t1_1.b
               Join Filter: (t1_1.a = t2_1.b)
               ->  Materialize
                     Output: t1_1.a, t1_1.b
                     ->  RemoteScan on public.prt1_p2 t1_1
                           Output: t1_1.a, t1_1.b
                           Shard: 2      Remote SQL: select a, b from regression_$$_public.prt1_p2 
               ->  Materialize
                     Output: t2_1.b
                     ->  RemoteScan on public.prt2_p2 t2_1
                           Output: t2_1.b
                           Shard: 2      Remote SQL: select b from regression_$$_public.prt2_p2 
         ->  Nested Loop Anti Join
               Output: t1_2.a, t1_2.b
               Join Filter: (t1_2.a = t2_2.b)
               ->  RemoteScan on public.prt1_p3 t1_2
                     Output: t1_2.a, t1_2.b
                     Shard: 2    Remote SQL: select a, b from regression_$$_public.prt1_p3 
               ->  RemoteScan on public.prt2_p3 t2_2
                     Output: t2_2.b
                     Shard: 1    Remote SQL: select b from regression_$$_public.prt2_p3 
(38 rows)

SELECT t1.a, t1.c, t2.b, t2.c FROM prt1_e t1, prt2_e t2 WHERE (t1.a + t1.b)/2 = (t2.b + t2.a)/2 AND t1.c = 0 ORDER BY t1.a, t2.b;
  a  | c |  b  | c 
-----+---+-----+---
   0 | 0 |   0 | 0
 150 | 0 | 150 | 0
 300 | 0 | 300 | 0
 450 | 0 | 450 | 0
(4 rows)

EXPLAIN (verbose, COSTS OFF)
SELECT t1.a, t1.c, t2.b, t2.c FROM prt1_e t1, prt2_e t2 WHERE (t1.a + t1.b)/2 = (t2.b + t2.a)/2 AND t1.c = 0 ORDER BY t1.a, t2.b;
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Sort
   Output: t1.a, t1.c, t2.b, t2.c
   Sort Key: t1.a, t2.b
   ->  Append
         ->  Nested Loop
               Output: t1.a, t1.c, t2.b, t2.c
               Join Filter: (((t1.a + t1.b) / 2) = ((t2.b + t2.a) / 2))
               ->  Materialize
                     Output: t1.a, t1.c, t1.b
                     ->  RemoteScan on public.prt1_e_p1 t1
                           Output: t1.a, t1.c, t1.b
                           Filter: (t1.b = 0)
                           Shard: 1      Remote SQL: select a, c, b from regression_$$_public.prt1_e_p1  where (c = 0)
               ->  Materialize
                     Output: t2.b, t2.c, t2.a
                     ->  RemoteScan on public.prt2_e_p1 t2
                           Output: t2.b, t2.c, t2.a
                           Shard: 2      Remote SQL: select b, c, a from regression_$$_public.prt2_e_p1 
         ->  Nested Loop
               Output: t1_1.a, t1_1.c, t2_1.b, t2_1.c
               Join Filter: (((t1_1.a + t1_1.b) / 2) = ((t2_1.b + t2_1.a) / 2))
               ->  Materialize
                     Output: t1_1.a, t1_1.c, t1_1.b
                     ->  RemoteScan on public.prt1_e_p2 t1_1
                           Output: t1_1.a, t1_1.c, t1_1.b
                           Filter: (t1_1.b = 0)
                           Shard: 1      Remote SQL: select a, c, b from regression_$$_public.prt1_e_p2  where (c = 0)
               ->  Materialize
                     Output: t2_1.b, t2_1.c, t2_1.a
                     ->  RemoteScan on public.prt2_e_p2 t2_1
                           Output: t2_1.b, t2_1.c, t2_1.a
                           Shard: 1      Remote SQL: select b, c, a from regression_$$_public.prt2_e_p2 
         ->  Nested Loop
               Output: t1_2.a, t1_2.c, t2_2.b, t2_2.c
               Join Filter: (((t1_2.a + t1_2.b) / 2) = ((t2_2.b + t2_2.a) / 2))
               ->  Materialize
                     Output: t1_2.a, t1_2.c, t1_2.b
                     ->  RemoteScan on public.prt1_e_p3 t1_2
                           Output: t1_2.a, t1_2.c, t1_2.b
                           Filter: (t1_2.b = 0)
                           Shard: 2      Remote SQL: select a, c, b from regression_$$_public.prt1_e_p3  where (c = 0)
               ->  Materialize
                     Output: t2_2.b, t2_2.c, t2_2.a
                     ->  RemoteScan on public.prt2_e_p3 t2_2
                           Output: t2_2.b, t2_2.c, t2_2.a
                           Shard: 2      Remote SQL: select b, c, a from regression_$$_public.prt2_e_p3 
(46 rows)

SELECT t1.a, t1.c, t2.b, t2.c, t3.a + t3.b, t3.c FROM (prt1 t1 LEFT JOIN prt2 t2 ON t1.a = t2.b) LEFT JOIN prt1_e t3 ON (t1.a = (t3.a + t3.b)/2) WHERE t1.b = 0 ORDER BY t1.a, t2.b, t3.a + t3.b;
  a  |  c   |  b  |  c   | ?column? | c 
-----+------+-----+------+----------+---
   0 | 0000 |   0 | 0000 |        0 | 0
  50 | 0050 |     |      |      100 | 0
 100 | 0100 |     |      |      200 | 0
 150 | 0150 | 150 | 0150 |      300 | 0
 200 | 0200 |     |      |      400 | 0
 250 | 0250 |     |      |      500 | 0
 300 | 0300 | 300 | 0300 |      600 | 0
 350 | 0350 |     |      |      700 | 0
 400 | 0400 |     |      |      800 | 0
 450 | 0450 | 450 | 0450 |      900 | 0
 500 | 0500 |     |      |     1000 | 0
 550 | 0550 |     |      |     1100 | 0
(12 rows)

EXPLAIN (verbose, COSTS OFF)
SELECT t1.a, t1.c, t2.b, t2.c, t3.a + t3.b, t3.c FROM (prt1 t1 LEFT JOIN prt2 t2 ON t1.a = t2.b) LEFT JOIN prt1_e t3 ON (t1.a = (t3.a + t3.b)/2) WHERE t1.b = 0 ORDER BY t1.a, t2.b, t3.a + t3.b;
                                                        QUERY PLAN                                                        
--------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: t1.a, t1.c, t2.b, t2.c, ((t3.a + t3.b)), t3.c
   Sort Key: t1.a, t2.b, ((t3.a + t3.b))
   ->  Append
         ->  Nested Loop Left Join
               Output: t1.a, t1.c, t2.b, t2.c, (t3.a + t3.b), t3.c
               Join Filter: (t1.a = ((t3.a + t3.b) / 2))
               ->  Nested Loop Left Join
                     Output: t1.a, t1.c, t2.b, t2.c
                     Join Filter: (t1.a = t2.b)
                     ->  Materialize
                           Output: t1.a, t1.c
                           ->  RemoteScan on public.prt1_p1 t1
                                 Output: t1.a, t1.c
                                 Filter: (t1.c = 0)
                                 Shard: 2        Remote SQL: select a, c from regression_$$_public.prt1_p1  where (b = 0)
                     ->  Materialize
                           Output: t2.b, t2.c
                           ->  RemoteScan on public.prt2_p1 t2
                                 Output: t2.b, t2.c
                                 Shard: 1        Remote SQL: select b, c from regression_$$_public.prt2_p1 
               ->  Materialize
                     Output: t3.a, t3.b, t3.c
                     ->  RemoteScan on public.prt1_e_p1 t3
                           Output: t3.a, t3.b, t3.c
                           Shard: 1      Remote SQL: select a, b, c from regression_$$_public.prt1_e_p1 
         ->  Nested Loop Left Join
               Output: t1_1.a, t1_1.c, t2_1.b, t2_1.c, (t3_1.a + t3_1.b), t3_1.c
               Join Filter: (t1_1.a = ((t3_1.a + t3_1.b) / 2))
               ->  Nested Loop Left Join
                     Output: t1_1.a, t1_1.c, t2_1.b, t2_1.c
                     Join Filter: (t1_1.a = t2_1.b)
                     ->  Materialize
                           Output: t1_1.a, t1_1.c
                           ->  RemoteScan on public.prt1_p2 t1_1
                                 Output: t1_1.a, t1_1.c
                                 Filter: (t1_1.c = 0)
                                 Shard: 2        Remote SQL: select a, c from regression_$$_public.prt1_p2  where (b = 0)
                     ->  Materialize
                           Output: t2_1.b, t2_1.c
                           ->  RemoteScan on public.prt2_p2 t2_1
                                 Output: t2_1.b, t2_1.c
                                 Shard: 2        Remote SQL: select b, c from regression_$$_public.prt2_p2 
               ->  Materialize
                     Output: t3_1.a, t3_1.b, t3_1.c
                     ->  RemoteScan on public.prt1_e_p2 t3_1
                           Output: t3_1.a, t3_1.b, t3_1.c
                           Shard: 1      Remote SQL: select a, b, c from regression_$$_public.prt1_e_p2 
         ->  Nested Loop Left Join
               Output: t1_2.a, t1_2.c, t2_2.b, t2_2.c, (t3_2.a + t3_2.b), t3_2.c
               Join Filter: (t1_2.a = ((t3_2.a + t3_2.b) / 2))
               ->  Nested Loop Left Join
                     Output: t1_2.a, t1_2.c, t2_2.b, t2_2.c
                     Join Filter: (t1_2.a = t2_2.b)
                     ->  Materialize
                           Output: t1_2.a, t1_2.c
                           ->  RemoteScan on public.prt1_p3 t1_2
                                 Output: t1_2.a, t1_2.c
                                 Filter: (t1_2.c = 0)
                                 Shard: 2        Remote SQL: select a, c from regression_$$_public.prt1_p3  where (b = 0)
                     ->  RemoteScan on public.prt2_p3 t2_2
                           Output: t2_2.b, t2_2.c
                           Shard: 1      Remote SQL: select b, c from regression_$$_public.prt2_p3 
               ->  Materialize
                     Output: t3_2.a, t3_2.b, t3_2.c
                     ->  RemoteScan on public.prt1_e_p3 t3_2
                           Output: t3_2.a, t3_2.b, t3_2.c
                           Shard: 2      Remote SQL: select a, b, c from regression_$$_public.prt1_e_p3 
(68 rows)

SELECT t1.a, t1.c, t2.b, t2.c, t3.a + t3.b, t3.c FROM (prt1 t1 LEFT JOIN prt2 t2 ON t1.a = t2.b) RIGHT JOIN prt1_e t3 ON (t1.a = (t3.a + t3.b)/2) WHERE t3.c = 0 ORDER BY t1.a, t2.b, t3.a + t3.b;
  a  |  c   |  b  |  c   | ?column? | c 
-----+------+-----+------+----------+---
   0 | 0000 |   0 | 0000 |        0 | 0
  50 | 0050 |     |      |      100 | 0
 100 | 0100 |     |      |      200 | 0
 150 | 0150 | 150 | 0150 |      300 | 0
 200 | 0200 |     |      |      400 | 0
 250 | 0250 |     |      |      500 | 0
 300 | 0300 | 300 | 0300 |      600 | 0
 350 | 0350 |     |      |      700 | 0
 400 | 0400 |     |      |      800 | 0
 450 | 0450 | 450 | 0450 |      900 | 0
 500 | 0500 |     |      |     1000 | 0
 550 | 0550 |     |      |     1100 | 0
(12 rows)

EXPLAIN (verbose, COSTS OFF)
SELECT t1.a, t1.c, t2.b, t2.c, t3.a + t3.b, t3.c FROM (prt1 t1 LEFT JOIN prt2 t2 ON t1.a = t2.b) RIGHT JOIN prt1_e t3 ON (t1.a = (t3.a + t3.b)/2) WHERE t3.c = 0 ORDER BY t1.a, t2.b, t3.a + t3.b;
                                                          QUERY PLAN                                                           
-------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: t1.a, t1.c, t2.b, t2.c, ((t3.a + t3.b)), t3.c
   Sort Key: t1.a, t2.b, ((t3.a + t3.b))
   ->  Append
         ->  Nested Loop Left Join
               Output: t1.a, t1.c, t2.b, t2.c, (t3.a + t3.b), t3.c
               Join Filter: (t1.a = t2.b)
               ->  Nested Loop Left Join
                     Output: t3.a, t3.b, t3.c, t1.a, t1.c
                     Join Filter: (t1.a = ((t3.a + t3.b) / 2))
                     ->  Materialize
                           Output: t3.a, t3.b, t3.c
                           ->  RemoteScan on public.prt1_e_p1 t3
                                 Output: t3.a, t3.b, t3.c
                                 Filter: (t3.c = 0)
                                 Shard: 1        Remote SQL: select a, b, c from regression_$$_public.prt1_e_p1  where (c = 0)
                     ->  Materialize
                           Output: t1.a, t1.c
                           ->  RemoteScan on public.prt1_p1 t1
                                 Output: t1.a, t1.c
                                 Shard: 2        Remote SQL: select a, c from regression_$$_public.prt1_p1 
               ->  Materialize
                     Output: t2.b, t2.c
                     ->  RemoteScan on public.prt2_p1 t2
                           Output: t2.b, t2.c
                           Shard: 1      Remote SQL: select b, c from regression_$$_public.prt2_p1 
         ->  Nested Loop Left Join
               Output: t1_1.a, t1_1.c, t2_1.b, t2_1.c, (t3_1.a + t3_1.b), t3_1.c
               Join Filter: (t1_1.a = t2_1.b)
               ->  Nested Loop Left Join
                     Output: t3_1.a, t3_1.b, t3_1.c, t1_1.a, t1_1.c
                     Join Filter: (t1_1.a = ((t3_1.a + t3_1.b) / 2))
                     ->  Materialize
                           Output: t3_1.a, t3_1.b, t3_1.c
                           ->  RemoteScan on public.prt1_e_p2 t3_1
                                 Output: t3_1.a, t3_1.b, t3_1.c
                                 Filter: (t3_1.c = 0)
                                 Shard: 1        Remote SQL: select a, b, c from regression_$$_public.prt1_e_p2  where (c = 0)
                     ->  Materialize
                           Output: t1_1.a, t1_1.c
                           ->  RemoteScan on public.prt1_p2 t1_1
                                 Output: t1_1.a, t1_1.c
                                 Shard: 2        Remote SQL: select a, c from regression_$$_public.prt1_p2 
               ->  Materialize
                     Output: t2_1.b, t2_1.c
                     ->  RemoteScan on public.prt2_p2 t2_1
                           Output: t2_1.b, t2_1.c
                           Shard: 2      Remote SQL: select b, c from regression_$$_public.prt2_p2 
         ->  Nested Loop Left Join
               Output: t1_2.a, t1_2.c, t2_2.b, t2_2.c, (t3_2.a + t3_2.b), t3_2.c
               Join Filter: (t1_2.a = t2_2.b)
               ->  Nested Loop Left Join
                     Output: t3_2.a, t3_2.b, t3_2.c, t1_2.a, t1_2.c
                     Join Filter: (t1_2.a = ((t3_2.a + t3_2.b) / 2))
                     ->  Materialize
                           Output: t3_2.a, t3_2.b, t3_2.c
                           ->  RemoteScan on public.prt1_e_p3 t3_2
                                 Output: t3_2.a, t3_2.b, t3_2.c
                                 Filter: (t3_2.c = 0)
                                 Shard: 2        Remote SQL: select a, b, c from regression_$$_public.prt1_e_p3  where (c = 0)
                     ->  Materialize
                           Output: t1_2.a, t1_2.c
                           ->  RemoteScan on public.prt1_p3 t1_2
                                 Output: t1_2.a, t1_2.c
                                 Shard: 2        Remote SQL: select a, c from regression_$$_public.prt1_p3 
               ->  RemoteScan on public.prt2_p3 t2_2
                     Output: t2_2.b, t2_2.c
                     Shard: 1    Remote SQL: select b, c from regression_$$_public.prt2_p3 
(68 rows)

SELECT t1.* FROM prt1 t1 WHERE t1.a IN (SELECT t1.b FROM prt2 t1, prt1_e t2 WHERE t1.a = 0 AND t1.b = (t2.a + t2.b)/2) AND t1.b = 0 ORDER BY t1.a;
  a  | b |  c   
-----+---+------
   0 | 0 | 0000
 150 | 0 | 0150
 300 | 0 | 0300
 450 | 0 | 0450
(4 rows)

EXPLAIN (verbose, COSTS OFF)
SELECT t1.* FROM prt1 t1 WHERE t1.a IN (SELECT t1.b FROM prt2 t1, prt1_e t2 WHERE t1.a = 0 AND t1.b = (t2.a + t2.b)/2) AND t1.b = 0 ORDER BY t1.a;
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Sort
   Output: t1.a, t1.b, t1.c
   Sort Key: t1.a
   ->  Append
         ->  Nested Loop Semi Join
               Output: t1.a, t1.b, t1.c
               Join Filter: (t1.a = t1_3.b)
               ->  Materialize
                     Output: t1.a, t1.b, t1.c
                     ->  RemoteScan on public.prt1_p1 t1
                           Output: t1.a, t1.b, t1.c
                           Filter: (t1.b = 0)
                           Shard: 2      Remote SQL: select a, b, c from regression_$$_public.prt1_p1  where (b = 0)
               ->  Nested Loop
                     Output: t1_3.b, t2.a, t2.b
                     Join Filter: (t1_3.b = ((t2.a + t2.b) / 2))
                     ->  Materialize
                           Output: t1_3.b
                           ->  RemoteScan on public.prt2_p1 t1_3
                                 Output: t1_3.b
                                 Filter: (t1_3.b = 0)
                                 Shard: 1        Remote SQL: select b from regression_$$_public.prt2_p1  where (a = 0)
                     ->  Materialize
                           Output: t2.a, t2.b
                           ->  RemoteScan on public.prt1_e_p1 t2
                                 Output: t2.a, t2.b
                                 Shard: 1        Remote SQL: select a, b from regression_$$_public.prt1_e_p1 
         ->  Nested Loop Semi Join
               Output: t1_1.a, t1_1.b, t1_1.c
               Join Filter: (t1_1.a = t1_4.b)
               ->  Materialize
                     Output: t1_1.a, t1_1.b, t1_1.c
                     ->  RemoteScan on public.prt1_p2 t1_1
                           Output: t1_1.a, t1_1.b, t1_1.c
                           Filter: (t1_1.b = 0)
                           Shard: 2      Remote SQL: select a, b, c from regression_$$_public.prt1_p2  where (b = 0)
               ->  Materialize
                     Output: t1_4.b, , 
                     ->  Nested Loop
                           Output: t1_4.b, t2_1.a, t2_1.b
                           Join Filter: (t1_4.b = ((t2_1.a + t2_1.b) / 2))
                           ->  RemoteScan on public.prt2_p2 t1_4
                                 Output: t1_4.b
                                 Filter: (t1_4.b = 0)
                                 Shard: 2        Remote SQL: select b from regression_$$_public.prt2_p2  where (a = 0)
                           ->  Materialize
                                 Output: t2_1.a, t2_1.b
                                 ->  RemoteScan on public.prt1_e_p2 t2_1
                                       Output: t2_1.a, t2_1.b
                                       Shard: 1  Remote SQL: select a, b from regression_$$_public.prt1_e_p2 
         ->  Nested Loop Semi Join
               Output: t1_2.a, t1_2.b, t1_2.c
               Join Filter: (t1_2.a = t1_5.b)
               ->  Materialize
                     Output: t1_2.a, t1_2.b, t1_2.c
                     ->  RemoteScan on public.prt1_p3 t1_2
                           Output: t1_2.a, t1_2.b, t1_2.c
                           Filter: (t1_2.b = 0)
                           Shard: 2      Remote SQL: select a, b, c from regression_$$_public.prt1_p3  where (b = 0)
               ->  Materialize
                     Output: t1_5.b, , 
                     ->  Nested Loop
                           Output: t1_5.b, t2_2.a, t2_2.b
                           Join Filter: (t1_5.b = ((t2_2.a + t2_2.b) / 2))
                           ->  RemoteScan on public.prt2_p3 t1_5
                                 Output: t1_5.b
                                 Filter: (t1_5.b = 0)
                                 Shard: 1        Remote SQL: select b from regression_$$_public.prt2_p3  where (a = 0)
                           ->  Materialize
                                 Output: t2_2.a, t2_2.b
                                 ->  RemoteScan on public.prt1_e_p3 t2_2
                                       Output: t2_2.a, t2_2.b
                                       Shard: 2  Remote SQL: select a, b from regression_$$_public.prt1_e_p3 
(73 rows)

set enable_hashjoin=true;
set enable_mergejoin=false;
set enable_nestloop=false;
SELECT t1.x, sum(t1.y), count(*) FROM pagg_tab1 t1, pagg_tab2 t2 WHERE t1.x = t2.y GROUP BY t1.x ORDER BY 1, 2, 3;
 x  | sum  | count 
----+------+-------
  0 |  500 |   100
  6 | 1100 |   100
 12 |  700 |   100
 18 | 1300 |   100
 24 |  900 |   100
(5 rows)

EXPLAIN (verbose, COSTS OFF)
SELECT t1.x, sum(t1.y), count(*) FROM pagg_tab1 t1, pagg_tab2 t2 WHERE t1.x = t2.y GROUP BY t1.x ORDER BY 1, 2, 3;
                                                   QUERY PLAN                                                    
-----------------------------------------------------------------------------------------------------------------
 Sort
   Output: t1.x, (sum(t1.y)), (count(*))
   Sort Key: t1.x, (sum(t1.y)), (count(*))
   ->  HashAggregate
         Output: t1.x, sum(t1.y), count(*)
         Group Key: t1.x
         ->  Append
               ->  Hash Join
                     Output: t1.x, t1.y
                     Hash Cond: (t1.x = t2.y)
                     ->  Materialize
                           Output: t1.x, t1.y
                           ->  RemoteScan on public.pagg_tab1_p1 t1
                                 Output: t1.x, t1.y
                                 Shard: 2        Remote SQL: select x, y from regression_$$_public.pagg_tab1_p1 
                     ->  Hash
                           Output: t2.y
                           ->  Materialize
                                 Output: t2.y
                                 ->  RemoteScan on public.pagg_tab2_p1 t2
                                       Output: t2.y
                                       Shard: 1  Remote SQL: select y from regression_$$_public.pagg_tab2_p1 
               ->  Hash Join
                     Output: t1_1.x, t1_1.y
                     Hash Cond: (t1_1.x = t2_1.y)
                     ->  Materialize
                           Output: t1_1.x, t1_1.y
                           ->  RemoteScan on public.pagg_tab1_p2 t1_1
                                 Output: t1_1.x, t1_1.y
                                 Shard: 2        Remote SQL: select x, y from regression_$$_public.pagg_tab1_p2 
                     ->  Hash
                           Output: t2_1.y
                           ->  Materialize
                                 Output: t2_1.y
                                 ->  RemoteScan on public.pagg_tab2_p2 t2_1
                                       Output: t2_1.y
                                       Shard: 2  Remote SQL: select y from regression_$$_public.pagg_tab2_p2 
               ->  Hash Join
                     Output: t1_2.x, t1_2.y
                     Hash Cond: (t1_2.x = t2_2.y)
                     ->  RemoteScan on public.pagg_tab1_p3 t1_2
                           Output: t1_2.x, t1_2.y
                           Shard: 2      Remote SQL: select x, y from regression_$$_public.pagg_tab1_p3 
                     ->  Hash
                           Output: t2_2.y
                           ->  RemoteScan on public.pagg_tab2_p3 t2_2
                                 Output: t2_2.y
                                 Shard: 1        Remote SQL: select y from regression_$$_public.pagg_tab2_p3 
(48 rows)

SELECT t1.y, sum(t1.x), count(*) FROM pagg_tab1 t1, pagg_tab2 t2 WHERE t1.x = t2.y GROUP BY t1.y HAVING avg(t1.x) > 10 ORDER BY 1, 2, 3;
 y  | sum  | count 
----+------+-------
  2 |  600 |    50
  4 | 1200 |    50
  8 |  900 |    50
 12 |  600 |    50
 14 | 1200 |    50
 18 |  900 |    50
(6 rows)

EXPLAIN (verbose, COSTS OFF)
SELECT t1.y, sum(t1.x), count(*) FROM pagg_tab1 t1, pagg_tab2 t2 WHERE t1.x = t2.y GROUP BY t1.y HAVING avg(t1.x) > 10 ORDER BY 1, 2, 3;
                                                   QUERY PLAN                                                    
-----------------------------------------------------------------------------------------------------------------
 Sort
   Output: t1.y, (sum(t1.x)), (count(*))
   Sort Key: t1.y, (sum(t1.x)), (count(*))
   ->  HashAggregate
         Output: t1.y, sum(t1.x), count(*)
         Group Key: t1.y
         Filter: (avg(t1.x) > '10'::numeric)
         ->  Append
               ->  Hash Join
                     Output: t1.y, t1.x
                     Hash Cond: (t1.x = t2.y)
                     ->  Materialize
                           Output: t1.y, t1.x
                           ->  RemoteScan on public.pagg_tab1_p1 t1
                                 Output: t1.y, t1.x
                                 Shard: 2        Remote SQL: select y, x from regression_$$_public.pagg_tab1_p1 
                     ->  Hash
                           Output: t2.y
                           ->  Materialize
                                 Output: t2.y
                                 ->  RemoteScan on public.pagg_tab2_p1 t2
                                       Output: t2.y
                                       Shard: 1  Remote SQL: select y from regression_$$_public.pagg_tab2_p1 
               ->  Hash Join
                     Output: t1_1.y, t1_1.x
                     Hash Cond: (t1_1.x = t2_1.y)
                     ->  Materialize
                           Output: t1_1.y, t1_1.x
                           ->  RemoteScan on public.pagg_tab1_p2 t1_1
                                 Output: t1_1.y, t1_1.x
                                 Shard: 2        Remote SQL: select y, x from regression_$$_public.pagg_tab1_p2 
                     ->  Hash
                           Output: t2_1.y
                           ->  Materialize
                                 Output: t2_1.y
                                 ->  RemoteScan on public.pagg_tab2_p2 t2_1
                                       Output: t2_1.y
                                       Shard: 2  Remote SQL: select y from regression_$$_public.pagg_tab2_p2 
               ->  Hash Join
                     Output: t1_2.y, t1_2.x
                     Hash Cond: (t1_2.x = t2_2.y)
                     ->  RemoteScan on public.pagg_tab1_p3 t1_2
                           Output: t1_2.y, t1_2.x
                           Shard: 2      Remote SQL: select y, x from regression_$$_public.pagg_tab1_p3 
                     ->  Hash
                           Output: t2_2.y
                           ->  RemoteScan on public.pagg_tab2_p3 t2_2
                                 Output: t2_2.y
                                 Shard: 1        Remote SQL: select y from regression_$$_public.pagg_tab2_p3 
(49 rows)

SELECT b.y, sum(a.y) FROM pagg_tab1 a LEFT JOIN pagg_tab2 b ON a.x = b.y GROUP BY b.y ORDER BY 1 NULLS LAST;
 y  | sum  
----+------
  0 |  500
  6 | 1100
 12 |  700
 18 | 1300
 24 |  900
    |  900
(6 rows)

EXPLAIN (verbose, COSTS OFF)
SELECT b.y, sum(a.y) FROM pagg_tab1 a LEFT JOIN pagg_tab2 b ON a.x = b.y GROUP BY b.y ORDER BY 1 NULLS LAST;
                                                   QUERY PLAN                                                    
-----------------------------------------------------------------------------------------------------------------
 GroupAggregate
   Output: b.y, sum(a.y)
   Group Key: b.y
   ->  Sort
         Output: b.y, a.y
         Sort Key: b.y
         ->  Append
               ->  Hash Left Join
                     Output: b.y, a.y
                     Hash Cond: (a.x = b.y)
                     ->  Materialize
                           Output: a.y, a.x
                           ->  RemoteScan on public.pagg_tab1_p1 a
                                 Output: a.y, a.x
                                 Shard: 2        Remote SQL: select y, x from regression_$$_public.pagg_tab1_p1 
                     ->  Hash
                           Output: b.y
                           ->  Materialize
                                 Output: b.y
                                 ->  RemoteScan on public.pagg_tab2_p1 b
                                       Output: b.y
                                       Shard: 1  Remote SQL: select y from regression_$$_public.pagg_tab2_p1 
               ->  Hash Left Join
                     Output: b_1.y, a_1.y
                     Hash Cond: (a_1.x = b_1.y)
                     ->  Materialize
                           Output: a_1.y, a_1.x
                           ->  RemoteScan on public.pagg_tab1_p2 a_1
                                 Output: a_1.y, a_1.x
                                 Shard: 2        Remote SQL: select y, x from regression_$$_public.pagg_tab1_p2 
                     ->  Hash
                           Output: b_1.y
                           ->  Materialize
                                 Output: b_1.y
                                 ->  RemoteScan on public.pagg_tab2_p2 b_1
                                       Output: b_1.y
                                       Shard: 2  Remote SQL: select y from regression_$$_public.pagg_tab2_p2 
               ->  Hash Left Join
                     Output: b_2.y, a_2.y
                     Hash Cond: (a_2.x = b_2.y)
                     ->  RemoteScan on public.pagg_tab1_p3 a_2
                           Output: a_2.y, a_2.x
                           Shard: 2      Remote SQL: select y, x from regression_$$_public.pagg_tab1_p3 
                     ->  Hash
                           Output: b_2.y
                           ->  RemoteScan on public.pagg_tab2_p3 b_2
                                 Output: b_2.y
                                 Shard: 1        Remote SQL: select y from regression_$$_public.pagg_tab2_p3 
(48 rows)

SELECT b.y, sum(a.y) FROM pagg_tab1 a RIGHT JOIN pagg_tab2 b ON a.x = b.y GROUP BY b.y ORDER BY 1 NULLS LAST;
 y  | sum  
----+------
  0 |  500
  3 |     
  6 | 1100
  9 |     
 12 |  700
 15 |     
 18 | 1300
 21 |     
 24 |  900
 27 |     
(10 rows)

EXPLAIN (verbose, COSTS OFF)
SELECT b.y, sum(a.y) FROM pagg_tab1 a RIGHT JOIN pagg_tab2 b ON a.x = b.y GROUP BY b.y ORDER BY 1 NULLS LAST;
                                                   QUERY PLAN                                                    
-----------------------------------------------------------------------------------------------------------------
 GroupAggregate
   Output: b.y, sum(a.y)
   Group Key: b.y
   ->  Sort
         Output: b.y, a.y
         Sort Key: b.y
         ->  Append
               ->  Hash Left Join
                     Output: b.y, a.y
                     Hash Cond: (b.y = a.x)
                     ->  Materialize
                           Output: b.y
                           ->  RemoteScan on public.pagg_tab2_p1 b
                                 Output: b.y
                                 Shard: 1        Remote SQL: select y from regression_$$_public.pagg_tab2_p1 
                     ->  Hash
                           Output: a.y, a.x
                           ->  Materialize
                                 Output: a.y, a.x
                                 ->  RemoteScan on public.pagg_tab1_p1 a
                                       Output: a.y, a.x
                                       Shard: 2  Remote SQL: select y, x from regression_$$_public.pagg_tab1_p1 
               ->  Hash Left Join
                     Output: b_1.y, a_1.y
                     Hash Cond: (b_1.y = a_1.x)
                     ->  Materialize
                           Output: b_1.y
                           ->  RemoteScan on public.pagg_tab2_p2 b_1
                                 Output: b_1.y
                                 Shard: 2        Remote SQL: select y from regression_$$_public.pagg_tab2_p2 
                     ->  Hash
                           Output: a_1.y, a_1.x
                           ->  Materialize
                                 Output: a_1.y, a_1.x
                                 ->  RemoteScan on public.pagg_tab1_p2 a_1
                                       Output: a_1.y, a_1.x
                                       Shard: 2  Remote SQL: select y, x from regression_$$_public.pagg_tab1_p2 
               ->  Hash Left Join
                     Output: b_2.y, a_2.y
                     Hash Cond: (b_2.y = a_2.x)
                     ->  RemoteScan on public.pagg_tab2_p3 b_2
                           Output: b_2.y
                           Shard: 1      Remote SQL: select y from regression_$$_public.pagg_tab2_p3 
                     ->  Hash
                           Output: a_2.y, a_2.x
                           ->  RemoteScan on public.pagg_tab1_p3 a_2
                                 Output: a_2.y, a_2.x
                                 Shard: 2        Remote SQL: select y, x from regression_$$_public.pagg_tab1_p3 
(48 rows)

SELECT t1.a, t1.c, t2.b, t2.c FROM prt1 t1 RIGHT JOIN prt2 t2 ON t1.a = t2.b WHERE t2.a = 0 ORDER BY t1.a, t2.b;
  a  |  c   |  b  |  c   
-----+------+-----+------
   0 | 0000 |   0 | 0000
 150 | 0150 | 150 | 0150
 300 | 0300 | 300 | 0300
 450 | 0450 | 450 | 0450
     |      |  75 | 0075
     |      | 225 | 0225
     |      | 375 | 0375
     |      | 525 | 0525
(8 rows)

EXPLAIN (verbose, COSTS OFF)
SELECT t1.a, t1.c, t2.b, t2.c FROM prt1 t1 RIGHT JOIN prt2 t2 ON t1.a = t2.b WHERE t2.a = 0 ORDER BY t1.a, t2.b;
                                                    QUERY PLAN                                                    
------------------------------------------------------------------------------------------------------------------
 Sort
   Output: t1.a, t1.c, t2.b, t2.c
   Sort Key: t1.a, t2.b
   ->  Append
         ->  Hash Left Join
               Output: t1.a, t1.c, t2.b, t2.c
               Hash Cond: (t2.b = t1.a)
               ->  Materialize
                     Output: t2.b, t2.c
                     ->  RemoteScan on public.prt2_p1 t2
                           Output: t2.b, t2.c
                           Filter: (t2.b = 0)
                           Shard: 1      Remote SQL: select b, c from regression_$$_public.prt2_p1  where (a = 0)
               ->  Hash
                     Output: t1.a, t1.c
                     ->  Materialize
                           Output: t1.a, t1.c
                           ->  RemoteScan on public.prt1_p1 t1
                                 Output: t1.a, t1.c
                                 Shard: 2        Remote SQL: select a, c from regression_$$_public.prt1_p1 
         ->  Hash Left Join
               Output: t1_1.a, t1_1.c, t2_1.b, t2_1.c
               Hash Cond: (t2_1.b = t1_1.a)
               ->  Materialize
                     Output: t2_1.b, t2_1.c
                     ->  RemoteScan on public.prt2_p2 t2_1
                           Output: t2_1.b, t2_1.c
                           Filter: (t2_1.b = 0)
                           Shard: 2      Remote SQL: select b, c from regression_$$_public.prt2_p2  where (a = 0)
               ->  Hash
                     Output: t1_1.a, t1_1.c
                     ->  Materialize
                           Output: t1_1.a, t1_1.c
                           ->  RemoteScan on public.prt1_p2 t1_1
                                 Output: t1_1.a, t1_1.c
                                 Shard: 2        Remote SQL: select a, c from regression_$$_public.prt1_p2 
         ->  Hash Left Join
               Output: t1_2.a, t1_2.c, t2_2.b, t2_2.c
               Hash Cond: (t2_2.b = t1_2.a)
               ->  RemoteScan on public.prt2_p3 t2_2
                     Output: t2_2.b, t2_2.c
                     Filter: (t2_2.b = 0)
                     Shard: 1    Remote SQL: select b, c from regression_$$_public.prt2_p3  where (a = 0)
               ->  Hash
                     Output: t1_2.a, t1_2.c
                     ->  RemoteScan on public.prt1_p3 t1_2
                           Output: t1_2.a, t1_2.c
                           Shard: 2      Remote SQL: select a, c from regression_$$_public.prt1_p3 
(48 rows)

SELECT sum(t1.a), avg(t1.a), sum(t1.b), avg(t1.b) FROM prt1 t1 WHERE NOT EXISTS (SELECT 1 FROM prt2 t2 WHERE t1.a = t2.b);
  sum  |         avg          | sum  |         avg         
-------+----------------------+------+---------------------
 60000 | 300.0000000000000000 | 2400 | 12.0000000000000000
(1 row)

EXPLAIN (verbose, COSTS OFF)
SELECT sum(t1.a), avg(t1.a), sum(t1.b), avg(t1.b) FROM prt1 t1 WHERE NOT EXISTS (SELECT 1 FROM prt2 t2 WHERE t1.a = t2.b);
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Aggregate
   Output: sum(t1.a), avg(t1.a), sum(t1.b), avg(t1.b)
   ->  Append
         ->  Hash Anti Join
               Output: t1.a, t1.b
               Hash Cond: (t1.a = t2.b)
               ->  Materialize
                     Output: t1.a, t1.b
                     ->  RemoteScan on public.prt1_p1 t1
                           Output: t1.a, t1.b
                           Shard: 2      Remote SQL: select a, b from regression_$$_public.prt1_p1 
               ->  Hash
                     Output: t2.b
                     ->  Materialize
                           Output: t2.b
                           ->  RemoteScan on public.prt2_p1 t2
                                 Output: t2.b
                                 Shard: 1        Remote SQL: select b from regression_$$_public.prt2_p1 
         ->  Hash Anti Join
               Output: t1_1.a, t1_1.b
               Hash Cond: (t1_1.a = t2_1.b)
               ->  Materialize
                     Output: t1_1.a, t1_1.b
                     ->  RemoteScan on public.prt1_p2 t1_1
                           Output: t1_1.a, t1_1.b
                           Shard: 2      Remote SQL: select a, b from regression_$$_public.prt1_p2 
               ->  Hash
                     Output: t2_1.b
                     ->  Materialize
                           Output: t2_1.b
                           ->  RemoteScan on public.prt2_p2 t2_1
                                 Output: t2_1.b
                                 Shard: 2        Remote SQL: select b from regression_$$_public.prt2_p2 
         ->  Hash Anti Join
               Output: t1_2.a, t1_2.b
               Hash Cond: (t1_2.a = t2_2.b)
               ->  RemoteScan on public.prt1_p3 t1_2
                     Output: t1_2.a, t1_2.b
                     Shard: 2    Remote SQL: select a, b from regression_$$_public.prt1_p3 
               ->  Hash
                     Output: t2_2.b
                     ->  RemoteScan on public.prt2_p3 t2_2
                           Output: t2_2.b
                           Shard: 1      Remote SQL: select b from regression_$$_public.prt2_p3 
(44 rows)

SELECT t1.a, t1.c, t2.b, t2.c FROM prt1_e t1, prt2_e t2 WHERE (t1.a + t1.b)/2 = (t2.b + t2.a)/2 AND t1.c = 0 ORDER BY t1.a, t2.b;
  a  | c |  b  | c 
-----+---+-----+---
   0 | 0 |   0 | 0
 150 | 0 | 150 | 0
 300 | 0 | 300 | 0
 450 | 0 | 450 | 0
(4 rows)

EXPLAIN (verbose, COSTS OFF)
SELECT t1.a, t1.c, t2.b, t2.c FROM prt1_e t1, prt2_e t2 WHERE (t1.a + t1.b)/2 = (t2.b + t2.a)/2 AND t1.c = 0 ORDER BY t1.a, t2.b;
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Sort
   Output: t1.a, t1.c, t2.b, t2.c
   Sort Key: t1.a, t2.b
   ->  Append
         ->  Hash Join
               Output: t1.a, t1.c, t2.b, t2.c
               Hash Cond: (((t1.a + t1.b) / 2) = ((t2.b + t2.a) / 2))
               ->  Materialize
                     Output: t1.a, t1.c, t1.b
                     ->  RemoteScan on public.prt1_e_p1 t1
                           Output: t1.a, t1.c, t1.b
                           Filter: (t1.b = 0)
                           Shard: 1      Remote SQL: select a, c, b from regression_$$_public.prt1_e_p1  where (c = 0)
               ->  Hash
                     Output: t2.b, t2.c, t2.a
                     ->  Materialize
                           Output: t2.b, t2.c, t2.a
                           ->  RemoteScan on public.prt2_e_p1 t2
                                 Output: t2.b, t2.c, t2.a
                                 Shard: 2        Remote SQL: select b, c, a from regression_$$_public.prt2_e_p1 
         ->  Hash Join
               Output: t1_1.a, t1_1.c, t2_1.b, t2_1.c
               Hash Cond: (((t1_1.a + t1_1.b) / 2) = ((t2_1.b + t2_1.a) / 2))
               ->  Materialize
                     Output: t1_1.a, t1_1.c, t1_1.b
                     ->  RemoteScan on public.prt1_e_p2 t1_1
                           Output: t1_1.a, t1_1.c, t1_1.b
                           Filter: (t1_1.b = 0)
                           Shard: 1      Remote SQL: select a, c, b from regression_$$_public.prt1_e_p2  where (c = 0)
               ->  Hash
                     Output: t2_1.b, t2_1.c, t2_1.a
                     ->  RemoteScan on public.prt2_e_p2 t2_1
                           Output: t2_1.b, t2_1.c, t2_1.a
                           Shard: 1      Remote SQL: select b, c, a from regression_$$_public.prt2_e_p2 
         ->  Hash Join
               Output: t1_2.a, t1_2.c, t2_2.b, t2_2.c
               Hash Cond: (((t1_2.a + t1_2.b) / 2) = ((t2_2.b + t2_2.a) / 2))
               ->  Materialize
                     Output: t1_2.a, t1_2.c, t1_2.b
                     ->  RemoteScan on public.prt1_e_p3 t1_2
                           Output: t1_2.a, t1_2.c, t1_2.b
                           Filter: (t1_2.b = 0)
                           Shard: 2      Remote SQL: select a, c, b from regression_$$_public.prt1_e_p3  where (c = 0)
               ->  Hash
                     Output: t2_2.b, t2_2.c, t2_2.a
                     ->  RemoteScan on public.prt2_e_p3 t2_2
                           Output: t2_2.b, t2_2.c, t2_2.a
                           Shard: 2      Remote SQL: select b, c, a from regression_$$_public.prt2_e_p3 
(48 rows)

SELECT t1.a, t1.c, t2.b, t2.c, t3.a + t3.b, t3.c FROM (prt1 t1 LEFT JOIN prt2 t2 ON t1.a = t2.b) LEFT JOIN prt1_e t3 ON (t1.a = (t3.a + t3.b)/2) WHERE t1.b = 0 ORDER BY t1.a, t2.b, t3.a + t3.b;
  a  |  c   |  b  |  c   | ?column? | c 
-----+------+-----+------+----------+---
   0 | 0000 |   0 | 0000 |        0 | 0
  50 | 0050 |     |      |      100 | 0
 100 | 0100 |     |      |      200 | 0
 150 | 0150 | 150 | 0150 |      300 | 0
 200 | 0200 |     |      |      400 | 0
 250 | 0250 |     |      |      500 | 0
 300 | 0300 | 300 | 0300 |      600 | 0
 350 | 0350 |     |      |      700 | 0
 400 | 0400 |     |      |      800 | 0
 450 | 0450 | 450 | 0450 |      900 | 0
 500 | 0500 |     |      |     1000 | 0
 550 | 0550 |     |      |     1100 | 0
(12 rows)

EXPLAIN (verbose, COSTS OFF)
SELECT t1.a, t1.c, t2.b, t2.c, t3.a + t3.b, t3.c FROM (prt1 t1 LEFT JOIN prt2 t2 ON t1.a = t2.b) LEFT JOIN prt1_e t3 ON (t1.a = (t3.a + t3.b)/2) WHERE t1.b = 0 ORDER BY t1.a, t2.b, t3.a + t3.b;
                                                        QUERY PLAN                                                        
--------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: t1.a, t1.c, t2.b, t2.c, ((t3.a + t3.b)), t3.c
   Sort Key: t1.a, t2.b, ((t3.a + t3.b))
   ->  Append
         ->  Hash Left Join
               Output: t1.a, t1.c, t2.b, t2.c, (t3.a + t3.b), t3.c
               Hash Cond: (t1.a = ((t3.a + t3.b) / 2))
               ->  Hash Left Join
                     Output: t1.a, t1.c, t2.b, t2.c
                     Hash Cond: (t1.a = t2.b)
                     ->  Materialize
                           Output: t1.a, t1.c
                           ->  RemoteScan on public.prt1_p1 t1
                                 Output: t1.a, t1.c
                                 Filter: (t1.c = 0)
                                 Shard: 2        Remote SQL: select a, c from regression_$$_public.prt1_p1  where (b = 0)
                     ->  Hash
                           Output: t2.b, t2.c
                           ->  Materialize
                                 Output: t2.b, t2.c
                                 ->  RemoteScan on public.prt2_p1 t2
                                       Output: t2.b, t2.c
                                       Shard: 1  Remote SQL: select b, c from regression_$$_public.prt2_p1 
               ->  Hash
                     Output: t3.a, t3.b, t3.c
                     ->  Materialize
                           Output: t3.a, t3.b, t3.c
                           ->  RemoteScan on public.prt1_e_p1 t3
                                 Output: t3.a, t3.b, t3.c
                                 Shard: 1        Remote SQL: select a, b, c from regression_$$_public.prt1_e_p1 
         ->  Hash Left Join
               Output: t1_1.a, t1_1.c, t2_1.b, t2_1.c, (t3_1.a + t3_1.b), t3_1.c
               Hash Cond: (t1_1.a = ((t3_1.a + t3_1.b) / 2))
               ->  Hash Left Join
                     Output: t1_1.a, t1_1.c, t2_1.b, t2_1.c
                     Hash Cond: (t1_1.a = t2_1.b)
                     ->  Materialize
                           Output: t1_1.a, t1_1.c
                           ->  RemoteScan on public.prt1_p2 t1_1
                                 Output: t1_1.a, t1_1.c
                                 Filter: (t1_1.c = 0)
                                 Shard: 2        Remote SQL: select a, c from regression_$$_public.prt1_p2  where (b = 0)
                     ->  Hash
                           Output: t2_1.b, t2_1.c
                           ->  Materialize
                                 Output: t2_1.b, t2_1.c
                                 ->  RemoteScan on public.prt2_p2 t2_1
                                       Output: t2_1.b, t2_1.c
                                       Shard: 2  Remote SQL: select b, c from regression_$$_public.prt2_p2 
               ->  Hash
                     Output: t3_1.a, t3_1.b, t3_1.c
                     ->  Materialize
                           Output: t3_1.a, t3_1.b, t3_1.c
                           ->  RemoteScan on public.prt1_e_p2 t3_1
                                 Output: t3_1.a, t3_1.b, t3_1.c
                                 Shard: 1        Remote SQL: select a, b, c from regression_$$_public.prt1_e_p2 
         ->  Hash Left Join
               Output: t1_2.a, t1_2.c, t2_2.b, t2_2.c, (t3_2.a + t3_2.b), t3_2.c
               Hash Cond: (t1_2.a = ((t3_2.a + t3_2.b) / 2))
               ->  Hash Left Join
                     Output: t1_2.a, t1_2.c, t2_2.b, t2_2.c
                     Hash Cond: (t1_2.a = t2_2.b)
                     ->  Materialize
                           Output: t1_2.a, t1_2.c
                           ->  RemoteScan on public.prt1_p3 t1_2
                                 Output: t1_2.a, t1_2.c
                                 Filter: (t1_2.c = 0)
                                 Shard: 2        Remote SQL: select a, c from regression_$$_public.prt1_p3  where (b = 0)
                     ->  Hash
                           Output: t2_2.b, t2_2.c
                           ->  RemoteScan on public.prt2_p3 t2_2
                                 Output: t2_2.b, t2_2.c
                                 Shard: 1        Remote SQL: select b, c from regression_$$_public.prt2_p3 
               ->  Hash
                     Output: t3_2.a, t3_2.b, t3_2.c
                     ->  RemoteScan on public.prt1_e_p3 t3_2
                           Output: t3_2.a, t3_2.b, t3_2.c
                           Shard: 2      Remote SQL: select a, b, c from regression_$$_public.prt1_e_p3 
(78 rows)

SELECT t1.a, t1.c, t2.b, t2.c, t3.a + t3.b, t3.c FROM (prt1 t1 LEFT JOIN prt2 t2 ON t1.a = t2.b) RIGHT JOIN prt1_e t3 ON (t1.a = (t3.a + t3.b)/2) WHERE t3.c = 0 ORDER BY t1.a, t2.b, t3.a + t3.b;
  a  |  c   |  b  |  c   | ?column? | c 
-----+------+-----+------+----------+---
   0 | 0000 |   0 | 0000 |        0 | 0
  50 | 0050 |     |      |      100 | 0
 100 | 0100 |     |      |      200 | 0
 150 | 0150 | 150 | 0150 |      300 | 0
 200 | 0200 |     |      |      400 | 0
 250 | 0250 |     |      |      500 | 0
 300 | 0300 | 300 | 0300 |      600 | 0
 350 | 0350 |     |      |      700 | 0
 400 | 0400 |     |      |      800 | 0
 450 | 0450 | 450 | 0450 |      900 | 0
 500 | 0500 |     |      |     1000 | 0
 550 | 0550 |     |      |     1100 | 0
(12 rows)

EXPLAIN (verbose, COSTS OFF)
SELECT t1.a, t1.c, t2.b, t2.c, t3.a + t3.b, t3.c FROM (prt1 t1 LEFT JOIN prt2 t2 ON t1.a = t2.b) RIGHT JOIN prt1_e t3 ON (t1.a = (t3.a + t3.b)/2) WHERE t3.c = 0 ORDER BY t1.a, t2.b, t3.a + t3.b;
                                                          QUERY PLAN                                                           
-------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: t1.a, t1.c, t2.b, t2.c, ((t3.a + t3.b)), t3.c
   Sort Key: t1.a, t2.b, ((t3.a + t3.b))
   ->  Append
         ->  Hash Left Join
               Output: t1.a, t1.c, t2.b, t2.c, (t3.a + t3.b), t3.c
               Hash Cond: (t1.a = t2.b)
               ->  Hash Left Join
                     Output: t3.a, t3.b, t3.c, t1.a, t1.c
                     Hash Cond: (((t3.a + t3.b) / 2) = t1.a)
                     ->  Materialize
                           Output: t3.a, t3.b, t3.c
                           ->  RemoteScan on public.prt1_e_p1 t3
                                 Output: t3.a, t3.b, t3.c
                                 Filter: (t3.c = 0)
                                 Shard: 1        Remote SQL: select a, b, c from regression_$$_public.prt1_e_p1  where (c = 0)
                     ->  Hash
                           Output: t1.a, t1.c
                           ->  Materialize
                                 Output: t1.a, t1.c
                                 ->  RemoteScan on public.prt1_p1 t1
                                       Output: t1.a, t1.c
                                       Shard: 2  Remote SQL: select a, c from regression_$$_public.prt1_p1 
               ->  Hash
                     Output: t2.b, t2.c
                     ->  Materialize
                           Output: t2.b, t2.c
                           ->  RemoteScan on public.prt2_p1 t2
                                 Output: t2.b, t2.c
                                 Shard: 1        Remote SQL: select b, c from regression_$$_public.prt2_p1 
         ->  Hash Left Join
               Output: t1_1.a, t1_1.c, t2_1.b, t2_1.c, (t3_1.a + t3_1.b), t3_1.c
               Hash Cond: (t1_1.a = t2_1.b)
               ->  Hash Left Join
                     Output: t3_1.a, t3_1.b, t3_1.c, t1_1.a, t1_1.c
                     Hash Cond: (((t3_1.a + t3_1.b) / 2) = t1_1.a)
                     ->  Materialize
                           Output: t3_1.a, t3_1.b, t3_1.c
                           ->  RemoteScan on public.prt1_e_p2 t3_1
                                 Output: t3_1.a, t3_1.b, t3_1.c
                                 Filter: (t3_1.c = 0)
                                 Shard: 1        Remote SQL: select a, b, c from regression_$$_public.prt1_e_p2  where (c = 0)
                     ->  Hash
                           Output: t1_1.a, t1_1.c
                           ->  Materialize
                                 Output: t1_1.a, t1_1.c
                                 ->  RemoteScan on public.prt1_p2 t1_1
                                       Output: t1_1.a, t1_1.c
                                       Shard: 2  Remote SQL: select a, c from regression_$$_public.prt1_p2 
               ->  Hash
                     Output: t2_1.b, t2_1.c
                     ->  Materialize
                           Output: t2_1.b, t2_1.c
                           ->  RemoteScan on public.prt2_p2 t2_1
                                 Output: t2_1.b, t2_1.c
                                 Shard: 2        Remote SQL: select b, c from regression_$$_public.prt2_p2 
         ->  Hash Left Join
               Output: t1_2.a, t1_2.c, t2_2.b, t2_2.c, (t3_2.a + t3_2.b), t3_2.c
               Hash Cond: (t1_2.a = t2_2.b)
               ->  Hash Left Join
                     Output: t3_2.a, t3_2.b, t3_2.c, t1_2.a, t1_2.c
                     Hash Cond: (((t3_2.a + t3_2.b) / 2) = t1_2.a)
                     ->  Materialize
                           Output: t3_2.a, t3_2.b, t3_2.c
                           ->  RemoteScan on public.prt1_e_p3 t3_2
                                 Output: t3_2.a, t3_2.b, t3_2.c
                                 Filter: (t3_2.c = 0)
                                 Shard: 2        Remote SQL: select a, b, c from regression_$$_public.prt1_e_p3  where (c = 0)
                     ->  Hash
                           Output: t1_2.a, t1_2.c
                           ->  RemoteScan on public.prt1_p3 t1_2
                                 Output: t1_2.a, t1_2.c
                                 Shard: 2        Remote SQL: select a, c from regression_$$_public.prt1_p3 
               ->  Hash
                     Output: t2_2.b, t2_2.c
                     ->  RemoteScan on public.prt2_p3 t2_2
                           Output: t2_2.b, t2_2.c
                           Shard: 1      Remote SQL: select b, c from regression_$$_public.prt2_p3 
(78 rows)

SELECT t1.* FROM prt1 t1 WHERE t1.a IN (SELECT t1.b FROM prt2 t1, prt1_e t2 WHERE t1.a = 0 AND t1.b = (t2.a + t2.b)/2) AND t1.b = 0 ORDER BY t1.a;
  a  | b |  c   
-----+---+------
   0 | 0 | 0000
 150 | 0 | 0150
 300 | 0 | 0300
 450 | 0 | 0450
(4 rows)

EXPLAIN (verbose, COSTS OFF)
SELECT t1.* FROM prt1 t1 WHERE t1.a IN (SELECT t1.b FROM prt2 t1, prt1_e t2 WHERE t1.a = 0 AND t1.b = (t2.a + t2.b)/2) AND t1.b = 0 ORDER BY t1.a;
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Sort
   Output: t1.a, t1.b, t1.c
   Sort Key: t1.a
   ->  Append
         ->  Hash Semi Join
               Output: t1.a, t1.b, t1.c
               Hash Cond: (t1.a = t1_3.b)
               ->  Materialize
                     Output: t1.a, t1.b, t1.c
                     ->  RemoteScan on public.prt1_p1 t1
                           Output: t1.a, t1.b, t1.c
                           Filter: (t1.b = 0)
                           Shard: 2      Remote SQL: select a, b, c from regression_$$_public.prt1_p1  where (b = 0)
               ->  Hash
                     Output: t1_3.b, t2.a, t2.b
                     ->  Hash Join
                           Output: t1_3.b, t2.a, t2.b
                           Hash Cond: (t1_3.b = ((t2.a + t2.b) / 2))
                           ->  Materialize
                                 Output: t1_3.b
                                 ->  RemoteScan on public.prt2_p1 t1_3
                                       Output: t1_3.b
                                       Filter: (t1_3.b = 0)
                                       Shard: 1  Remote SQL: select b from regression_$$_public.prt2_p1  where (a = 0)
                           ->  Hash
                                 Output: t2.a, t2.b
                                 ->  Materialize
                                       Output: t2.a, t2.b
                                       ->  RemoteScan on public.prt1_e_p1 t2
                                             Output: t2.a, t2.b
                                             Shard: 1    Remote SQL: select a, b from regression_$$_public.prt1_e_p1 
         ->  Hash Semi Join
               Output: t1_1.a, t1_1.b, t1_1.c
               Hash Cond: (t1_1.a = t1_4.b)
               ->  Materialize
                     Output: t1_1.a, t1_1.b, t1_1.c
                     ->  RemoteScan on public.prt1_p2 t1_1
                           Output: t1_1.a, t1_1.b, t1_1.c
                           Filter: (t1_1.b = 0)
                           Shard: 2      Remote SQL: select a, b, c from regression_$$_public.prt1_p2  where (b = 0)
               ->  Hash
                     Output: t1_4.b, t2_1.a, t2_1.b
                     ->  Hash Join
                           Output: t1_4.b, t2_1.a, t2_1.b
                           Hash Cond: (t1_4.b = ((t2_1.a + t2_1.b) / 2))
                           ->  Materialize
                                 Output: t1_4.b
                                 ->  RemoteScan on public.prt2_p2 t1_4
                                       Output: t1_4.b
                                       Filter: (t1_4.b = 0)
                                       Shard: 2  Remote SQL: select b from regression_$$_public.prt2_p2  where (a = 0)
                           ->  Hash
                                 Output: t2_1.a, t2_1.b
                                 ->  Materialize
                                       Output: t2_1.a, t2_1.b
                                       ->  RemoteScan on public.prt1_e_p2 t2_1
                                             Output: t2_1.a, t2_1.b
                                             Shard: 1    Remote SQL: select a, b from regression_$$_public.prt1_e_p2 
         ->  Hash Semi Join
               Output: t1_2.a, t1_2.b, t1_2.c
               Hash Cond: (t1_2.a = t1_5.b)
               ->  Materialize
                     Output: t1_2.a, t1_2.b, t1_2.c
                     ->  RemoteScan on public.prt1_p3 t1_2
                           Output: t1_2.a, t1_2.b, t1_2.c
                           Filter: (t1_2.b = 0)
                           Shard: 2      Remote SQL: select a, b, c from regression_$$_public.prt1_p3  where (b = 0)
               ->  Hash
                     Output: t1_5.b, t2_2.a, t2_2.b
                     ->  Hash Join
                           Output: t1_5.b, t2_2.a, t2_2.b
                           Hash Cond: (t1_5.b = ((t2_2.a + t2_2.b) / 2))
                           ->  RemoteScan on public.prt2_p3 t1_5
                                 Output: t1_5.b
                                 Filter: (t1_5.b = 0)
                                 Shard: 1        Remote SQL: select b from regression_$$_public.prt2_p3  where (a = 0)
                           ->  Hash
                                 Output: t2_2.a, t2_2.b
                                 ->  RemoteScan on public.prt1_e_p3 t2_2
                                       Output: t2_2.a, t2_2.b
                                       Shard: 2  Remote SQL: select a, b from regression_$$_public.prt1_e_p3 
(81 rows)

set enable_hashjoin=false;
set enable_mergejoin=true;
set enable_nestloop=false;
SELECT t1.x, sum(t1.y), count(*) FROM pagg_tab1 t1, pagg_tab2 t2 WHERE t1.x = t2.y GROUP BY t1.x ORDER BY 1, 2, 3;
 x  | sum  | count 
----+------+-------
  0 |  500 |   100
  6 | 1100 |   100
 12 |  700 |   100
 18 | 1300 |   100
 24 |  900 |   100
(5 rows)

EXPLAIN (verbose, COSTS OFF)
SELECT t1.x, sum(t1.y), count(*) FROM pagg_tab1 t1, pagg_tab2 t2 WHERE t1.x = t2.y GROUP BY t1.x ORDER BY 1, 2, 3;
                                                   QUERY PLAN                                                    
-----------------------------------------------------------------------------------------------------------------
 Sort
   Output: t1.x, (sum(t1.y)), (count(*))
   Sort Key: t1.x, (sum(t1.y)), (count(*))
   ->  HashAggregate
         Output: t1.x, sum(t1.y), count(*)
         Group Key: t1.x
         ->  Append
               ->  Merge Join
                     Output: t1.x, t1.y
                     Merge Cond: (t1.x = t2.y)
                     ->  Sort
                           Output: t1.x, t1.y
                           Sort Key: t1.x
                           ->  Materialize
                                 Output: t1.x, t1.y
                                 ->  RemoteScan on public.pagg_tab1_p1 t1
                                       Output: t1.x, t1.y
                                       Shard: 2  Remote SQL: select x, y from regression_$$_public.pagg_tab1_p1 
                     ->  Sort
                           Output: t2.y
                           Sort Key: t2.y
                           ->  Materialize
                                 Output: t2.y
                                 ->  RemoteScan on public.pagg_tab2_p1 t2
                                       Output: t2.y
                                       Shard: 1  Remote SQL: select y from regression_$$_public.pagg_tab2_p1 
               ->  Merge Join
                     Output: t1_1.x, t1_1.y
                     Merge Cond: (t1_1.x = t2_1.y)
                     ->  Sort
                           Output: t1_1.x, t1_1.y
                           Sort Key: t1_1.x
                           ->  Materialize
                                 Output: t1_1.x, t1_1.y
                                 ->  RemoteScan on public.pagg_tab1_p2 t1_1
                                       Output: t1_1.x, t1_1.y
                                       Shard: 2  Remote SQL: select x, y from regression_$$_public.pagg_tab1_p2 
                     ->  Sort
                           Output: t2_1.y
                           Sort Key: t2_1.y
                           ->  Materialize
                                 Output: t2_1.y
                                 ->  RemoteScan on public.pagg_tab2_p2 t2_1
                                       Output: t2_1.y
                                       Shard: 2  Remote SQL: select y from regression_$$_public.pagg_tab2_p2 
               ->  Merge Join
                     Output: t1_2.x, t1_2.y
                     Merge Cond: (t1_2.x = t2_2.y)
                     ->  Sort
                           Output: t1_2.x, t1_2.y
                           Sort Key: t1_2.x
                           ->  RemoteScan on public.pagg_tab1_p3 t1_2
                                 Output: t1_2.x, t1_2.y
                                 Shard: 2        Remote SQL: select x, y from regression_$$_public.pagg_tab1_p3 
                     ->  Sort
                           Output: t2_2.y
                           Sort Key: t2_2.y
                           ->  RemoteScan on public.pagg_tab2_p3 t2_2
                                 Output: t2_2.y
                                 Shard: 1        Remote SQL: select y from regression_$$_public.pagg_tab2_p3 
(60 rows)

SELECT t1.y, sum(t1.x), count(*) FROM pagg_tab1 t1, pagg_tab2 t2 WHERE t1.x = t2.y GROUP BY t1.y HAVING avg(t1.x) > 10 ORDER BY 1, 2, 3;
 y  | sum  | count 
----+------+-------
  2 |  600 |    50
  4 | 1200 |    50
  8 |  900 |    50
 12 |  600 |    50
 14 | 1200 |    50
 18 |  900 |    50
(6 rows)

EXPLAIN (verbose, COSTS OFF)
SELECT t1.y, sum(t1.x), count(*) FROM pagg_tab1 t1, pagg_tab2 t2 WHERE t1.x = t2.y GROUP BY t1.y HAVING avg(t1.x) > 10 ORDER BY 1, 2, 3;
                                                   QUERY PLAN                                                    
-----------------------------------------------------------------------------------------------------------------
 Sort
   Output: t1.y, (sum(t1.x)), (count(*))
   Sort Key: t1.y, (sum(t1.x)), (count(*))
   ->  HashAggregate
         Output: t1.y, sum(t1.x), count(*)
         Group Key: t1.y
         Filter: (avg(t1.x) > '10'::numeric)
         ->  Append
               ->  Merge Join
                     Output: t1.y, t1.x
                     Merge Cond: (t1.x = t2.y)
                     ->  Sort
                           Output: t1.y, t1.x
                           Sort Key: t1.x
                           ->  Materialize
                                 Output: t1.y, t1.x
                                 ->  RemoteScan on public.pagg_tab1_p1 t1
                                       Output: t1.y, t1.x
                                       Shard: 2  Remote SQL: select y, x from regression_$$_public.pagg_tab1_p1 
                     ->  Sort
                           Output: t2.y
                           Sort Key: t2.y
                           ->  Materialize
                                 Output: t2.y
                                 ->  RemoteScan on public.pagg_tab2_p1 t2
                                       Output: t2.y
                                       Shard: 1  Remote SQL: select y from regression_$$_public.pagg_tab2_p1 
               ->  Merge Join
                     Output: t1_1.y, t1_1.x
                     Merge Cond: (t1_1.x = t2_1.y)
                     ->  Sort
                           Output: t1_1.y, t1_1.x
                           Sort Key: t1_1.x
                           ->  Materialize
                                 Output: t1_1.y, t1_1.x
                                 ->  RemoteScan on public.pagg_tab1_p2 t1_1
                                       Output: t1_1.y, t1_1.x
                                       Shard: 2  Remote SQL: select y, x from regression_$$_public.pagg_tab1_p2 
                     ->  Sort
                           Output: t2_1.y
                           Sort Key: t2_1.y
                           ->  Materialize
                                 Output: t2_1.y
                                 ->  RemoteScan on public.pagg_tab2_p2 t2_1
                                       Output: t2_1.y
                                       Shard: 2  Remote SQL: select y from regression_$$_public.pagg_tab2_p2 
               ->  Merge Join
                     Output: t1_2.y, t1_2.x
                     Merge Cond: (t1_2.x = t2_2.y)
                     ->  Sort
                           Output: t1_2.y, t1_2.x
                           Sort Key: t1_2.x
                           ->  RemoteScan on public.pagg_tab1_p3 t1_2
                                 Output: t1_2.y, t1_2.x
                                 Shard: 2        Remote SQL: select y, x from regression_$$_public.pagg_tab1_p3 
                     ->  Sort
                           Output: t2_2.y
                           Sort Key: t2_2.y
                           ->  RemoteScan on public.pagg_tab2_p3 t2_2
                                 Output: t2_2.y
                                 Shard: 1        Remote SQL: select y from regression_$$_public.pagg_tab2_p3 
(61 rows)

SELECT b.y, sum(a.y) FROM pagg_tab1 a LEFT JOIN pagg_tab2 b ON a.x = b.y GROUP BY b.y ORDER BY 1 NULLS LAST;
 y  | sum  
----+------
  0 |  500
  6 | 1100
 12 |  700
 18 | 1300
 24 |  900
    |  900
(6 rows)

EXPLAIN (verbose, COSTS OFF)
SELECT b.y, sum(a.y) FROM pagg_tab1 a LEFT JOIN pagg_tab2 b ON a.x = b.y GROUP BY b.y ORDER BY 1 NULLS LAST;
                                                   QUERY PLAN                                                    
-----------------------------------------------------------------------------------------------------------------
 GroupAggregate
   Output: b.y, sum(a.y)
   Group Key: b.y
   ->  Sort
         Output: b.y, a.y
         Sort Key: b.y
         ->  Append
               ->  Merge Left Join
                     Output: b.y, a.y
                     Merge Cond: (a.x = b.y)
                     ->  Sort
                           Output: a.y, a.x
                           Sort Key: a.x
                           ->  Materialize
                                 Output: a.y, a.x
                                 ->  RemoteScan on public.pagg_tab1_p1 a
                                       Output: a.y, a.x
                                       Shard: 2  Remote SQL: select y, x from regression_$$_public.pagg_tab1_p1 
                     ->  Sort
                           Output: b.y
                           Sort Key: b.y
                           ->  Materialize
                                 Output: b.y
                                 ->  RemoteScan on public.pagg_tab2_p1 b
                                       Output: b.y
                                       Shard: 1  Remote SQL: select y from regression_$$_public.pagg_tab2_p1 
               ->  Merge Left Join
                     Output: b_1.y, a_1.y
                     Merge Cond: (a_1.x = b_1.y)
                     ->  Sort
                           Output: a_1.y, a_1.x
                           Sort Key: a_1.x
                           ->  Materialize
                                 Output: a_1.y, a_1.x
                                 ->  RemoteScan on public.pagg_tab1_p2 a_1
                                       Output: a_1.y, a_1.x
                                       Shard: 2  Remote SQL: select y, x from regression_$$_public.pagg_tab1_p2 
                     ->  Sort
                           Output: b_1.y
                           Sort Key: b_1.y
                           ->  Materialize
                                 Output: b_1.y
                                 ->  RemoteScan on public.pagg_tab2_p2 b_1
                                       Output: b_1.y
                                       Shard: 2  Remote SQL: select y from regression_$$_public.pagg_tab2_p2 
               ->  Merge Left Join
                     Output: b_2.y, a_2.y
                     Merge Cond: (a_2.x = b_2.y)
                     ->  Sort
                           Output: a_2.y, a_2.x
                           Sort Key: a_2.x
                           ->  RemoteScan on public.pagg_tab1_p3 a_2
                                 Output: a_2.y, a_2.x
                                 Shard: 2        Remote SQL: select y, x from regression_$$_public.pagg_tab1_p3 
                     ->  Sort
                           Output: b_2.y
                           Sort Key: b_2.y
                           ->  RemoteScan on public.pagg_tab2_p3 b_2
                                 Output: b_2.y
                                 Shard: 1        Remote SQL: select y from regression_$$_public.pagg_tab2_p3 
(60 rows)

SELECT b.y, sum(a.y) FROM pagg_tab1 a RIGHT JOIN pagg_tab2 b ON a.x = b.y GROUP BY b.y ORDER BY 1 NULLS LAST;
 y  | sum  
----+------
  0 |  500
  3 |     
  6 | 1100
  9 |     
 12 |  700
 15 |     
 18 | 1300
 21 |     
 24 |  900
 27 |     
(10 rows)

EXPLAIN (verbose, COSTS OFF)
SELECT b.y, sum(a.y) FROM pagg_tab1 a RIGHT JOIN pagg_tab2 b ON a.x = b.y GROUP BY b.y ORDER BY 1 NULLS LAST;
                                                   QUERY PLAN                                                    
-----------------------------------------------------------------------------------------------------------------
 GroupAggregate
   Output: b.y, sum(a.y)
   Group Key: b.y
   ->  Sort
         Output: b.y, a.y
         Sort Key: b.y
         ->  Append
               ->  Merge Left Join
                     Output: b.y, a.y
                     Merge Cond: (b.y = a.x)
                     ->  Sort
                           Output: b.y
                           Sort Key: b.y
                           ->  Materialize
                                 Output: b.y
                                 ->  RemoteScan on public.pagg_tab2_p1 b
                                       Output: b.y
                                       Shard: 1  Remote SQL: select y from regression_$$_public.pagg_tab2_p1 
                     ->  Sort
                           Output: a.y, a.x
                           Sort Key: a.x
                           ->  Materialize
                                 Output: a.y, a.x
                                 ->  RemoteScan on public.pagg_tab1_p1 a
                                       Output: a.y, a.x
                                       Shard: 2  Remote SQL: select y, x from regression_$$_public.pagg_tab1_p1 
               ->  Merge Left Join
                     Output: b_1.y, a_1.y
                     Merge Cond: (b_1.y = a_1.x)
                     ->  Sort
                           Output: b_1.y
                           Sort Key: b_1.y
                           ->  Materialize
                                 Output: b_1.y
                                 ->  RemoteScan on public.pagg_tab2_p2 b_1
                                       Output: b_1.y
                                       Shard: 2  Remote SQL: select y from regression_$$_public.pagg_tab2_p2 
                     ->  Sort
                           Output: a_1.y, a_1.x
                           Sort Key: a_1.x
                           ->  Materialize
                                 Output: a_1.y, a_1.x
                                 ->  RemoteScan on public.pagg_tab1_p2 a_1
                                       Output: a_1.y, a_1.x
                                       Shard: 2  Remote SQL: select y, x from regression_$$_public.pagg_tab1_p2 
               ->  Merge Left Join
                     Output: b_2.y, a_2.y
                     Merge Cond: (b_2.y = a_2.x)
                     ->  Sort
                           Output: b_2.y
                           Sort Key: b_2.y
                           ->  RemoteScan on public.pagg_tab2_p3 b_2
                                 Output: b_2.y
                                 Shard: 1        Remote SQL: select y from regression_$$_public.pagg_tab2_p3 
                     ->  Sort
                           Output: a_2.y, a_2.x
                           Sort Key: a_2.x
                           ->  RemoteScan on public.pagg_tab1_p3 a_2
                                 Output: a_2.y, a_2.x
                                 Shard: 2        Remote SQL: select y, x from regression_$$_public.pagg_tab1_p3 
(60 rows)

SELECT t1.a, t1.c, t2.b, t2.c FROM prt1 t1 RIGHT JOIN prt2 t2 ON t1.a = t2.b WHERE t2.a = 0 ORDER BY t1.a, t2.b;
  a  |  c   |  b  |  c   
-----+------+-----+------
   0 | 0000 |   0 | 0000
 150 | 0150 | 150 | 0150
 300 | 0300 | 300 | 0300
 450 | 0450 | 450 | 0450
     |      |  75 | 0075
     |      | 225 | 0225
     |      | 375 | 0375
     |      | 525 | 0525
(8 rows)

EXPLAIN (verbose, COSTS OFF)
SELECT t1.a, t1.c, t2.b, t2.c FROM prt1 t1 RIGHT JOIN prt2 t2 ON t1.a = t2.b WHERE t2.a = 0 ORDER BY t1.a, t2.b;
                                                        QUERY PLAN                                                        
--------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: t1.a, t1.c, t2.b, t2.c
   Sort Key: t1.a, t2.b
   ->  Append
         ->  Merge Left Join
               Output: t1.a, t1.c, t2.b, t2.c
               Merge Cond: (t2.b = t1.a)
               ->  Sort
                     Output: t2.b, t2.c
                     Sort Key: t2.b
                     ->  Materialize
                           Output: t2.b, t2.c
                           ->  RemoteScan on public.prt2_p1 t2
                                 Output: t2.b, t2.c
                                 Filter: (t2.b = 0)
                                 Shard: 1        Remote SQL: select b, c from regression_$$_public.prt2_p1  where (a = 0)
               ->  Sort
                     Output: t1.a, t1.c
                     Sort Key: t1.a
                     ->  Materialize
                           Output: t1.a, t1.c
                           ->  RemoteScan on public.prt1_p1 t1
                                 Output: t1.a, t1.c
                                 Shard: 2        Remote SQL: select a, c from regression_$$_public.prt1_p1 
         ->  Merge Left Join
               Output: t1_1.a, t1_1.c, t2_1.b, t2_1.c
               Merge Cond: (t2_1.b = t1_1.a)
               ->  Sort
                     Output: t2_1.b, t2_1.c
                     Sort Key: t2_1.b
                     ->  Materialize
                           Output: t2_1.b, t2_1.c
                           ->  RemoteScan on public.prt2_p2 t2_1
                                 Output: t2_1.b, t2_1.c
                                 Filter: (t2_1.b = 0)
                                 Shard: 2        Remote SQL: select b, c from regression_$$_public.prt2_p2  where (a = 0)
               ->  Sort
                     Output: t1_1.a, t1_1.c
                     Sort Key: t1_1.a
                     ->  Materialize
                           Output: t1_1.a, t1_1.c
                           ->  RemoteScan on public.prt1_p2 t1_1
                                 Output: t1_1.a, t1_1.c
                                 Shard: 2        Remote SQL: select a, c from regression_$$_public.prt1_p2 
         ->  Merge Left Join
               Output: t1_2.a, t1_2.c, t2_2.b, t2_2.c
               Merge Cond: (t2_2.b = t1_2.a)
               ->  Sort
                     Output: t2_2.b, t2_2.c
                     Sort Key: t2_2.b
                     ->  RemoteScan on public.prt2_p3 t2_2
                           Output: t2_2.b, t2_2.c
                           Filter: (t2_2.b = 0)
                           Shard: 1      Remote SQL: select b, c from regression_$$_public.prt2_p3  where (a = 0)
               ->  Sort
                     Output: t1_2.a, t1_2.c
                     Sort Key: t1_2.a
                     ->  RemoteScan on public.prt1_p3 t1_2
                           Output: t1_2.a, t1_2.c
                           Shard: 2      Remote SQL: select a, c from regression_$$_public.prt1_p3 
(60 rows)

SELECT sum(t1.a), avg(t1.a), sum(t1.b), avg(t1.b) FROM prt1 t1 WHERE NOT EXISTS (SELECT 1 FROM prt2 t2 WHERE t1.a = t2.b);
  sum  |         avg          | sum  |         avg         
-------+----------------------+------+---------------------
 60000 | 300.0000000000000000 | 2400 | 12.0000000000000000
(1 row)

EXPLAIN (verbose, COSTS OFF)
SELECT sum(t1.a), avg(t1.a), sum(t1.b), avg(t1.b) FROM prt1 t1 WHERE NOT EXISTS (SELECT 1 FROM prt2 t2 WHERE t1.a = t2.b);
                                                 QUERY PLAN                                                 
------------------------------------------------------------------------------------------------------------
 Aggregate
   Output: sum(t1.a), avg(t1.a), sum(t1.b), avg(t1.b)
   ->  Append
         ->  Merge Anti Join
               Output: t1.a, t1.b
               Merge Cond: (t1.a = t2.b)
               ->  Sort
                     Output: t1.a, t1.b
                     Sort Key: t1.a
                     ->  Materialize
                           Output: t1.a, t1.b
                           ->  RemoteScan on public.prt1_p1 t1
                                 Output: t1.a, t1.b
                                 Shard: 2        Remote SQL: select a, b from regression_$$_public.prt1_p1 
               ->  Sort
                     Output: t2.b
                     Sort Key: t2.b
                     ->  Materialize
                           Output: t2.b
                           ->  RemoteScan on public.prt2_p1 t2
                                 Output: t2.b
                                 Shard: 1        Remote SQL: select b from regression_$$_public.prt2_p1 
         ->  Merge Anti Join
               Output: t1_1.a, t1_1.b
               Merge Cond: (t1_1.a = t2_1.b)
               ->  Sort
                     Output: t1_1.a, t1_1.b
                     Sort Key: t1_1.a
                     ->  Materialize
                           Output: t1_1.a, t1_1.b
                           ->  RemoteScan on public.prt1_p2 t1_1
                                 Output: t1_1.a, t1_1.b
                                 Shard: 2        Remote SQL: select a, b from regression_$$_public.prt1_p2 
               ->  Sort
                     Output: t2_1.b
                     Sort Key: t2_1.b
                     ->  Materialize
                           Output: t2_1.b
                           ->  RemoteScan on public.prt2_p2 t2_1
                                 Output: t2_1.b
                                 Shard: 2        Remote SQL: select b from regression_$$_public.prt2_p2 
         ->  Merge Anti Join
               Output: t1_2.a, t1_2.b
               Merge Cond: (t1_2.a = t2_2.b)
               ->  Sort
                     Output: t1_2.a, t1_2.b
                     Sort Key: t1_2.a
                     ->  RemoteScan on public.prt1_p3 t1_2
                           Output: t1_2.a, t1_2.b
                           Shard: 2      Remote SQL: select a, b from regression_$$_public.prt1_p3 
               ->  Sort
                     Output: t2_2.b
                     Sort Key: t2_2.b
                     ->  RemoteScan on public.prt2_p3 t2_2
                           Output: t2_2.b
                           Shard: 1      Remote SQL: select b from regression_$$_public.prt2_p3 
(56 rows)

SELECT t1.a, t1.c, t2.b, t2.c FROM prt1_e t1, prt2_e t2 WHERE (t1.a + t1.b)/2 = (t2.b + t2.a)/2 AND t1.c = 0 ORDER BY t1.a, t2.b;
  a  | c |  b  | c 
-----+---+-----+---
   0 | 0 |   0 | 0
 150 | 0 | 150 | 0
 300 | 0 | 300 | 0
 450 | 0 | 450 | 0
(4 rows)

EXPLAIN (verbose, COSTS OFF)
SELECT t1.a, t1.c, t2.b, t2.c FROM prt1_e t1, prt2_e t2 WHERE (t1.a + t1.b)/2 = (t2.b + t2.a)/2 AND t1.c = 0 ORDER BY t1.a, t2.b;
                                                                   QUERY PLAN                                                                   
------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: t1.a, t1.c, t2.b, t2.c
   Sort Key: t1.a, t2.b
   ->  Append
         ->  Merge Join
               Output: t1.a, t1.c, t2.b, t2.c
               Merge Cond: (t1."((a + b) DIV 2)" = t2."((b + a) DIV 2)")
               ->  Sort
                     Output: t1.a, t1.c, t1.b, t1."((a + b) DIV 2)"
                     Sort Key: t1."((a + b) DIV 2)"
                     ->  Materialize
                           Output: t1.a, t1.c, t1.b, t1."((a + b) DIV 2)"
                           ->  RemoteScan on public.prt1_e_p1 t1
                                 Output: t1.a, t1.c, t1.b, t1."((a + b) DIV 2)"
                                 Filter: (t1.b = 0)
                                 Shard: 1        Remote SQL: select a, c, b, ((a + b) DIV 2) from regression_$$_public.prt1_e_p1  where (c = 0)
               ->  Sort
                     Output: t2.b, t2.c, t2.a, t2."((b + a) DIV 2)"
                     Sort Key: t2."((b + a) DIV 2)"
                     ->  Materialize
                           Output: t2.b, t2.c, t2.a, t2."((b + a) DIV 2)"
                           ->  RemoteScan on public.prt2_e_p1 t2
                                 Output: t2.b, t2.c, t2.a, t2."((b + a) DIV 2)"
                                 Shard: 2        Remote SQL: select b, c, a, ((b + a) DIV 2) from regression_$$_public.prt2_e_p1 
         ->  Merge Join
               Output: t1_1.a, t1_1.c, t2_1.b, t2_1.c
               Merge Cond: (t1_1."((a + b) DIV 2)" = t2_1."((b + a) DIV 2)")
               ->  Sort
                     Output: t1_1.a, t1_1.c, t1_1.b, t1_1."((a + b) DIV 2)"
                     Sort Key: t1_1."((a + b) DIV 2)"
                     ->  Materialize
                           Output: t1_1.a, t1_1.c, t1_1.b, t1_1."((a + b) DIV 2)"
                           ->  RemoteScan on public.prt1_e_p2 t1_1
                                 Output: t1_1.a, t1_1.c, t1_1.b, t1_1."((a + b) DIV 2)"
                                 Filter: (t1_1.b = 0)
                                 Shard: 1        Remote SQL: select a, c, b, ((a + b) DIV 2) from regression_$$_public.prt1_e_p2  where (c = 0)
               ->  Sort
                     Output: t2_1.b, t2_1.c, t2_1.a, t2_1."((b + a) DIV 2)"
                     Sort Key: t2_1."((b + a) DIV 2)"
                     ->  RemoteScan on public.prt2_e_p2 t2_1
                           Output: t2_1.b, t2_1.c, t2_1.a, t2_1."((b + a) DIV 2)"
                           Shard: 1      Remote SQL: select b, c, a, ((b + a) DIV 2) from regression_$$_public.prt2_e_p2 
         ->  Merge Join
               Output: t1_2.a, t1_2.c, t2_2.b, t2_2.c
               Merge Cond: (t1_2."((a + b) DIV 2)" = t2_2."((b + a) DIV 2)")
               ->  Sort
                     Output: t1_2.a, t1_2.c, t1_2.b, t1_2."((a + b) DIV 2)"
                     Sort Key: t1_2."((a + b) DIV 2)"
                     ->  Materialize
                           Output: t1_2.a, t1_2.c, t1_2.b, t1_2."((a + b) DIV 2)"
                           ->  RemoteScan on public.prt1_e_p3 t1_2
                                 Output: t1_2.a, t1_2.c, t1_2.b, t1_2."((a + b) DIV 2)"
                                 Filter: (t1_2.b = 0)
                                 Shard: 2        Remote SQL: select a, c, b, ((a + b) DIV 2) from regression_$$_public.prt1_e_p3  where (c = 0)
               ->  Sort
                     Output: t2_2.b, t2_2.c, t2_2.a, t2_2."((b + a) DIV 2)"
                     Sort Key: t2_2."((b + a) DIV 2)"
                     ->  RemoteScan on public.prt2_e_p3 t2_2
                           Output: t2_2.b, t2_2.c, t2_2.a, t2_2."((b + a) DIV 2)"
                           Shard: 2      Remote SQL: select b, c, a, ((b + a) DIV 2) from regression_$$_public.prt2_e_p3 
(60 rows)

SELECT t1.a, t1.c, t2.b, t2.c, t3.a + t3.b, t3.c FROM (prt1 t1 LEFT JOIN prt2 t2 ON t1.a = t2.b) LEFT JOIN prt1_e t3 ON (t1.a = (t3.a + t3.b)/2) WHERE t1.b = 0 ORDER BY t1.a, t2.b, t3.a + t3.b;
  a  |  c   |  b  |  c   | ?column? | c 
-----+------+-----+------+----------+---
   0 | 0000 |   0 | 0000 |        0 | 0
  50 | 0050 |     |      |      100 | 0
 100 | 0100 |     |      |      200 | 0
 150 | 0150 | 150 | 0150 |      300 | 0
 200 | 0200 |     |      |      400 | 0
 250 | 0250 |     |      |      500 | 0
 300 | 0300 | 300 | 0300 |      600 | 0
 350 | 0350 |     |      |      700 | 0
 400 | 0400 |     |      |      800 | 0
 450 | 0450 | 450 | 0450 |      900 | 0
 500 | 0500 |     |      |     1000 | 0
 550 | 0550 |     |      |     1100 | 0
(12 rows)

EXPLAIN (verbose, COSTS OFF)
SELECT t1.a, t1.c, t2.b, t2.c, t3.a + t3.b, t3.c FROM (prt1 t1 LEFT JOIN prt2 t2 ON t1.a = t2.b) LEFT JOIN prt1_e t3 ON (t1.a = (t3.a + t3.b)/2) WHERE t1.b = 0 ORDER BY t1.a, t2.b, t3.a + t3.b;
                                                            QUERY PLAN                                                            
----------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: t1.a, t1.c, t2.b, t2.c, ((t3.a + t3.b)), t3.c
   Sort Key: t1.a, t2.b, ((t3.a + t3.b))
   ->  Append
         ->  Merge Left Join
               Output: t1.a, t1.c, t2.b, t2.c, (t3.a + t3.b), t3.c
               Merge Cond: (t1.a = t3."((a + b) DIV 2)")
               ->  Merge Left Join
                     Output: t1.a, t1.c, t2.b, t2.c
                     Merge Cond: (t1.a = t2.b)
                     ->  Sort
                           Output: t1.a, t1.c
                           Sort Key: t1.a
                           ->  Materialize
                                 Output: t1.a, t1.c
                                 ->  RemoteScan on public.prt1_p1 t1
                                       Output: t1.a, t1.c
                                       Filter: (t1.c = 0)
                                       Shard: 2  Remote SQL: select a, c from regression_$$_public.prt1_p1  where (b = 0)
                     ->  Sort
                           Output: t2.b, t2.c
                           Sort Key: t2.b
                           ->  Materialize
                                 Output: t2.b, t2.c
                                 ->  RemoteScan on public.prt2_p1 t2
                                       Output: t2.b, t2.c
                                       Shard: 1  Remote SQL: select b, c from regression_$$_public.prt2_p1 
               ->  Sort
                     Output: t3.a, t3.b, t3.c, t3."((a + b) DIV 2)"
                     Sort Key: t3."((a + b) DIV 2)"
                     ->  Materialize
                           Output: t3.a, t3.b, t3.c, t3."((a + b) DIV 2)"
                           ->  RemoteScan on public.prt1_e_p1 t3
                                 Output: t3.a, t3.b, t3.c, t3."((a + b) DIV 2)"
                                 Shard: 1        Remote SQL: select a, b, c, ((a + b) DIV 2) from regression_$$_public.prt1_e_p1 
         ->  Merge Left Join
               Output: t1_1.a, t1_1.c, t2_1.b, t2_1.c, (t3_1.a + t3_1.b), t3_1.c
               Merge Cond: (t1_1.a = t3_1."((a + b) DIV 2)")
               ->  Merge Left Join
                     Output: t1_1.a, t1_1.c, t2_1.b, t2_1.c
                     Merge Cond: (t1_1.a = t2_1.b)
                     ->  Sort
                           Output: t1_1.a, t1_1.c
                           Sort Key: t1_1.a
                           ->  Materialize
                                 Output: t1_1.a, t1_1.c
                                 ->  RemoteScan on public.prt1_p2 t1_1
                                       Output: t1_1.a, t1_1.c
                                       Filter: (t1_1.c = 0)
                                       Shard: 2  Remote SQL: select a, c from regression_$$_public.prt1_p2  where (b = 0)
                     ->  Sort
                           Output: t2_1.b, t2_1.c
                           Sort Key: t2_1.b
                           ->  Materialize
                                 Output: t2_1.b, t2_1.c
                                 ->  RemoteScan on public.prt2_p2 t2_1
                                       Output: t2_1.b, t2_1.c
                                       Shard: 2  Remote SQL: select b, c from regression_$$_public.prt2_p2 
               ->  Sort
                     Output: t3_1.a, t3_1.b, t3_1.c, t3_1."((a + b) DIV 2)"
                     Sort Key: t3_1."((a + b) DIV 2)"
                     ->  Materialize
                           Output: t3_1.a, t3_1.b, t3_1.c, t3_1."((a + b) DIV 2)"
                           ->  RemoteScan on public.prt1_e_p2 t3_1
                                 Output: t3_1.a, t3_1.b, t3_1.c, t3_1."((a + b) DIV 2)"
                                 Shard: 1        Remote SQL: select a, b, c, ((a + b) DIV 2) from regression_$$_public.prt1_e_p2 
         ->  Merge Left Join
               Output: t1_2.a, t1_2.c, t2_2.b, t2_2.c, (t3_2.a + t3_2.b), t3_2.c
               Merge Cond: (t1_2.a = t3_2."((a + b) DIV 2)")
               ->  Merge Left Join
                     Output: t1_2.a, t1_2.c, t2_2.b, t2_2.c
                     Merge Cond: (t1_2.a = t2_2.b)
                     ->  Sort
                           Output: t1_2.a, t1_2.c
                           Sort Key: t1_2.a
                           ->  Materialize
                                 Output: t1_2.a, t1_2.c
                                 ->  RemoteScan on public.prt1_p3 t1_2
                                       Output: t1_2.a, t1_2.c
                                       Filter: (t1_2.c = 0)
                                       Shard: 2  Remote SQL: select a, c from regression_$$_public.prt1_p3  where (b = 0)
                     ->  Sort
                           Output: t2_2.b, t2_2.c
                           Sort Key: t2_2.b
                           ->  RemoteScan on public.prt2_p3 t2_2
                                 Output: t2_2.b, t2_2.c
                                 Shard: 1        Remote SQL: select b, c from regression_$$_public.prt2_p3 
               ->  Sort
                     Output: t3_2.a, t3_2.b, t3_2.c, t3_2."((a + b) DIV 2)"
                     Sort Key: t3_2."((a + b) DIV 2)"
                     ->  RemoteScan on public.prt1_e_p3 t3_2
                           Output: t3_2.a, t3_2.b, t3_2.c, t3_2."((a + b) DIV 2)"
                           Shard: 2      Remote SQL: select a, b, c, ((a + b) DIV 2) from regression_$$_public.prt1_e_p3 
(93 rows)

SELECT t1.a, t1.c, t2.b, t2.c, t3.a + t3.b, t3.c FROM (prt1 t1 LEFT JOIN prt2 t2 ON t1.a = t2.b) RIGHT JOIN prt1_e t3 ON (t1.a = (t3.a + t3.b)/2) WHERE t3.c = 0 ORDER BY t1.a, t2.b, t3.a + t3.b;
  a  |  c   |  b  |  c   | ?column? | c 
-----+------+-----+------+----------+---
   0 | 0000 |   0 | 0000 |        0 | 0
  50 | 0050 |     |      |      100 | 0
 100 | 0100 |     |      |      200 | 0
 150 | 0150 | 150 | 0150 |      300 | 0
 200 | 0200 |     |      |      400 | 0
 250 | 0250 |     |      |      500 | 0
 300 | 0300 | 300 | 0300 |      600 | 0
 350 | 0350 |     |      |      700 | 0
 400 | 0400 |     |      |      800 | 0
 450 | 0450 | 450 | 0450 |      900 | 0
 500 | 0500 |     |      |     1000 | 0
 550 | 0550 |     |      |     1100 | 0
(12 rows)

EXPLAIN (verbose, COSTS OFF)
SELECT t1.a, t1.c, t2.b, t2.c, t3.a + t3.b, t3.c FROM (prt1 t1 LEFT JOIN prt2 t2 ON t1.a = t2.b) RIGHT JOIN prt1_e t3 ON (t1.a = (t3.a + t3.b)/2) WHERE t3.c = 0 ORDER BY t1.a, t2.b, t3.a + t3.b;
                                                                   QUERY PLAN                                                                   
------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: t1.a, t1.c, t2.b, t2.c, ((t3.a + t3.b)), t3.c
   Sort Key: t1.a, t2.b, ((t3.a + t3.b))
   ->  Append
         ->  Merge Right Join
               Output: t1.a, t1.c, t2.b, t2.c, (t3.a + t3.b), t3.c
               Merge Cond: (t1.a = t3."((a + b) DIV 2)")
               ->  Merge Left Join
                     Output: t1.a, t1.c, t2.b, t2.c
                     Merge Cond: (t1.a = t2.b)
                     ->  Sort
                           Output: t1.a, t1.c
                           Sort Key: t1.a
                           ->  Materialize
                                 Output: t1.a, t1.c
                                 ->  RemoteScan on public.prt1_p1 t1
                                       Output: t1.a, t1.c
                                       Shard: 2  Remote SQL: select a, c from regression_$$_public.prt1_p1 
                     ->  Sort
                           Output: t2.b, t2.c
                           Sort Key: t2.b
                           ->  Materialize
                                 Output: t2.b, t2.c
                                 ->  RemoteScan on public.prt2_p1 t2
                                       Output: t2.b, t2.c
                                       Shard: 1  Remote SQL: select b, c from regression_$$_public.prt2_p1 
               ->  Sort
                     Output: t3.a, t3.b, t3.c, t3."((a + b) DIV 2)"
                     Sort Key: t3."((a + b) DIV 2)"
                     ->  Materialize
                           Output: t3.a, t3.b, t3.c, t3."((a + b) DIV 2)"
                           ->  RemoteScan on public.prt1_e_p1 t3
                                 Output: t3.a, t3.b, t3.c, t3."((a + b) DIV 2)"
                                 Filter: (t3.c = 0)
                                 Shard: 1        Remote SQL: select a, b, c, ((a + b) DIV 2) from regression_$$_public.prt1_e_p1  where (c = 0)
         ->  Merge Right Join
               Output: t1_1.a, t1_1.c, t2_1.b, t2_1.c, (t3_1.a + t3_1.b), t3_1.c
               Merge Cond: (t1_1.a = t3_1."((a + b) DIV 2)")
               ->  Merge Left Join
                     Output: t1_1.a, t1_1.c, t2_1.b, t2_1.c
                     Merge Cond: (t1_1.a = t2_1.b)
                     ->  Sort
                           Output: t1_1.a, t1_1.c
                           Sort Key: t1_1.a
                           ->  Materialize
                                 Output: t1_1.a, t1_1.c
                                 ->  RemoteScan on public.prt1_p2 t1_1
                                       Output: t1_1.a, t1_1.c
                                       Shard: 2  Remote SQL: select a, c from regression_$$_public.prt1_p2 
                     ->  Sort
                           Output: t2_1.b, t2_1.c
                           Sort Key: t2_1.b
                           ->  Materialize
                                 Output: t2_1.b, t2_1.c
                                 ->  RemoteScan on public.prt2_p2 t2_1
                                       Output: t2_1.b, t2_1.c
                                       Shard: 2  Remote SQL: select b, c from regression_$$_public.prt2_p2 
               ->  Sort
                     Output: t3_1.a, t3_1.b, t3_1.c, t3_1."((a + b) DIV 2)"
                     Sort Key: t3_1."((a + b) DIV 2)"
                     ->  Materialize
                           Output: t3_1.a, t3_1.b, t3_1.c, t3_1."((a + b) DIV 2)"
                           ->  RemoteScan on public.prt1_e_p2 t3_1
                                 Output: t3_1.a, t3_1.b, t3_1.c, t3_1."((a + b) DIV 2)"
                                 Filter: (t3_1.c = 0)
                                 Shard: 1        Remote SQL: select a, b, c, ((a + b) DIV 2) from regression_$$_public.prt1_e_p2  where (c = 0)
         ->  Merge Right Join
               Output: t1_2.a, t1_2.c, t2_2.b, t2_2.c, (t3_2.a + t3_2.b), t3_2.c
               Merge Cond: (t1_2.a = t3_2."((a + b) DIV 2)")
               ->  Merge Left Join
                     Output: t1_2.a, t1_2.c, t2_2.b, t2_2.c
                     Merge Cond: (t1_2.a = t2_2.b)
                     ->  Sort
                           Output: t1_2.a, t1_2.c
                           Sort Key: t1_2.a
                           ->  Materialize
                                 Output: t1_2.a, t1_2.c
                                 ->  RemoteScan on public.prt1_p3 t1_2
                                       Output: t1_2.a, t1_2.c
                                       Shard: 2  Remote SQL: select a, c from regression_$$_public.prt1_p3 
                     ->  Sort
                           Output: t2_2.b, t2_2.c
                           Sort Key: t2_2.b
                           ->  RemoteScan on public.prt2_p3 t2_2
                                 Output: t2_2.b, t2_2.c
                                 Shard: 1        Remote SQL: select b, c from regression_$$_public.prt2_p3 
               ->  Sort
                     Output: t3_2.a, t3_2.b, t3_2.c, t3_2."((a + b) DIV 2)"
                     Sort Key: t3_2."((a + b) DIV 2)"
                     ->  RemoteScan on public.prt1_e_p3 t3_2
                           Output: t3_2.a, t3_2.b, t3_2.c, t3_2."((a + b) DIV 2)"
                           Filter: (t3_2.c = 0)
                           Shard: 2      Remote SQL: select a, b, c, ((a + b) DIV 2) from regression_$$_public.prt1_e_p3  where (c = 0)
(93 rows)

SELECT t1.* FROM prt1 t1 WHERE t1.a IN (SELECT t1.b FROM prt2 t1, prt1_e t2 WHERE t1.a = 0 AND t1.b = (t2.a + t2.b)/2) AND t1.b = 0 ORDER BY t1.a;
  a  | b |  c   
-----+---+------
   0 | 0 | 0000
 150 | 0 | 0150
 300 | 0 | 0300
 450 | 0 | 0450
(4 rows)

EXPLAIN (verbose, COSTS OFF)
SELECT t1.* FROM prt1 t1 WHERE t1.a IN (SELECT t1.b FROM prt2 t1, prt1_e t2 WHERE t1.a = 0 AND t1.b = (t2.a + t2.b)/2) AND t1.b = 0 ORDER BY t1.a;
                                                          QUERY PLAN                                                           
-------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: t1.a, t1.b, t1.c
   Sort Key: t1.a
   ->  Append
         ->  Merge Semi Join
               Output: t1.a, t1.b, t1.c
               Merge Cond: (t1.a = t1_3.b)
               ->  Sort
                     Output: t1.a, t1.b, t1.c
                     Sort Key: t1.a
                     ->  Materialize
                           Output: t1.a, t1.b, t1.c
                           ->  RemoteScan on public.prt1_p1 t1
                                 Output: t1.a, t1.b, t1.c
                                 Filter: (t1.b = 0)
                                 Shard: 2        Remote SQL: select a, b, c from regression_$$_public.prt1_p1  where (b = 0)
               ->  Merge Join
                     Output: t1_3.b, t2.a, t2.b
                     Merge Cond: (t1_3.b = t2."((a + b) DIV 2)")
                     ->  Sort
                           Output: t1_3.b
                           Sort Key: t1_3.b
                           ->  Materialize
                                 Output: t1_3.b
                                 ->  RemoteScan on public.prt2_p1 t1_3
                                       Output: t1_3.b
                                       Filter: (t1_3.b = 0)
                                       Shard: 1  Remote SQL: select b from regression_$$_public.prt2_p1  where (a = 0)
                     ->  Sort
                           Output: t2.a, t2.b, t2."((a + b) DIV 2)"
                           Sort Key: t2."((a + b) DIV 2)"
                           ->  Materialize
                                 Output: t2.a, t2.b, t2."((a + b) DIV 2)"
                                 ->  RemoteScan on public.prt1_e_p1 t2
                                       Output: t2.a, t2.b, t2."((a + b) DIV 2)"
                                       Shard: 1  Remote SQL: select a, b, ((a + b) DIV 2) from regression_$$_public.prt1_e_p1 
         ->  Merge Semi Join
               Output: t1_1.a, t1_1.b, t1_1.c
               Merge Cond: (t1_1.a = t1_4.b)
               ->  Sort
                     Output: t1_1.a, t1_1.b, t1_1.c
                     Sort Key: t1_1.a
                     ->  Materialize
                           Output: t1_1.a, t1_1.b, t1_1.c
                           ->  RemoteScan on public.prt1_p2 t1_1
                                 Output: t1_1.a, t1_1.b, t1_1.c
                                 Filter: (t1_1.b = 0)
                                 Shard: 2        Remote SQL: select a, b, c from regression_$$_public.prt1_p2  where (b = 0)
               ->  Merge Join
                     Output: t1_4.b, t2_1.a, t2_1.b
                     Merge Cond: (t1_4.b = t2_1."((a + b) DIV 2)")
                     ->  Sort
                           Output: t1_4.b
                           Sort Key: t1_4.b
                           ->  Materialize
                                 Output: t1_4.b
                                 ->  RemoteScan on public.prt2_p2 t1_4
                                       Output: t1_4.b
                                       Filter: (t1_4.b = 0)
                                       Shard: 2  Remote SQL: select b from regression_$$_public.prt2_p2  where (a = 0)
                     ->  Sort
                           Output: t2_1.a, t2_1.b, t2_1."((a + b) DIV 2)"
                           Sort Key: t2_1."((a + b) DIV 2)"
                           ->  Materialize
                                 Output: t2_1.a, t2_1.b, t2_1."((a + b) DIV 2)"
                                 ->  RemoteScan on public.prt1_e_p2 t2_1
                                       Output: t2_1.a, t2_1.b, t2_1."((a + b) DIV 2)"
                                       Shard: 1  Remote SQL: select a, b, ((a + b) DIV 2) from regression_$$_public.prt1_e_p2 
         ->  Merge Semi Join
               Output: t1_2.a, t1_2.b, t1_2.c
               Merge Cond: (t1_2.a = t1_5.b)
               ->  Sort
                     Output: t1_2.a, t1_2.b, t1_2.c
                     Sort Key: t1_2.a
                     ->  Materialize
                           Output: t1_2.a, t1_2.b, t1_2.c
                           ->  RemoteScan on public.prt1_p3 t1_2
                                 Output: t1_2.a, t1_2.b, t1_2.c
                                 Filter: (t1_2.b = 0)
                                 Shard: 2        Remote SQL: select a, b, c from regression_$$_public.prt1_p3  where (b = 0)
               ->  Merge Join
                     Output: t1_5.b, t2_2.a, t2_2.b
                     Merge Cond: (t1_5.b = t2_2."((a + b) DIV 2)")
                     ->  Sort
                           Output: t1_5.b
                           Sort Key: t1_5.b
                           ->  RemoteScan on public.prt2_p3 t1_5
                                 Output: t1_5.b
                                 Filter: (t1_5.b = 0)
                                 Shard: 1        Remote SQL: select b from regression_$$_public.prt2_p3  where (a = 0)
                     ->  Sort
                           Output: t2_2.a, t2_2.b, t2_2."((a + b) DIV 2)"
                           Sort Key: t2_2."((a + b) DIV 2)"
                           ->  RemoteScan on public.prt1_e_p3 t2_2
                                 Output: t2_2.a, t2_2.b, t2_2."((a + b) DIV 2)"
                                 Shard: 2        Remote SQL: select a, b, ((a + b) DIV 2) from regression_$$_public.prt1_e_p3 
(96 rows)

