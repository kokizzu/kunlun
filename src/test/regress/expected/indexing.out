-- Creating an index on a partitioned table makes the partitions
-- automatically get the index
drop table if exists idxpart;
psql:sql/indexing.sql:3: NOTICE:  table "idxpart" does not exist, skipping
DROP TABLE
create table idxpart (a int, b int, c text) partition by range (a);
CREATE TABLE
create table idxpart1 partition of idxpart for values from (0) to (10);
CREATE TABLE
create table idxpart2 partition of idxpart for values from (10) to (100)
	partition by range (b);
CREATE TABLE
create table idxpart21 partition of idxpart2 for values from (0) to (100);
CREATE TABLE
create index on idxpart (a);
CREATE INDEX
select relname, relkind, inhparent::regclass
    from pg_class left join pg_index ix on (indexrelid = oid)
	left join pg_inherits on (ix.indexrelid = inhrelid)
	where relname like 'idxpart%' order by relname;
     relname     | relkind |   inhparent    
-----------------+---------+----------------
 idxpart         | p       | 
 idxpart1        | r       | 
 idxpart1_a_idx  | i       | idxpart_a_idx
 idxpart2        | p       | 
 idxpart21       | r       | 
 idxpart21_a_idx | i       | idxpart2_a_idx
 idxpart2_a_idx  | I       | idxpart_a_idx
 idxpart_a_idx   | I       | 
(8 rows)

drop table idxpart;
DROP TABLE
-- Some unsupported features
create table idxpart (a int, b int, c text) partition by range (a);
CREATE TABLE
create table idxpart1 partition of idxpart for values from (0) to (10);
CREATE TABLE
create index concurrently on idxpart (a);
psql:sql/indexing.sql:19: ERROR:  cannot create index on partitioned table "idxpart" concurrently
drop table idxpart;
DROP TABLE
-- Verify bugfix with query on indexed partitioned table with no partitions
-- https://postgr.es/m/20180124162006.pmapfiznhgngwtjf@alvherre.pgsql
CREATE TABLE idxpart (col1 INT) PARTITION BY RANGE (col1);
CREATE TABLE
CREATE INDEX ON idxpart (col1);
CREATE INDEX
CREATE TABLE idxpart_two (col2 INT);
CREATE TABLE
SELECT col2 FROM idxpart_two fk LEFT OUTER JOIN idxpart pk ON (col1 = col2);
 col2 
------
(0 rows)

DROP table idxpart;
DROP TABLE
drop table idxpart_two;
DROP TABLE
-- Verify bugfix with index rewrite on ALTER TABLE / SET DATA TYPE
-- https://postgr.es/m/CAKcux6mxNCGsgATwf5CGMF8g4WSupCXicCVMeKUTuWbyxHOMsQ@mail.gmail.com
CREATE TABLE idxpart (a INT, b varchar(50), c INT) PARTITION BY RANGE(a);
CREATE TABLE
CREATE TABLE idxpart1 PARTITION OF idxpart FOR VALUES FROM (MINVALUE) TO (MAXVALUE);
CREATE TABLE
CREATE INDEX partidx_abc_idx ON idxpart (a, b, c);
CREATE INDEX
INSERT INTO idxpart (a, b, c) SELECT i, i, i FROM generate_series(1, 50) i;
INSERT 0 50
ALTER TABLE idxpart ALTER COLUMN c TYPE numeric;
ALTER TABLE
DROP TABLE idxpart;
DROP TABLE
-- If a table without index is attached as partition to a table with
-- an index, the index is automatically created
create table idxpart (a int, b int, c varchar(50)) partition by range (a);
CREATE TABLE
create index idxparti on idxpart (a);
CREATE INDEX
create index idxparti2 on idxpart (b, c);
CREATE INDEX
create table idxpart1 partition of idxpart for values from (0) to (10);;
CREATE TABLE
\d idxpart1
                     Table "public.idxpart1"
 Column |         Type          | Collation | Nullable | Default 
--------+-----------------------+-----------+----------+---------
 a      | integer               |           |          | 
 b      | integer               |           |          | 
 c      | character varying(50) |           |          | 
Partition of: idxpart FOR VALUES FROM (0) TO (10)
Indexes:
    "idxpart1_a_idx" btree (a NULLS FIRST)
    "idxpart1_b_c_idx" btree (b NULLS FIRST, c NULLS FIRST)

\d idxpart1
                     Table "public.idxpart1"
 Column |         Type          | Collation | Nullable | Default 
--------+-----------------------+-----------+----------+---------
 a      | integer               |           |          | 
 b      | integer               |           |          | 
 c      | character varying(50) |           |          | 
Partition of: idxpart FOR VALUES FROM (0) TO (10)
Indexes:
    "idxpart1_a_idx" btree (a NULLS FIRST)
    "idxpart1_b_c_idx" btree (b NULLS FIRST, c NULLS FIRST)

\d+ idxpart1_a_idx
                 Index "public.idxpart1_a_idx"
 Column |  Type   | Key? | Definition | Storage | Stats target 
--------+---------+------+------------+---------+--------------
 a      | integer | yes  | a          | plain   | 
Partition of: idxparti 
No partition constraint
btree, for table "public.idxpart1"

\d+ idxpart1_b_c_idx
                       Index "public.idxpart1_b_c_idx"
 Column |         Type          | Key? | Definition | Storage  | Stats target 
--------+-----------------------+------+------------+----------+--------------
 b      | integer               | yes  | b          | plain    | 
 c      | character varying(50) | yes  | c          | extended | 
Partition of: idxparti2 
No partition constraint
btree, for table "public.idxpart1"

drop table idxpart;
DROP TABLE
-- If a partition already has an index, don't create a duplicative one
create table idxpart (a int, b int) partition by range (a, b);
CREATE TABLE
create table idxpart1 partition of idxpart for values from (0, 0) to (10, 10);
CREATE TABLE
create index on idxpart1 (a, b);
CREATE INDEX
create index on idxpart (a, b);
CREATE INDEX
\d idxpart1
              Table "public.idxpart1"
 Column |  Type   | Collation | Nullable | Default 
--------+---------+-----------+----------+---------
 a      | integer |           |          | 
 b      | integer |           |          | 
Partition of: idxpart FOR VALUES FROM (0, 0) TO (10, 10)
Indexes:
    "idxpart1_a_b_idx" btree (a NULLS FIRST, b NULLS FIRST)
Statistics objects:
    "public"."idxpart1_a_b_idx_pfx_2" () ON a, b FROM idxpart1

select relname, relkind, inhparent::regclass
    from pg_class left join pg_index ix on (indexrelid = oid)
	left join pg_inherits on (ix.indexrelid = inhrelid)
	where relname like 'idxpart%' order by relname;
     relname      | relkind |    inhparent    
------------------+---------+-----------------
 idxpart          | p       | 
 idxpart1         | r       | 
 idxpart1_a_b_idx | i       | idxpart_a_b_idx
 idxpart_a_b_idx  | I       | 
(4 rows)

drop table idxpart;
DROP TABLE
-- DROP behavior for partitioned indexes
create table idxpart (a int) partition by range (a);
CREATE TABLE
create index on idxpart (a);
CREATE INDEX
create table idxpart1 partition of idxpart for values from (0) to (10);
CREATE TABLE
drop index idxpart1_a_idx;	-- no way
psql:sql/indexing.sql:68: ERROR:  cannot drop index idxpart1_a_idx because index idxpart_a_idx requires it
HINT:  You can drop index idxpart_a_idx instead.
drop index idxpart_a_idx;	-- both indexes go away
DROP INDEX
select relname, relkind from pg_class
  where relname like 'idxpart%' order by relname;
 relname  | relkind 
----------+---------
 idxpart  | p
 idxpart1 | r
(2 rows)

create index on idxpart (a);
CREATE INDEX
drop table idxpart1;		-- the index on partition goes away too
DROP TABLE
select relname, relkind from pg_class
  where relname like 'idxpart%' order by relname;
    relname    | relkind 
---------------+---------
 idxpart       | p
 idxpart_a_idx | I
(2 rows)

drop table idxpart;
DROP TABLE
-- ALTER INDEX .. ATTACH, error cases
create table idxpart (a int, b int) partition by range (a, b);
CREATE TABLE
create table idxpart1 partition of idxpart for values from (0, 0) to (10, 10);
CREATE TABLE
create index idxpart_a_b_idx on only idxpart (a, b);
CREATE INDEX
create index idxpart1_a_b_idx on idxpart1 (a, b);
CREATE INDEX
create index idxpart1_tst1 on idxpart1 (b, a);
CREATE INDEX
create index idxpart1_tst2 on idxpart1 using hash (a);
CREATE INDEX
drop table idxpart;
DROP TABLE
-- make sure everything's gone
select indexrelid::regclass, indrelid::regclass
  from pg_index where indexrelid::regclass::text like 'idxpart%';
 indexrelid | indrelid 
------------+----------
(0 rows)

-- Don't auto-attach incompatible indexes
create table idxpart (a int, b int) partition by range (a);
CREATE TABLE
create table idxpart1 partition of idxpart for values from (0) to (1000);
CREATE TABLE
create index on idxpart1 using hash (a);
CREATE INDEX
--create index on idxpart1 (a, a);
create index on idxpart (a);
CREATE INDEX
\d idxpart1
              Table "public.idxpart1"
 Column |  Type   | Collation | Nullable | Default 
--------+---------+-----------+----------+---------
 a      | integer |           |          | 
 b      | integer |           |          | 
Partition of: idxpart FOR VALUES FROM (0) TO (1000)
Indexes:
    "idxpart1_a_idx" hash (a)
    "idxpart1_a_idx1" btree (a NULLS FIRST)

drop table idxpart;
DROP TABLE
-- If CREATE INDEX ONLY, don't create indexes on partitions; and existing
-- indexes on partitions don't change parent.  ALTER INDEX ATTACH can change
-- the parent after the fact.
create table idxpart (a int) partition by range (a);
CREATE TABLE
create table idxpart1 partition of idxpart for values from (0) to (100);
CREATE TABLE
create table idxpart2 partition of idxpart for values from (100) to (1000)
  partition by range (a);
CREATE TABLE
create table idxpart21 partition of idxpart2 for values from (100) to (200);
CREATE TABLE
create table idxpart22 partition of idxpart2 for values from (200) to (300);
CREATE TABLE
create index on idxpart22 (a);
CREATE INDEX
create index on only idxpart2 (a);
CREATE INDEX
create index on idxpart (a);
CREATE INDEX
-- Here we expect that idxpart1 and idxpart2 have a new index, but idxpart21
-- does not; also, idxpart22 is not attached.
\d idxpart1
              Table "public.idxpart1"
 Column |  Type   | Collation | Nullable | Default 
--------+---------+-----------+----------+---------
 a      | integer |           |          | 
Partition of: idxpart FOR VALUES FROM (0) TO (100)
Indexes:
    "idxpart1_a_idx" btree (a NULLS FIRST)

\d idxpart2
        Partitioned table "public.idxpart2"
 Column |  Type   | Collation | Nullable | Default 
--------+---------+-----------+----------+---------
 a      | integer |           |          | 
Partition of: idxpart FOR VALUES FROM (100) TO (1000)
Partition key: RANGE (a)
Indexes:
    "idxpart2_a_idx" btree (a) INVALID
Number of partitions: 2 (Use \d+ to list them.)

\d idxpart21
             Table "public.idxpart21"
 Column |  Type   | Collation | Nullable | Default 
--------+---------+-----------+----------+---------
 a      | integer |           |          | 
Partition of: idxpart2 FOR VALUES FROM (100) TO (200)

select indexrelid::regclass, indrelid::regclass, inhparent::regclass
  from pg_index idx left join pg_inherits inh on (idx.indexrelid = inh.inhrelid)
where indexrelid::regclass::text like 'idxpart%'
  order by indexrelid::regclass::text collate "C";
   indexrelid    | indrelid  |   inhparent   
-----------------+-----------+---------------
 idxpart1_a_idx  | idxpart1  | idxpart_a_idx
 idxpart22_a_idx | idxpart22 | 
 idxpart2_a_idx  | idxpart2  | idxpart_a_idx
 idxpart_a_idx   | idxpart   | 
(4 rows)

select indexrelid::regclass, indrelid::regclass, inhparent::regclass
  from pg_index idx left join pg_inherits inh on (idx.indexrelid = inh.inhrelid)
where indexrelid::regclass::text like 'idxpart%'
  order by indexrelid::regclass::text collate "C";
   indexrelid    | indrelid  |   inhparent   
-----------------+-----------+---------------
 idxpart1_a_idx  | idxpart1  | idxpart_a_idx
 idxpart22_a_idx | idxpart22 | 
 idxpart2_a_idx  | idxpart2  | idxpart_a_idx
 idxpart_a_idx   | idxpart   | 
(4 rows)

-- attaching idxpart22 is not enough to set idxpart22_a_idx valid ...
\d idxpart2
        Partitioned table "public.idxpart2"
 Column |  Type   | Collation | Nullable | Default 
--------+---------+-----------+----------+---------
 a      | integer |           |          | 
Partition of: idxpart FOR VALUES FROM (100) TO (1000)
Partition key: RANGE (a)
Indexes:
    "idxpart2_a_idx" btree (a) INVALID
Number of partitions: 2 (Use \d+ to list them.)

-- ... but this one is.
create index on idxpart21 (a);
CREATE INDEX
\d idxpart2
        Partitioned table "public.idxpart2"
 Column |  Type   | Collation | Nullable | Default 
--------+---------+-----------+----------+---------
 a      | integer |           |          | 
Partition of: idxpart FOR VALUES FROM (100) TO (1000)
Partition key: RANGE (a)
Indexes:
    "idxpart2_a_idx" btree (a) INVALID
Number of partitions: 2 (Use \d+ to list them.)

drop table idxpart;
DROP TABLE
-- When a table is attached a partition and it already has an index, a
-- duplicate index should not get created, but rather the index becomes
-- attached to the parent's index.
create table idxpart (a int, b int, c varchar(50)) partition by range (a);
CREATE TABLE
create index idxparti on idxpart (a);
CREATE INDEX
create index idxparti2 on idxpart (b, c);
CREATE INDEX
create table idxpart1 partition of idxpart for values from (0) to (10);
CREATE TABLE
\d idxpart1
                     Table "public.idxpart1"
 Column |         Type          | Collation | Nullable | Default 
--------+-----------------------+-----------+----------+---------
 a      | integer               |           |          | 
 b      | integer               |           |          | 
 c      | character varying(50) |           |          | 
Partition of: idxpart FOR VALUES FROM (0) TO (10)
Indexes:
    "idxpart1_a_idx" btree (a NULLS FIRST)
    "idxpart1_b_c_idx" btree (b NULLS FIRST, c NULLS FIRST)

select relname, relkind, inhparent::regclass
    from pg_class left join pg_index ix on (indexrelid = oid)
	left join pg_inherits on (ix.indexrelid = inhrelid)
	where relname like 'idxpart%' order by relname;
     relname      | relkind | inhparent 
------------------+---------+-----------
 idxpart          | p       | 
 idxpart1         | r       | 
 idxpart1_a_idx   | i       | idxparti
 idxpart1_b_c_idx | i       | idxparti2
 idxparti         | I       | 
 idxparti2        | I       | 
(6 rows)

drop table idxpart;
DROP TABLE
-- Verify that attaching an invalid index does not mark the parent index valid.
-- On the other hand, attaching a valid index marks not only its direct
-- ancestor valid, but also any indirect ancestor that was only missing the one
-- that was just made valid
create table idxpart (a int, b int) partition by range (a);
CREATE TABLE
create table idxpart1 partition of idxpart for values from (1) to (1000) partition by range (a);
CREATE TABLE
create table idxpart11 partition of idxpart1 for values from (1) to (100);
CREATE TABLE
create index on only idxpart1 (a);
CREATE INDEX
create index on only idxpart (a);
CREATE INDEX
-- this results in two invalid indexes:
select relname, indisvalid from pg_class join pg_index on indexrelid = oid
   where relname like 'idxpart%' order by relname;
    relname     | indisvalid 
----------------+------------
 idxpart1_a_idx | f
 idxpart_a_idx  | f
(2 rows)

-- idxpart1_a_idx is not valid, so idxpart_a_idx should not become valid:
select relname, indisvalid from pg_class join pg_index on indexrelid = oid
   where relname like 'idxpart%' order by relname;
    relname     | indisvalid 
----------------+------------
 idxpart1_a_idx | f
 idxpart_a_idx  | f
(2 rows)

-- after creating and attaching this, both idxpart1_a_idx and idxpart_a_idx
-- should become valid
create index on idxpart11 (a);
CREATE INDEX
select relname, indisvalid from pg_class join pg_index on indexrelid = oid
   where relname like 'idxpart%' order by relname;
     relname     | indisvalid 
-----------------+------------
 idxpart11_a_idx | t
 idxpart1_a_idx  | f
 idxpart_a_idx   | f
(3 rows)

drop table idxpart;
DROP TABLE
-- verify dependency handling during ALTER TABLE DETACH PARTITION
create table idxpart (a int) partition by range (a);
CREATE TABLE
create table idxpart1 partition of idxpart for values from (0000) to (1000);
CREATE TABLE
create index on idxpart1 (a);
CREATE INDEX
create index on idxpart (a);
CREATE INDEX
create table idxpart2 partition of idxpart for values from (1000) to (2000);
CREATE TABLE
create table idxpart3 partition of idxpart for values from (2000) to (3000);
CREATE TABLE
select relname, relkind from pg_class where relname like 'idxpart%' order by relname;
    relname     | relkind 
----------------+---------
 idxpart        | p
 idxpart1       | r
 idxpart1_a_idx | i
 idxpart2       | r
 idxpart2_a_idx | i
 idxpart3       | r
 idxpart3_a_idx | i
 idxpart_a_idx  | I
(8 rows)

-- a) after detaching partitions, the indexes can be dropped independently
drop index idxpart1_a_idx;
psql:sql/indexing.sql:177: ERROR:  cannot drop index idxpart1_a_idx because index idxpart_a_idx requires it
HINT:  You can drop index idxpart_a_idx instead.
drop index idxpart2_a_idx;
psql:sql/indexing.sql:178: ERROR:  cannot drop index idxpart2_a_idx because index idxpart_a_idx requires it
HINT:  You can drop index idxpart_a_idx instead.
drop index idxpart3_a_idx;
psql:sql/indexing.sql:179: ERROR:  cannot drop index idxpart3_a_idx because index idxpart_a_idx requires it
HINT:  You can drop index idxpart_a_idx instead.
select relname, relkind from pg_class where relname like 'idxpart%' order by relname;
    relname     | relkind 
----------------+---------
 idxpart        | p
 idxpart1       | r
 idxpart1_a_idx | i
 idxpart2       | r
 idxpart2_a_idx | i
 idxpart3       | r
 idxpart3_a_idx | i
 idxpart_a_idx  | I
(8 rows)

drop table idxpart;
DROP TABLE
drop table idxpart1;
psql:sql/indexing.sql:182: ERROR:  table "idxpart1" does not exist
drop table idxpart2;
psql:sql/indexing.sql:183: ERROR:  table "idxpart2" does not exist
drop table idxpart3;
psql:sql/indexing.sql:184: ERROR:  table "idxpart3" does not exist
select relname, relkind from pg_class where relname like 'idxpart%' order by relname;
 relname | relkind 
---------+---------
(0 rows)

create table idxpart (a int) partition by range (a);
CREATE TABLE
create table idxpart1 partition of idxpart for values from (0000) to (1000);
CREATE TABLE
create index on idxpart1 (a);
CREATE INDEX
create index on idxpart (a);
CREATE INDEX
create table idxpart2 partition of idxpart for values from (1000) to (2000);
CREATE TABLE
create table idxpart3 partition of idxpart for values from (2000) to (3000);
CREATE TABLE
-- b) after detaching, dropping the index on parent does not remove the others
select relname, relkind from pg_class where relname like 'idxpart%' order by relname;
    relname     | relkind 
----------------+---------
 idxpart        | p
 idxpart1       | r
 idxpart1_a_idx | i
 idxpart2       | r
 idxpart2_a_idx | i
 idxpart3       | r
 idxpart3_a_idx | i
 idxpart_a_idx  | I
(8 rows)

drop index idxpart_a_idx;
DROP INDEX
select relname, relkind from pg_class where relname like 'idxpart%' order by relname;
 relname  | relkind 
----------+---------
 idxpart  | p
 idxpart1 | r
 idxpart2 | r
 idxpart3 | r
(4 rows)

drop table idxpart;
DROP TABLE
drop table idxpart1;
psql:sql/indexing.sql:198: ERROR:  table "idxpart1" does not exist
drop table idxpart2;
psql:sql/indexing.sql:199: ERROR:  table "idxpart2" does not exist
drop table idxpart3;
psql:sql/indexing.sql:200: ERROR:  table "idxpart3" does not exist
select relname, relkind from pg_class where relname like 'idxpart%' order by relname;
 relname | relkind 
---------+---------
(0 rows)

-- Verify that expression indexes inherit correctly
create table idxpart (a int, b int) partition by range (a);
CREATE TABLE
create table idxpart1 partition of idxpart for values from (0000) to (1000)
create table idxpart2 partition of idxpart for values from (1000) to (2000);
psql:sql/indexing.sql:206: ERROR:  syntax error at or near "create"
LINE 2: create table idxpart2 partition of idxpart for values from (...
        ^
create table idxpart3 partition of idxpart for values from (2000) to (3000);
CREATE TABLE
select relname as child, inhparent::regclass as parent, pg_get_indexdef as childdef
  from pg_class join pg_inherits on inhrelid = oid,
  lateral pg_get_indexdef(pg_class.oid)
  where relkind in ('i', 'I') and relname like 'idxpart%' order by relname;
 child | parent | childdef 
-------+--------+----------
(0 rows)

drop table idxpart;
DROP TABLE
-- Verify behavior for collation (mis)matches
create table idxpart (a varchar(50)) partition by range (a);
CREATE TABLE
create table idxpart1 partition of idxpart for values from ('aaa') to ('bbb');
CREATE TABLE
create table idxpart2 partition of idxpart for values from ('bbb') to ('ccc');
CREATE TABLE
--create index on idxpart2 (a collate "POSIX");
create index on idxpart2 (a);
CREATE INDEX
--create index on idxpart2 (a collate "C");
create table idxpart3 partition of idxpart for values from ('ccc') to ('ddd');
CREATE TABLE
--create index on idxpart (a collate "C");
create table idxpart4 partition of idxpart for values from ('ddd') to ('eee');
CREATE TABLE
select relname as child, inhparent::regclass as parent, pg_get_indexdef as childdef
  from pg_class left join pg_inherits on inhrelid = oid,
  lateral pg_get_indexdef(pg_class.oid)
  where relkind in ('i', 'I') and relname like 'idxpart%' order by relname;
     child      | parent |                                  childdef                                  
----------------+--------+----------------------------------------------------------------------------
 idxpart2_a_idx |        | CREATE INDEX idxpart2_a_idx ON public.idxpart2 USING btree (a NULLS FIRST)
(1 row)

drop table idxpart;
DROP TABLE
-- Verify behavior for opclass (mis)matches
create table idxpart (a varchar(50)) partition by range (a);
CREATE TABLE
create table idxpart1 partition of idxpart for values from ('aaa') to ('bbb');
CREATE TABLE
create table idxpart2 partition of idxpart for values from ('bbb') to ('ccc');
CREATE TABLE
create index on idxpart2 (a);
CREATE INDEX
create table idxpart3 partition of idxpart for values from ('ccc') to ('ddd');
CREATE TABLE
create table idxpart4 partition of idxpart for values from ('ddd') to ('eee');
CREATE TABLE
-- must *not* have attached the index we created on idxpart2
select relname as child, inhparent::regclass as parent, pg_get_indexdef as childdef
  from pg_class left join pg_inherits on inhrelid = oid,
  lateral pg_get_indexdef(pg_class.oid)
  where relkind in ('i', 'I') and relname like 'idxpart%' order by relname;
     child      | parent |                                  childdef                                  
----------------+--------+----------------------------------------------------------------------------
 idxpart2_a_idx |        | CREATE INDEX idxpart2_a_idx ON public.idxpart2 USING btree (a NULLS FIRST)
(1 row)

drop index idxpart_a_idx;
psql:sql/indexing.sql:242: ERROR:  index "idxpart_a_idx" does not exist
create index on only idxpart (a text_pattern_ops);
CREATE INDEX
-- must reject
drop table idxpart;
DROP TABLE
-- Verify that attaching indexes maps attribute numbers correctly
create table idxpart (col1 int, a int, col2 int, b int) partition by range (a);
CREATE TABLE
create table idxpart1 partition of idxpart for values from (0) to (10);
CREATE TABLE
alter table idxpart drop column col1, drop column col2;
ALTER TABLE
create index idxpart_1_idx on only idxpart (b, a);
CREATE INDEX
create index idxpart1_1_idx on idxpart1 (b, a);
CREATE INDEX
create index idxpart1_1b_idx on idxpart1 (b);
CREATE INDEX
-- test expressions and partial-index predicate, too
select relname as child, inhparent::regclass as parent, pg_get_indexdef as childdef
  from pg_class left join pg_inherits on inhrelid = oid,
  lateral pg_get_indexdef(pg_class.oid)
  where relkind in ('i', 'I') and relname like 'idxpart%' order by relname;
      child      | parent |                                         childdef                                          
-----------------+--------+-------------------------------------------------------------------------------------------
 idxpart1_1_idx  |        | CREATE INDEX idxpart1_1_idx ON public.idxpart1 USING btree (b NULLS FIRST, a NULLS FIRST)
 idxpart1_1b_idx |        | CREATE INDEX idxpart1_1b_idx ON public.idxpart1 USING btree (b NULLS FIRST)
 idxpart_1_idx   |        | CREATE INDEX idxpart_1_idx ON ONLY public.idxpart USING btree (b, a)
(3 rows)

drop table idxpart;
DROP TABLE
-- Make sure the partition columns are mapped correctly
create table idxpart (a int, b int, c varchar(50)) partition by range (a);
CREATE TABLE
create index idxparti on idxpart (a);
CREATE INDEX
create index idxparti2 on idxpart (c, b);
CREATE INDEX
create table idxpart1 partition of idxpart for values from (0) to (10);
CREATE TABLE
create table idxpart2 partition of idxpart for values from (10) to (20);
CREATE TABLE
create index on idxpart2 (a);
CREATE INDEX
create index on idxpart2 (c, b);
CREATE INDEX
select c.relname, pg_get_indexdef(indexrelid)
  from pg_class c join pg_index i on c.oid = i.indexrelid
  where indrelid::regclass::text like 'idxpart%'
  order by indexrelid::regclass::text collate "C";
      relname      |                                       pg_get_indexdef                                        
-------------------+----------------------------------------------------------------------------------------------
 idxpart1_a_idx    | CREATE INDEX idxpart1_a_idx ON public.idxpart1 USING btree (a NULLS FIRST)
 idxpart1_c_b_idx  | CREATE INDEX idxpart1_c_b_idx ON public.idxpart1 USING btree (c NULLS FIRST, b NULLS FIRST)
 idxpart2_a_idx    | CREATE INDEX idxpart2_a_idx ON public.idxpart2 USING btree (a NULLS FIRST)
 idxpart2_a_idx1   | CREATE INDEX idxpart2_a_idx1 ON public.idxpart2 USING btree (a NULLS FIRST)
 idxpart2_c_b_idx  | CREATE INDEX idxpart2_c_b_idx ON public.idxpart2 USING btree (c NULLS FIRST, b NULLS FIRST)
 idxpart2_c_b_idx1 | CREATE INDEX idxpart2_c_b_idx1 ON public.idxpart2 USING btree (c NULLS FIRST, b NULLS FIRST)
 idxparti          | CREATE INDEX idxparti ON ONLY public.idxpart USING btree (a)
 idxparti2         | CREATE INDEX idxparti2 ON ONLY public.idxpart USING btree (c, b)
(8 rows)

drop table idxpart;
DROP TABLE
-- Verify that columns are mapped correctly in expression indexes
create table idxpart (col1 int, col2 int, a int, b int) partition by range (a);
CREATE TABLE
create table idxpart1 partition of idxpart for values from (1) to 2);
psql:sql/indexing.sql:277: ERROR:  syntax error at or near "2"
LINE 1: ...ble idxpart1 partition of idxpart for values from (1) to 2);
                                                                    ^
create table idxpart2 partition of idxpart for values from (0) to (1);
CREATE TABLE
alter table idxpart drop column col1, drop column col2;
ALTER TABLE
select c.relname, pg_get_indexdef(indexrelid)
  from pg_class c join pg_index i on c.oid = i.indexrelid
  where indrelid::regclass::text like 'idxpart%'
  order by indexrelid::regclass::text collate "C";
 relname | pg_get_indexdef 
---------+-----------------
(0 rows)

drop table idxpart;
DROP TABLE
-- Verify that columns are mapped correctly for WHERE in a partial index
create table idxpart (col1 int, a int, col3 int, b int) partition by range (a);
CREATE TABLE
alter table idxpart drop column col1, drop column col3;
ALTER TABLE
create table idxpart1 partition of idxpart for values from (0) to (1000);
CREATE TABLE
create table idxpart2 partition of idxpart for values from (1000) to (2000);
CREATE TABLE
select c.relname, pg_get_indexdef(indexrelid)
  from pg_class c join pg_index i on c.oid = i.indexrelid
  where indrelid::regclass::text like 'idxpart%'
  order by indexrelid::regclass::text collate "C";
 relname | pg_get_indexdef 
---------+-----------------
(0 rows)

drop table idxpart;
DROP TABLE
--
-- Constraint-related indexes
--
-- Verify that it works to add primary key / unique to partitioned tables
create table idxpart (a int primary key, b int) partition by range (a);
CREATE TABLE
\d idxpart
        Partitioned table "public.idxpart"
 Column |  Type   | Collation | Nullable | Default 
--------+---------+-----------+----------+---------
 a      | integer |           | not null | 
 b      | integer |           |          | 
Partition key: RANGE (a)
Indexes:
    "idxpart_pkey" PRIMARY KEY, btree (a)
Number of partitions: 0

-- multiple primary key on child should fail
create table failpart partition of idxpart (b primary key) for values from (0) to (100);
psql:sql/indexing.sql:304: ERROR:  multiple primary keys for table "failpart" are not allowed
drop table idxpart;
DROP TABLE
-- primary key on child is okay if there's no PK in the parent, though
create table idxpart (a int) partition by range (a);
CREATE TABLE
create table idxpart1pk partition of idxpart (a primary key) for values from (0) to (100);
CREATE TABLE
\d idxpart1pk
             Table "public.idxpart1pk"
 Column |  Type   | Collation | Nullable | Default 
--------+---------+-----------+----------+---------
 a      | integer |           | not null | 
Partition of: idxpart FOR VALUES FROM (0) TO (100)
Indexes:
    "idxpart1pk_pkey" PRIMARY KEY, btree (a NULLS FIRST)

drop table idxpart;
DROP TABLE
-- Failing to use the full partition key is not allowed
create table idxpart (a int unique, b int) partition by range (a, b);
psql:sql/indexing.sql:313: ERROR:  insufficient columns in UNIQUE constraint definition
DETAIL:  UNIQUE constraint on table "idxpart" lacks column "b" which is part of the partition key.
create table idxpart (a int, b int unique) partition by range (a, b);
psql:sql/indexing.sql:314: ERROR:  insufficient columns in UNIQUE constraint definition
DETAIL:  UNIQUE constraint on table "idxpart" lacks column "a" which is part of the partition key.
create table idxpart (a int primary key, b int) partition by range (b, a);
psql:sql/indexing.sql:315: ERROR:  insufficient columns in PRIMARY KEY constraint definition
DETAIL:  PRIMARY KEY constraint on table "idxpart" lacks column "b" which is part of the partition key.
create table idxpart (a int, b int primary key) partition by range (b, a);
psql:sql/indexing.sql:316: ERROR:  insufficient columns in PRIMARY KEY constraint definition
DETAIL:  PRIMARY KEY constraint on table "idxpart" lacks column "a" which is part of the partition key.
-- OK if you use them in some other order
create table idxpart (a int, b int, c varchar(50), primary key  (a, b, c)) partition by range (b, c, a);
CREATE TABLE
drop table idxpart;
DROP TABLE
-- not other types of index-based constraints
create table idxpart (a int, exclude (a with = )) partition by range (a);
psql:sql/indexing.sql:323: ERROR:  exclusion constraints are not supported on partitioned tables
LINE 1: create table idxpart (a int, exclude (a with = )) partition ...
                                     ^
-- no expressions in partition key for PK/UNIQUE
create table idxpart (a int primary key, b int) partition by range ((b + a));
psql:sql/indexing.sql:326: ERROR:  unsupported PRIMARY KEY constraint with partition key definition
DETAIL:  PRIMARY KEY constraints cannot be used when partition keys include expressions.
create table idxpart (a int unique, b int) partition by range ((b + a));
psql:sql/indexing.sql:327: ERROR:  unsupported UNIQUE constraint with partition key definition
DETAIL:  UNIQUE constraints cannot be used when partition keys include expressions.
-- use ALTER TABLE to add a primary key
create table idxpart (a int, b int, c text) partition by range (a, b);
CREATE TABLE
alter table idxpart add primary key (a);	-- not an incomplete one though
psql:sql/indexing.sql:331: ERROR:  insufficient columns in PRIMARY KEY constraint definition
DETAIL:  PRIMARY KEY constraint on table "idxpart" lacks column "b" which is part of the partition key.
alter table idxpart add primary key (a, b);	-- this works
ALTER TABLE
\d idxpart
        Partitioned table "public.idxpart"
 Column |  Type   | Collation | Nullable | Default 
--------+---------+-----------+----------+---------
 a      | integer |           | not null | 
 b      | integer |           | not null | 
 c      | text    |           |          | 
Partition key: RANGE (a, b)
Indexes:
    "idxpart_pkey" PRIMARY KEY, btree (a, b)
Number of partitions: 0

create table idxpart1 partition of idxpart for values from (0, 0) to (1000, 1000);
CREATE TABLE
\d idxpart1
              Table "public.idxpart1"
 Column |  Type   | Collation | Nullable | Default 
--------+---------+-----------+----------+---------
 a      | integer |           | not null | 
 b      | integer |           | not null | 
 c      | text    |           |          | 
Partition of: idxpart FOR VALUES FROM (0, 0) TO (1000, 1000)
Indexes:
    "idxpart1_pkey" PRIMARY KEY, btree (a NULLS FIRST, b NULLS FIRST)

drop table idxpart;
DROP TABLE
-- use ALTER TABLE to add a unique constraint
create table idxpart (a int, b int) partition by range (a, b);
CREATE TABLE
alter table idxpart add unique (a);			-- not an incomplete one though
psql:sql/indexing.sql:340: ERROR:  insufficient columns in UNIQUE constraint definition
DETAIL:  UNIQUE constraint on table "idxpart" lacks column "b" which is part of the partition key.
alter table idxpart add unique (b, a);		-- this works
ALTER TABLE
\d idxpart
        Partitioned table "public.idxpart"
 Column |  Type   | Collation | Nullable | Default 
--------+---------+-----------+----------+---------
 a      | integer |           |          | 
 b      | integer |           |          | 
Partition key: RANGE (a, b)
Indexes:
    "idxpart_b_a_key" UNIQUE CONSTRAINT, btree (b, a)
Number of partitions: 0

drop table idxpart;
DROP TABLE
-- Exclusion constraints cannot be added
create table idxpart (a int, b int) partition by range (a);
CREATE TABLE
alter table idxpart add exclude (a with =);
psql:sql/indexing.sql:347: ERROR:  Kunlun-db: Alter table is not supported
drop table idxpart;
DROP TABLE
-- When (sub)partitions are created, they also contain the constraint
create table idxpart (a int, b int, primary key (a, b)) partition by range (a, b);
CREATE TABLE
create table idxpart1 partition of idxpart for values from (1, 1) to (10, 10);
CREATE TABLE
create table idxpart2 partition of idxpart for values from (10, 10) to (20, 20)
  partition by range (b);
CREATE TABLE
create table idxpart21 partition of idxpart2 for values from (10) to (15);
CREATE TABLE
create table idxpart22 partition of idxpart2 for values from (15) to (20);
CREATE TABLE
create table idxpart3 partition of idxpart for values from from (20, 20) to (30, 30);
psql:sql/indexing.sql:357: ERROR:  syntax error at or near "from"
LINE 1: ...ble idxpart3 partition of idxpart for values from from (20, ...
                                                             ^
select conname, contype, conrelid::regclass, conindid::regclass, conkey
  from pg_constraint where conrelid::regclass::text like 'idxpart%'
  order by conname;
    conname     | contype | conrelid  |    conindid    | conkey 
----------------+---------+-----------+----------------+--------
 idxpart1_pkey  | p       | idxpart1  | idxpart1_pkey  | {1,2}
 idxpart21_pkey | p       | idxpart21 | idxpart21_pkey | {1,2}
 idxpart22_pkey | p       | idxpart22 | idxpart22_pkey | {1,2}
 idxpart2_pkey  | p       | idxpart2  | idxpart2_pkey  | {1,2}
 idxpart_pkey   | p       | idxpart   | idxpart_pkey   | {1,2}
(5 rows)

drop table idxpart;
DROP TABLE
-- Verify that multi-layer partitioning honors the requirement that all
-- columns in the partition key must appear in primary/unique key
create table idxpart (a int, b int, primary key (a)) partition by range (a);
CREATE TABLE
create table idxpart2 partition of idxpart
for values from (0) to (1000) partition by range (b); -- fail
psql:sql/indexing.sql:367: ERROR:  insufficient columns in PRIMARY KEY constraint definition
DETAIL:  PRIMARY KEY constraint on table "idxpart2" lacks column "b" which is part of the partition key.
drop table idxpart;
DROP TABLE
-- Multi-layer partitioning works correctly in this case:
create table idxpart (a int, b int, primary key (a, b)) partition by range (a);
CREATE TABLE
create table idxpart2 partition of idxpart for values from (0) to (1000) partition by range (b);
CREATE TABLE
create table idxpart21 partition of idxpart2 for values from (0) to (1000);
CREATE TABLE
select conname, contype, conrelid::regclass, conindid::regclass, conkey
  from pg_constraint where conrelid::regclass::text like 'idxpart%'
  order by conname;
    conname     | contype | conrelid  |    conindid    | conkey 
----------------+---------+-----------+----------------+--------
 idxpart21_pkey | p       | idxpart21 | idxpart21_pkey | {1,2}
 idxpart2_pkey  | p       | idxpart2  | idxpart2_pkey  | {1,2}
 idxpart_pkey   | p       | idxpart   | idxpart_pkey   | {1,2}
(3 rows)

drop table idxpart;
DROP TABLE
-- If a partitioned table has a unique/PK constraint, then it's not possible
-- to drop the corresponding constraint in the children; nor it's possible
-- to drop the indexes individually.  Dropping the constraint in the parent
-- gets rid of the lot.
create table idxpart (i int) partition by hash (i);
CREATE TABLE
create table idxpart0 partition of idxpart (i) for values with (modulus 2, remainder 0);
CREATE TABLE
create table idxpart1 partition of idxpart (i) for values with (modulus 2, remainder 1);
CREATE TABLE
alter table idxpart0 add primary key(i);
ALTER TABLE
alter table idxpart add primary key(i);
ALTER TABLE
select indrelid::regclass, indexrelid::regclass, inhparent::regclass, indisvalid,
  conname, conislocal, coninhcount, connoinherit, convalidated
  from pg_index idx left join pg_inherits inh on (idx.indexrelid = inh.inhrelid)
  left join pg_constraint con on (idx.indexrelid = con.conindid)
  where indrelid::regclass::text like 'idxpart%'
  order by indexrelid::regclass::text collate "C";
 indrelid |  indexrelid   |  inhparent   | indisvalid |    conname    | conislocal | coninhcount | connoinherit | convalidated 
----------+---------------+--------------+------------+---------------+------------+-------------+--------------+--------------
 idxpart0 | idxpart0_pkey | idxpart_pkey | t          | idxpart0_pkey | f          |           1 | t            | t
 idxpart1 | idxpart1_pkey | idxpart_pkey | t          | idxpart1_pkey | f          |           1 | f            | t
 idxpart  | idxpart_pkey  |              | t          | idxpart_pkey  | t          |           0 | t            | t
(3 rows)

drop index idxpart0_pkey;								-- fail
psql:sql/indexing.sql:394: ERROR:  cannot drop index idxpart0_pkey because index idxpart_pkey requires it
HINT:  You can drop index idxpart_pkey instead.
drop index idxpart1_pkey;								-- fail
psql:sql/indexing.sql:395: ERROR:  cannot drop index idxpart1_pkey because index idxpart_pkey requires it
HINT:  You can drop index idxpart_pkey instead.
alter table idxpart0 drop constraint idxpart0_pkey;		-- fail
psql:sql/indexing.sql:396: ERROR:  cannot drop inherited constraint "idxpart0_pkey" of relation "idxpart0"
alter table idxpart1 drop constraint idxpart1_pkey;		-- fail
psql:sql/indexing.sql:397: ERROR:  cannot drop inherited constraint "idxpart1_pkey" of relation "idxpart1"
alter table idxpart drop constraint idxpart_pkey;		-- ok
ALTER TABLE
select indrelid::regclass, indexrelid::regclass, inhparent::regclass, indisvalid,
  conname, conislocal, coninhcount, connoinherit, convalidated
  from pg_index idx left join pg_inherits inh on (idx.indexrelid = inh.inhrelid)
  left join pg_constraint con on (idx.indexrelid = con.conindid)
  where indrelid::regclass::text like 'idxpart%'
  order by indexrelid::regclass::text collate "C";
 indrelid | indexrelid | inhparent | indisvalid | conname | conislocal | coninhcount | connoinherit | convalidated 
----------+------------+-----------+------------+---------+------------+-------------+--------------+--------------
(0 rows)

drop table idxpart;
DROP TABLE
-- Test that unique constraints are working
create table idxpart (a int, b varchar(50), primary key (a, b)) partition by range (a);
CREATE TABLE
create table idxpart1 partition of idxpart for values from (0) to (100000);
CREATE TABLE
create table idxpart2 partition of idxpart for values from (100000) to (1000000);
CREATE TABLE
insert into idxpart values (0, 'zero'), (42, 'life'), (2^16, 'sixteen');
INSERT 0 3
insert into idxpart select 2^g, format('two to power of %s', g) from generate_series(15, 17) g;
INSERT 0 3
insert into idxpart values (16, 'sixteen');
INSERT 0 1
insert into idxpart (b, a) values ('one', 142857), ('two', 285714);
INSERT 0 2
insert into idxpart select a * 2, b || b from idxpart where a between 2^16 and 2^19;
INSERT 0 5
insert into idxpart values (572814, 'five');
INSERT 0 1
insert into idxpart values (857142, 'six');
INSERT 0 1
drop table idxpart;
DROP TABLE
-- test fastpath mechanism for index insertion
drop table if exists fastpath;
psql:sql/indexing.sql:421: NOTICE:  table "fastpath" does not exist, skipping
DROP TABLE
create table fastpath (a int, b varchar(50), c numeric);
CREATE TABLE
create unique index fpindex1 on fastpath(a);
CREATE INDEX
insert into fastpath values (1, 'b1', 100.00);
INSERT 0 1
insert into fastpath values (1, 'b1', 100.00); -- unique key check
psql:sql/indexing.sql:426: ERROR:  Kunlun-db: MySQL storage node (1, 1) returned error: 1062, Duplicate entry '1' for key 'fastpath.fpindex1'.
delete from fastpath;
DELETE 1
insert into fastpath select generate_series(1,10000), 'b', 100;
INSERT 0 10000
set enable_seqscan to false;
SET
set enable_bitmapscan to false;
SET
select sum(a) from fastpath where a = 6456;
 sum  
------
 6456
(1 row)

select sum(a) from fastpath where a >= 5000 and a < 5700;
   sum   
---------
 3744650
(1 row)

-- drop the only index on the table and compute hashes for
-- a few queries which orders the results in various different ways.
drop index fpindex1;
DROP INDEX
delete from fastpath;
DELETE 10000
insert into fastpath select y.x, 'b' || (y.x/10)::text, 100 from (select generate_series(1,10000) as x) y;
INSERT 0 10000
select md5(string_agg(a::text, b order by a, b asc)) from fastpath
	where a >= 1000 and a < 2000 and b > 'b1' and b < 'b3';
               md5                
----------------------------------
 2ca216010a558a52d7df12f76dfc77ab
(1 row)

select md5(string_agg(a::text, b order by a desc, b desc)) from fastpath
	where a >= 1000 and a < 2000 and b > 'b1' and b < 'b3';
               md5                
----------------------------------
 6167a852b3e0679886b84a5405b5b53d
(1 row)

select md5(string_agg(a::text, b order by b, a desc)) from fastpath
	where a >= 1000 and a < 2000 and b > 'b1' and b < 'b3';
               md5                
----------------------------------
 dfcf2bd5e5fea8397d47b2fd14618d31
(1 row)

select md5(string_agg(a::text, b order by b, a asc)) from fastpath
	where a >= 1000 and a < 2000 and b > 'b1' and b < 'b3';
               md5                
----------------------------------
 2ca216010a558a52d7df12f76dfc77ab
(1 row)

-- now create a multi-column index with both column asc
create index fpindex2 on fastpath(a, b);
CREATE INDEX
delete from fastpath;
DELETE 10000
insert into fastpath select y.x, 'b' || (y.x/10)::text, 100 from (select generate_series(1,10000) as x) y;
INSERT 0 10000
select md5(string_agg(a::text, b order by a, b asc)) from fastpath
	where a >= 1000 and a < 2000 and b > 'b1' and b < 'b3';
               md5                
----------------------------------
 2ca216010a558a52d7df12f76dfc77ab
(1 row)

select md5(string_agg(a::text, b order by a desc, b desc)) from fastpath
	where a >= 1000 and a < 2000 and b > 'b1' and b < 'b3';
               md5                
----------------------------------
 6167a852b3e0679886b84a5405b5b53d
(1 row)

select md5(string_agg(a::text, b order by b, a desc)) from fastpath
	where a >= 1000 and a < 2000 and b > 'b1' and b < 'b3';
               md5                
----------------------------------
 dfcf2bd5e5fea8397d47b2fd14618d31
(1 row)

select md5(string_agg(a::text, b order by b, a asc)) from fastpath
	where a >= 1000 and a < 2000 and b > 'b1' and b < 'b3';
               md5                
----------------------------------
 2ca216010a558a52d7df12f76dfc77ab
(1 row)

-- same queries with a different kind of index now. the final result must not
-- change irrespective of what kind of index we have.
drop index fpindex2;
DROP INDEX
create index fpindex3 on fastpath(a desc, b asc);
CREATE INDEX
delete from fastpath;
DELETE 10000
insert into fastpath select y.x, 'b' || (y.x/10)::text, 100 from (select generate_series(1,10000) as x) y;
INSERT 0 10000
select md5(string_agg(a::text, b order by a, b asc)) from fastpath
	where a >= 1000 and a < 2000 and b > 'b1' and b < 'b3';
               md5                
----------------------------------
 2ca216010a558a52d7df12f76dfc77ab
(1 row)

select md5(string_agg(a::text, b order by a desc, b desc)) from fastpath
	where a >= 1000 and a < 2000 and b > 'b1' and b < 'b3';
               md5                
----------------------------------
 6167a852b3e0679886b84a5405b5b53d
(1 row)

select md5(string_agg(a::text, b order by b, a desc)) from fastpath
	where a >= 1000 and a < 2000 and b > 'b1' and b < 'b3';
               md5                
----------------------------------
 dfcf2bd5e5fea8397d47b2fd14618d31
(1 row)

select md5(string_agg(a::text, b order by b, a asc)) from fastpath
	where a >= 1000 and a < 2000 and b > 'b1' and b < 'b3';
               md5                
----------------------------------
 2ca216010a558a52d7df12f76dfc77ab
(1 row)

-- repeat again
drop index fpindex3;
DROP INDEX
create index fpindex4 on fastpath(a asc, b desc);
CREATE INDEX
delete from fastpath;
DELETE 10000
insert into fastpath select y.x, 'b' || (y.x/10)::text, 100 from (select generate_series(1,10000) as x) y;
INSERT 0 10000
select md5(string_agg(a::text, b order by a, b asc)) from fastpath
	where a >= 1000 and a < 2000 and b > 'b1' and b < 'b3';
               md5                
----------------------------------
 2ca216010a558a52d7df12f76dfc77ab
(1 row)

select md5(string_agg(a::text, b order by a desc, b desc)) from fastpath
	where a >= 1000 and a < 2000 and b > 'b1' and b < 'b3';
               md5                
----------------------------------
 6167a852b3e0679886b84a5405b5b53d
(1 row)

select md5(string_agg(a::text, b order by b, a desc)) from fastpath
	where a >= 1000 and a < 2000 and b > 'b1' and b < 'b3';
               md5                
----------------------------------
 dfcf2bd5e5fea8397d47b2fd14618d31
(1 row)

select md5(string_agg(a::text, b order by b, a asc)) from fastpath
	where a >= 1000 and a < 2000 and b > 'b1' and b < 'b3';
               md5                
----------------------------------
 2ca216010a558a52d7df12f76dfc77ab
(1 row)

-- and again, this time indexing by (b, a). Note that column "b" has non-unique
-- values.
drop index fpindex4;
DROP INDEX
create index fpindex5 on fastpath(b asc, a desc);
CREATE INDEX
delete from fastpath;
DELETE 10000
insert into fastpath select y.x, 'b' || (y.x/10)::text, 100 from (select generate_series(1,10000) as x) y;
INSERT 0 10000
select md5(string_agg(a::text, b order by a, b asc)) from fastpath
	where a >= 1000 and a < 2000 and b > 'b1' and b < 'b3';
               md5                
----------------------------------
 2ca216010a558a52d7df12f76dfc77ab
(1 row)

select md5(string_agg(a::text, b order by a desc, b desc)) from fastpath
	where a >= 1000 and a < 2000 and b > 'b1' and b < 'b3';
               md5                
----------------------------------
 6167a852b3e0679886b84a5405b5b53d
(1 row)

select md5(string_agg(a::text, b order by b, a desc)) from fastpath
	where a >= 1000 and a < 2000 and b > 'b1' and b < 'b3';
               md5                
----------------------------------
 dfcf2bd5e5fea8397d47b2fd14618d31
(1 row)

select md5(string_agg(a::text, b order by b, a asc)) from fastpath
	where a >= 1000 and a < 2000 and b > 'b1' and b < 'b3';
               md5                
----------------------------------
 2ca216010a558a52d7df12f76dfc77ab
(1 row)

-- one last time
drop index fpindex5;
DROP INDEX
create index fpindex6 on fastpath(b desc, a desc);
CREATE INDEX
delete from fastpath;
DELETE 10000
insert into fastpath select y.x, 'b' || (y.x/10)::text, 100 from (select generate_series(1,10000) as x) y;
INSERT 0 10000
select md5(string_agg(a::text, b order by a, b asc)) from fastpath
	where a >= 1000 and a < 2000 and b > 'b1' and b < 'b3';
               md5                
----------------------------------
 2ca216010a558a52d7df12f76dfc77ab
(1 row)

select md5(string_agg(a::text, b order by a desc, b desc)) from fastpath
	where a >= 1000 and a < 2000 and b > 'b1' and b < 'b3';
               md5                
----------------------------------
 6167a852b3e0679886b84a5405b5b53d
(1 row)

select md5(string_agg(a::text, b order by b, a desc)) from fastpath
	where a >= 1000 and a < 2000 and b > 'b1' and b < 'b3';
               md5                
----------------------------------
 dfcf2bd5e5fea8397d47b2fd14618d31
(1 row)

select md5(string_agg(a::text, b order by b, a asc)) from fastpath
	where a >= 1000 and a < 2000 and b > 'b1' and b < 'b3';
               md5                
----------------------------------
 2ca216010a558a52d7df12f76dfc77ab
(1 row)

	
drop table fastpath;
DROP TABLE
-- intentionally leave some objects around
drop table if exists idxpart;
psql:sql/indexing.sql:525: NOTICE:  table "idxpart" does not exist, skipping
DROP TABLE
create table idxpart (a int) partition by range (a);
CREATE TABLE
create table idxpart1 partition of idxpart for values from (0) to (100);
CREATE TABLE
create table idxpart2 partition of idxpart for values from (100) to (1000)
  partition by range (a);
CREATE TABLE
create table idxpart21 partition of idxpart2 for values from (100) to (200);
CREATE TABLE
create table idxpart22 partition of idxpart2 for values from (200) to (300);
CREATE TABLE
create index on idxpart22 (a);
CREATE INDEX
create index on only idxpart2 (a);
CREATE INDEX
create index on idxpart (a);
CREATE INDEX
create table idxpart_another (a int, b int, primary key (a, b)) partition by range (a);
CREATE TABLE
create table idxpart_another_1 partition of idxpart_another for values from (0) to (100);
CREATE TABLE
create table idxpart3 partition of idxpart for values from (1000) to (2000) partition by range (a);
CREATE TABLE
create table idxpart31 partition of idxpart3 for values from (1000) to (1200);
CREATE TABLE
create table idxpart32 partition of idxpart3 for values from (1200) to (1400);
CREATE TABLE
drop table idxpart_another;
DROP TABLE
drop table idxpart;
DROP TABLE
-- check that detaching a partition also detaches the primary key constraint
drop table if exists parted_pk_detach_test;
psql:sql/indexing.sql:544: NOTICE:  table "parted_pk_detach_test" does not exist, skipping
DROP TABLE
create table parted_pk_detach_test (a int primary key) partition by list (a);
CREATE TABLE
create table parted_pk_detach_test1 partition of parted_pk_detach_test for values in (1);
CREATE TABLE
alter table parted_pk_detach_test1 drop constraint parted_pk_detach_test1_pkey;	-- should fail
psql:sql/indexing.sql:547: ERROR:  cannot drop inherited constraint "parted_pk_detach_test1_pkey" of relation "parted_pk_detach_test1"
alter table parted_pk_detach_test1 drop constraint parted_pk_detach_test1_pkey;
psql:sql/indexing.sql:548: ERROR:  cannot drop inherited constraint "parted_pk_detach_test1_pkey" of relation "parted_pk_detach_test1"
drop table parted_pk_detach_test;
DROP TABLE
drop table parted_pk_detach_test1;
psql:sql/indexing.sql:550: ERROR:  table "parted_pk_detach_test1" does not exist
create table parted_uniq_detach_test (a int unique) partition by list (a);
CREATE TABLE
create table parted_uniq_detach_test1 partition of parted_uniq_detach_test for values in (1);
CREATE TABLE
alter table parted_uniq_detach_test1 drop constraint parted_uniq_detach_test1_a_key;	-- should fail
psql:sql/indexing.sql:553: ERROR:  cannot drop inherited constraint "parted_uniq_detach_test1_a_key" of relation "parted_uniq_detach_test1"
alter table parted_uniq_detach_test1 drop constraint parted_uniq_detach_test1_a_key;
psql:sql/indexing.sql:554: ERROR:  cannot drop inherited constraint "parted_uniq_detach_test1_a_key" of relation "parted_uniq_detach_test1"
drop table parted_uniq_detach_test;
DROP TABLE
drop table parted_uniq_detach_test1;
psql:sql/indexing.sql:556: ERROR:  table "parted_uniq_detach_test1" does not exist
