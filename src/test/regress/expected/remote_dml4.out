DROP TABLE IF EXISTS t1;
NOTICE:  table "t1" does not exist, skipping
DROP TABLE IF EXISTS t2;
NOTICE:  table "t2" does not exist, skipping
CREATE TABLE t1(A INT PRIMARY KEY, B INT NOT NULL UNIQUE);
CREATE TEMP TABLE t2(A INT PRIMARY KEY, B INT NOT NULL UNIQUE);
CREATE TABLE t3 (A INT PRIMARY KEY, B INT) PARTITION BY RANGE(a);
CREATE TABLE t3p1 PARTITION OF t3 FOR VALUES FROM (0) TO (100);
CREATE TABLE t3p2 PARTITION OF t3 FOR VALUES FROM (100) TO (200);
CREATE TEMP TABLE t4 (A INT PRIMARY KEY, B INT) PARTITION BY RANGE(a);
CREATE TEMP TABLE t4p1 PARTITION OF t4 FOR VALUES FROM (0) TO (100);
CREATE TEMP TABLE t4p2 PARTITION OF t4 FOR VALUES FROM (100) TO (200);
-- insert ignore
INSERT INTO t1 VALUES(1,1), (2,2);
INSERT IGNORE INTO t1 VALUES(1,2);
SELECT * FROM t1;
 a | b 
---+---
 1 | 1
 2 | 2
(2 rows)

INSERT IGNORE INTO t1 VALUES(1, NULL); -- should be fail
ERROR:  null value in column "b" violates not-null constraint
DETAIL:  Failing row contains (1, null).
INSERT INTO t2 SELECT * FROM T1;
INSERT IGNORE INTO t2 VALUES(1,2);
SELECT * FROM t1;
 a | b 
---+---
 1 | 1
 2 | 2
(2 rows)

INSERT IGNORE INTO t1 VALUES(1, NULL); -- should be fail
ERROR:  null value in column "b" violates not-null constraint
DETAIL:  Failing row contains (1, null).
-- insert on duplicate key update
INSERT INTO t1 VALUES(1,1) ON DUPLICATE KEY UPDATE  b=-1;
INSERT INTO t1 VALUES(3,3), (3,4) ON DUPLICATE KEY UPDATE b=excluded.b+1;
SELECT *  FROM t1;
 a | b  
---+----
 1 | -1
 2 |  2
 3 |  5
(3 rows)

-- The temp table is stored in kunlun's postgres and does not allow more than two updates to a tuple.
INSERT INTO t2 VALUES(3,3), (3,4) ON DUPLICATE KEY UPDATE b=excluded.b+1; -- should be fail
ERROR:  ON CONFLICT DO UPDATE command cannot affect row a second time
HINT:  Ensure that no rows proposed for insertion within the same command have duplicate constrained values.
INSERT INTO t3 SELECT GENERATE_SERIES(0,400) % 200, 0 ON DUPLICATE KEY UPDATE b=t3.b+1;
-- update partition key is not allowed
INSERT INTO t3 SELECT GENERATE_SERIES(0,400) % 200, 0 ON DUPLICATE KEY UPDATE a=200-t3.a; -- should be fail
ERROR:  Kunlun-db: Can not update partition key of a remote relation.
--- replace
DELETE  FROM t1;
INSERT INTO t1 VALUES(1,1), (1,2);
ERROR:  Kunlun-db: MySQL storage node (1, 1) returned error: 1062, Duplicate entry '1' for key 't1.PRIMARY'.
REPLACE INTO t1 VALUES(1,2);
SELECT * FROM t1;
 a | b 
---+---
 1 | 2
(1 row)

REPLACE INTO t1 VALUES (3,3), (3,4), (3,5);
SELECT * FROM t1;
 a | b 
---+---
 1 | 2
 3 | 5
(2 rows)

DELETE FROM t2;
REPLACE INTO t1 VALUES (3,3), (3,4), (3,5); -- should be fail
DELETE FROM t3;
REPLACE INTO t3 SELECT GENERATE_SERIES(0,400) % 200, GENERATE_SERIES(0,400);
SELECT count(1) FROM t3;
 count 
-------
   200
(1 row)

DELETE FROM t4;
REPLACE INTO t4 SELECT GENERATE_SERIES(0,400) % 200, GENERATE_SERIES(0,400); -- should be fail
ERROR:  REPLACE INTO command cannot affect row a second time
HINT:  Ensure that no rows proposed for insertion within the same command have duplicate constrained values.
-- update limit
DELETE FROM t1;
INSERT INTO t1 SELECT GENERATE_SERIES(0,20), GENERATE_SERIES(0,20);
UPDATE t1 SET b=-b ORDER BY a LIMIT 1;
SELECT * FROM t1 WHERE b < 0;
 a | b 
---+---
(0 rows)

UPDATE t1 SET b=-b ORDER BY a DESC LIMIT 1;
SELECT * FROM t1 WHERE b < 0;
 a  |  b  
----+-----
 20 | -20
(1 row)

UPDATE t3 SET b=-b ORDER BY a LIMIT 1; -- should be fail, global order is not supported
ERROR:  Kunlun-db: Cannot push down plan
UPDATE t3 SET b=-b WHERE a<100 ORDER BY a LIMIT 1 RETURNING *;
 a |  b   
---+------
 0 | -400
(1 row)

WITH foo as (UPDATE t3 SET b=-b WHERE b > 0 LIMIT 10 RETURNING *) SELECT count(1) FROM foo;
 count 
-------
    10
(1 row)

SELECT count(1) FROM t3 where b<0;
 count 
-------
    11
(1 row)

INSERT INTO t4 SELECT GENERATE_SERIES(0,100);
UPDATE t4 SET a=a+10 ORDER BY a; -- should be fail
ERROR:  duplicate key value violates unique constraint "t4p1_pkey"
DETAIL:  Key (a)=(10) already exists.
UPDATE t4 SET a=a+10 ORDER BY a DESC LIMIT 30 RETURNING *;
  a  | b 
-----+---
 110 |  
 109 |  
 108 |  
 107 |  
 106 |  
 105 |  
 104 |  
 103 |  
 102 |  
 101 |  
 100 |  
  99 |  
  98 |  
  97 |  
  96 |  
  95 |  
  94 |  
  93 |  
  92 |  
  91 |  
  90 |  
  89 |  
  88 |  
  87 |  
  86 |  
  85 |  
  84 |  
  83 |  
  82 |  
  81 |  
(30 rows)

