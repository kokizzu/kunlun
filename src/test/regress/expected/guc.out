-- pg_regress should ensure that this default value applies; however
-- we can't rely on any specific default value of vacuum_cost_delay
SHOW datestyle;
 DateStyle 
-----------
 ISO, YMD
(1 row)

-- SET to some nondefault value
SET vacuum_cost_delay TO 40;
SET
SET datestyle = 'ISO, YMD';
SET
SHOW vacuum_cost_delay;
 vacuum_cost_delay 
-------------------
 40ms
(1 row)

SHOW datestyle;
 DateStyle 
-----------
 ISO, YMD
(1 row)

SELECT '2006-08-13 12:34:56'::timestamptz;
      timestamptz       
------------------------
 2006-08-13 12:34:56+08
(1 row)

-- SET LOCAL has no effect outside of a transaction
SET LOCAL vacuum_cost_delay TO 50;
psql:sql/guc.sql:13: WARNING:  SET LOCAL can only be used in transaction blocks
SET
SHOW vacuum_cost_delay;
 vacuum_cost_delay 
-------------------
 40ms
(1 row)

SET LOCAL datestyle = 'SQL';
psql:sql/guc.sql:15: WARNING:  SET LOCAL can only be used in transaction blocks
SET
SHOW datestyle;
 DateStyle 
-----------
 ISO, YMD
(1 row)

SELECT '2006-08-13 12:34:56'::timestamptz;
      timestamptz       
------------------------
 2006-08-13 12:34:56+08
(1 row)

-- SET LOCAL within a transaction that commits
BEGIN;
BEGIN
SET LOCAL vacuum_cost_delay TO 50;
SET
SHOW vacuum_cost_delay;
 vacuum_cost_delay 
-------------------
 50ms
(1 row)

SET LOCAL datestyle = 'SQL';
SET
SHOW datestyle;
 DateStyle 
-----------
 SQL, YMD
(1 row)

SELECT '2006-08-13 12:34:56'::timestamptz;
       timestamptz       
-------------------------
 08/13/2006 12:34:56 CST
(1 row)

COMMIT;
COMMIT
SHOW vacuum_cost_delay;
 vacuum_cost_delay 
-------------------
 40ms
(1 row)

SHOW datestyle;
 DateStyle 
-----------
 ISO, YMD
(1 row)

SELECT '2006-08-13 12:34:56'::timestamptz;
      timestamptz       
------------------------
 2006-08-13 12:34:56+08
(1 row)

-- SET should be reverted after ROLLBACK
BEGIN;
BEGIN
SET vacuum_cost_delay TO 60;
SET
SHOW vacuum_cost_delay;
 vacuum_cost_delay 
-------------------
 60ms
(1 row)

SET datestyle = 'German';
SET
SHOW datestyle;
  DateStyle  
-------------
 German, DMY
(1 row)

SELECT '2006-08-13 12:34:56'::timestamptz;
       timestamptz       
-------------------------
 13.08.2006 12:34:56 CST
(1 row)

ROLLBACK;
ROLLBACK
SHOW vacuum_cost_delay;
 vacuum_cost_delay 
-------------------
 40ms
(1 row)

SHOW datestyle;
 DateStyle 
-----------
 ISO, YMD
(1 row)

SELECT '2006-08-13 12:34:56'::timestamptz;
      timestamptz       
------------------------
 2006-08-13 12:34:56+08
(1 row)

-- Some tests with subtransactions
BEGIN;
BEGIN
SET vacuum_cost_delay TO 70;
SET
SET datestyle = 'MDY';
SET
SHOW datestyle;
 DateStyle 
-----------
 ISO, MDY
(1 row)

SELECT '2006-08-13 12:34:56'::timestamptz;
      timestamptz       
------------------------
 2006-08-13 12:34:56+08
(1 row)

SAVEPOINT first_sp;
SAVEPOINT
SET vacuum_cost_delay TO 80;
SET
SHOW vacuum_cost_delay;
 vacuum_cost_delay 
-------------------
 80ms
(1 row)

SET datestyle = 'German, DMY';
SET
SHOW datestyle;
  DateStyle  
-------------
 German, DMY
(1 row)

SELECT '2006-08-13 12:34:56'::timestamptz;
       timestamptz       
-------------------------
 13.08.2006 12:34:56 CST
(1 row)

ROLLBACK TO first_sp;
ROLLBACK
SHOW datestyle;
 DateStyle 
-----------
 ISO, MDY
(1 row)

SELECT '2006-08-13 12:34:56'::timestamptz;
      timestamptz       
------------------------
 2006-08-13 12:34:56+08
(1 row)

SAVEPOINT second_sp;
SAVEPOINT
SET vacuum_cost_delay TO 90;
SET
SET datestyle = 'SQL, YMD';
SET
SHOW datestyle;
 DateStyle 
-----------
 SQL, YMD
(1 row)

SELECT '2006-08-13 12:34:56'::timestamptz;
       timestamptz       
-------------------------
 08/13/2006 12:34:56 CST
(1 row)

SAVEPOINT third_sp;
SAVEPOINT
SET vacuum_cost_delay TO 100;
SET
SHOW vacuum_cost_delay;
 vacuum_cost_delay 
-------------------
 100ms
(1 row)

SET datestyle = 'Postgres, MDY';
SET
SHOW datestyle;
   DateStyle   
---------------
 Postgres, MDY
(1 row)

SELECT '2006-08-13 12:34:56'::timestamptz;
         timestamptz          
------------------------------
 Sun Aug 13 12:34:56 2006 CST
(1 row)

ROLLBACK TO third_sp;
ROLLBACK
SHOW vacuum_cost_delay;
 vacuum_cost_delay 
-------------------
 90ms
(1 row)

SHOW datestyle;
 DateStyle 
-----------
 SQL, YMD
(1 row)

SELECT '2006-08-13 12:34:56'::timestamptz;
       timestamptz       
-------------------------
 08/13/2006 12:34:56 CST
(1 row)

ROLLBACK TO second_sp;
ROLLBACK
SHOW vacuum_cost_delay;
 vacuum_cost_delay 
-------------------
 70ms
(1 row)

SHOW datestyle;
 DateStyle 
-----------
 ISO, MDY
(1 row)

SELECT '2006-08-13 12:34:56'::timestamptz;
      timestamptz       
------------------------
 2006-08-13 12:34:56+08
(1 row)

ROLLBACK;
ROLLBACK
SHOW vacuum_cost_delay;
 vacuum_cost_delay 
-------------------
 40ms
(1 row)

SHOW datestyle;
 DateStyle 
-----------
 ISO, YMD
(1 row)

SELECT '2006-08-13 12:34:56'::timestamptz;
      timestamptz       
------------------------
 2006-08-13 12:34:56+08
(1 row)

-- SET LOCAL with Savepoints
BEGIN;
BEGIN
SHOW vacuum_cost_delay;
 vacuum_cost_delay 
-------------------
 40ms
(1 row)

SHOW datestyle;
 DateStyle 
-----------
 ISO, YMD
(1 row)

SELECT '2006-08-13 12:34:56'::timestamptz;
      timestamptz       
------------------------
 2006-08-13 12:34:56+08
(1 row)

SAVEPOINT sp;
SAVEPOINT
SET LOCAL vacuum_cost_delay TO 30;
SET
SHOW vacuum_cost_delay;
 vacuum_cost_delay 
-------------------
 30ms
(1 row)

SET LOCAL datestyle = 'Postgres, MDY';
SET
SHOW datestyle;
   DateStyle   
---------------
 Postgres, MDY
(1 row)

SELECT '2006-08-13 12:34:56'::timestamptz;
         timestamptz          
------------------------------
 Sun Aug 13 12:34:56 2006 CST
(1 row)

ROLLBACK TO sp;
ROLLBACK
SHOW vacuum_cost_delay;
 vacuum_cost_delay 
-------------------
 40ms
(1 row)

SHOW datestyle;
 DateStyle 
-----------
 ISO, YMD
(1 row)

SELECT '2006-08-13 12:34:56'::timestamptz;
      timestamptz       
------------------------
 2006-08-13 12:34:56+08
(1 row)

ROLLBACK;
ROLLBACK
SHOW vacuum_cost_delay;
 vacuum_cost_delay 
-------------------
 40ms
(1 row)

SHOW datestyle;
 DateStyle 
-----------
 ISO, YMD
(1 row)

SELECT '2006-08-13 12:34:56'::timestamptz;
      timestamptz       
------------------------
 2006-08-13 12:34:56+08
(1 row)

-- SET LOCAL persists through RELEASE (which was not true in 8.0-8.2)
BEGIN;
BEGIN
SHOW vacuum_cost_delay;
 vacuum_cost_delay 
-------------------
 40ms
(1 row)

SHOW datestyle;
 DateStyle 
-----------
 ISO, YMD
(1 row)

SELECT '2006-08-13 12:34:56'::timestamptz;
      timestamptz       
------------------------
 2006-08-13 12:34:56+08
(1 row)

SAVEPOINT sp;
SAVEPOINT
SET LOCAL vacuum_cost_delay TO 30;
SET
SHOW vacuum_cost_delay;
 vacuum_cost_delay 
-------------------
 30ms
(1 row)

SET LOCAL datestyle = 'Postgres, MDY';
SET
SHOW datestyle;
   DateStyle   
---------------
 Postgres, MDY
(1 row)

SELECT '2006-08-13 12:34:56'::timestamptz;
         timestamptz          
------------------------------
 Sun Aug 13 12:34:56 2006 CST
(1 row)

SHOW vacuum_cost_delay;
 vacuum_cost_delay 
-------------------
 30ms
(1 row)

SHOW datestyle;
   DateStyle   
---------------
 Postgres, MDY
(1 row)

SELECT '2006-08-13 12:34:56'::timestamptz;
         timestamptz          
------------------------------
 Sun Aug 13 12:34:56 2006 CST
(1 row)

ROLLBACK;
ROLLBACK
SHOW vacuum_cost_delay;
 vacuum_cost_delay 
-------------------
 40ms
(1 row)

SHOW datestyle;
 DateStyle 
-----------
 ISO, YMD
(1 row)

SELECT '2006-08-13 12:34:56'::timestamptz;
      timestamptz       
------------------------
 2006-08-13 12:34:56+08
(1 row)

-- SET followed by SET LOCAL
BEGIN;
BEGIN
SET vacuum_cost_delay TO 40;
SET
SET LOCAL vacuum_cost_delay TO 50;
SET
SHOW vacuum_cost_delay;
 vacuum_cost_delay 
-------------------
 50ms
(1 row)

SET datestyle = 'ISO, DMY';
SET
SET LOCAL datestyle = 'Postgres, MDY';
SET
SHOW datestyle;
   DateStyle   
---------------
 Postgres, MDY
(1 row)

SELECT '2006-08-13 12:34:56'::timestamptz;
         timestamptz          
------------------------------
 Sun Aug 13 12:34:56 2006 CST
(1 row)

COMMIT;
COMMIT
SHOW vacuum_cost_delay;
 vacuum_cost_delay 
-------------------
 40ms
(1 row)

SHOW datestyle;
 DateStyle 
-----------
 ISO, DMY
(1 row)

SELECT '2006-08-13 12:34:56'::timestamptz;
      timestamptz       
------------------------
 2006-08-13 12:34:56+08
(1 row)

--
-- Test RESET.  We use datestyle because the reset value is forced by
-- pg_regress, so it doesn't depend on the installation's configuration.
--
SET datestyle = iso, ymd;
SET
SHOW datestyle;
 DateStyle 
-----------
 ISO, YMD
(1 row)

SELECT '2006-08-13 12:34:56'::timestamptz;
      timestamptz       
------------------------
 2006-08-13 12:34:56+08
(1 row)

RESET datestyle;
RESET
SHOW datestyle;
 DateStyle 
-----------
 ISO, YMD
(1 row)

SELECT '2006-08-13 12:34:56'::timestamptz;
      timestamptz       
------------------------
 2006-08-13 12:34:56+08
(1 row)

-- Test some simple error cases
SET seq_page_cost TO 'NaN';
psql:sql/guc.sql:147: ERROR:  parameter "seq_page_cost" requires a numeric value
SET vacuum_cost_delay TO '10s';
psql:sql/guc.sql:148: ERROR:  10000 is outside the valid range for parameter "vacuum_cost_delay" (0 .. 100)
--
-- Test DISCARD TEMP
--
CREATE TEMP TABLE reset_test ( data text ) ON COMMIT DELETE ROWS;
CREATE TABLE
SELECT relname FROM pg_class WHERE relname = 'reset_test';
  relname   
------------
 reset_test
(1 row)

DISCARD TEMP;
DISCARD TEMP
SELECT relname FROM pg_class WHERE relname = 'reset_test';
 relname 
---------
(0 rows)

--
-- Test DISCARD ALL
--
-- do changes
DECLARE foo CURSOR WITH HOLD FOR SELECT 1;
DECLARE CURSOR
PREPARE foo AS SELECT 1;
PREPARE
LISTEN foo_event;
LISTEN
SET vacuum_cost_delay = 13;
SET
CREATE TEMP TABLE tmp_foo (data text) ON COMMIT DELETE ROWS;
CREATE TABLE
CREATE ROLE regress_guc_user;
CREATE ROLE
SET SESSION AUTHORIZATION regress_guc_user;
SET
-- look changes
SELECT pg_listening_channels();
 pg_listening_channels 
-----------------------
 foo_event
(1 row)

SELECT name FROM pg_prepared_statements;
 name 
------
 foo
(1 row)

SELECT name FROM pg_cursors;
 name 
------
 foo
(1 row)

SHOW vacuum_cost_delay;
 vacuum_cost_delay 
-------------------
 13ms
(1 row)

SELECT relname from pg_class where relname = 'tmp_foo';
 relname 
---------
 tmp_foo
(1 row)

SELECT current_user = 'regress_guc_user';
 ?column? 
----------
 t
(1 row)

-- discard everything
DISCARD ALL;
DISCARD ALL
-- look again
SELECT pg_listening_channels();
 pg_listening_channels 
-----------------------
(0 rows)

SELECT name FROM pg_prepared_statements;
 name 
------
(0 rows)

SELECT name FROM pg_cursors;
 name 
------
(0 rows)

SHOW vacuum_cost_delay;
 vacuum_cost_delay 
-------------------
 0
(1 row)

SELECT relname from pg_class where relname = 'tmp_foo';
 relname 
---------
(0 rows)

SELECT current_user = 'regress_guc_user';
 ?column? 
----------
 f
(1 row)

DROP ROLE regress_guc_user;
DROP ROLE
--
-- search_path should react to changes in pg_namespace
--
set search_path = foo, public, not_there_initially;
SET
select current_schemas(false);
 current_schemas 
-----------------
 {public}
(1 row)

create schema not_there_initially;
CREATE SCHEMA
select current_schemas(false);
       current_schemas        
------------------------------
 {public,not_there_initially}
(1 row)

drop schema not_there_initially;
DROP SCHEMA
select current_schemas(false);
 current_schemas 
-----------------
 {public}
(1 row)

reset search_path;
RESET
--
-- Tests for function-local GUC settings
--
set work_mem = '3MB';
SET
create function report_guc(text) returns text as
$$ select current_setting($1) $$ language sql
set work_mem = '1MB';
CREATE FUNCTION
select report_guc('work_mem'), current_setting('work_mem');
 report_guc | current_setting 
------------+-----------------
 1MB        | 3MB
(1 row)

alter function report_guc(text) set work_mem = '2MB';
ALTER FUNCTION
select report_guc('work_mem'), current_setting('work_mem');
 report_guc | current_setting 
------------+-----------------
 2MB        | 3MB
(1 row)

alter function report_guc(text) reset all;
ALTER FUNCTION
select report_guc('work_mem'), current_setting('work_mem');
 report_guc | current_setting 
------------+-----------------
 3MB        | 3MB
(1 row)

-- SET LOCAL is restricted by a function SET option
create or replace function myfunc(int) returns text as $$
begin
  set local work_mem = '2MB';
  return current_setting('work_mem');
end $$
language plpgsql
set work_mem = '1MB';
CREATE FUNCTION
select myfunc(0), current_setting('work_mem');
 myfunc | current_setting 
--------+-----------------
 2MB    | 3MB
(1 row)

alter function myfunc(int) reset all;
ALTER FUNCTION
select myfunc(0), current_setting('work_mem');
 myfunc | current_setting 
--------+-----------------
 2MB    | 2MB
(1 row)

set work_mem = '3MB';
SET
-- but SET isn't
create or replace function myfunc(int) returns text as $$
begin
  set work_mem = '2MB';
  return current_setting('work_mem');
end $$
language plpgsql
set work_mem = '1MB';
CREATE FUNCTION
select myfunc(0), current_setting('work_mem');
 myfunc | current_setting 
--------+-----------------
 2MB    | 2MB
(1 row)

set work_mem = '3MB';
SET
-- it should roll back on error, though
create or replace function myfunc(int) returns text as $$
begin
  set work_mem = '2MB';
  perform 1/$1;
  return current_setting('work_mem');
end $$
language plpgsql
set work_mem = '1MB';
CREATE FUNCTION
select myfunc(0);
psql:sql/guc.sql:260: ERROR:  division by zero
CONTEXT:  SQL statement "SELECT 1/$1"
PL/pgSQL function myfunc(integer) line 4 at PERFORM
select current_setting('work_mem');
 current_setting 
-----------------
 3MB
(1 row)

select myfunc(1), current_setting('work_mem');
 myfunc | current_setting 
--------+-----------------
 2MB    | 2MB
(1 row)

-- check current_setting()'s behavior with invalid setting name
select current_setting('nosuch.setting');  -- FAIL
psql:sql/guc.sql:266: ERROR:  unrecognized configuration parameter "nosuch.setting"
select current_setting('nosuch.setting', false);  -- FAIL
psql:sql/guc.sql:267: ERROR:  unrecognized configuration parameter "nosuch.setting"
select current_setting('nosuch.setting', true) is null;
 ?column? 
----------
 t
(1 row)

-- after this, all three cases should yield 'nada'
set nosuch.setting = 'nada';
SET
select current_setting('nosuch.setting');
 current_setting 
-----------------
 nada
(1 row)

select current_setting('nosuch.setting', false);
 current_setting 
-----------------
 nada
(1 row)

select current_setting('nosuch.setting', true);
 current_setting 
-----------------
 nada
(1 row)

-- Normally, CREATE FUNCTION should complain about invalid values in
-- function SET options; but not if check_function_bodies is off,
-- because that creates ordering hazards for pg_dump
create function func_with_bad_set() returns int as $$ select 1 $$
language sql
set default_text_search_config = no_such_config;
psql:sql/guc.sql:283: NOTICE:  text search configuration "no_such_config" does not exist
psql:sql/guc.sql:283: ERROR:  invalid value for parameter "default_text_search_config": "no_such_config"
set check_function_bodies = off;
SET
create function func_with_bad_set() returns int as $$ select 1 $$
language sql
set default_text_search_config = no_such_config;
psql:sql/guc.sql:289: NOTICE:  text search configuration "no_such_config" does not exist
CREATE FUNCTION
select func_with_bad_set();
psql:sql/guc.sql:291: ERROR:  invalid value for parameter "default_text_search_config": "no_such_config"
reset check_function_bodies;
RESET
