--
-- insert with DEFAULT in the target_list
--
drop table if exists inserttest;
psql:sql/insert.sql:4: NOTICE:  table "inserttest" does not exist, skipping
DROP TABLE
create table inserttest (col1 int4, col2 int4 NOT NULL, col3 text default 'testing');
CREATE TABLE
insert into inserttest (col1, col2, col3) values (DEFAULT, DEFAULT, DEFAULT);
psql:sql/insert.sql:6: ERROR:  Kunlun-db: MySQL storage node (1, 1) returned error: 1048, Column 'col2' cannot be null.
insert into inserttest (col2, col3) values (3, DEFAULT);
INSERT 0 1
insert into inserttest (col1, col2, col3) values (DEFAULT, 5, DEFAULT);
INSERT 0 1
insert into inserttest values (DEFAULT, 5, 'test');
INSERT 0 1
insert into inserttest values (DEFAULT, 7);
INSERT 0 1
select * from inserttest;
 col1 | col2 |  col3   
------+------+---------
      |    3 | testing
      |    5 | testing
      |    5 | test
      |    7 | testing
(4 rows)

--
-- insert with similar expression / target_list values (all fail)
--
insert into inserttest (col1, col2, col3) values (DEFAULT, DEFAULT);
psql:sql/insert.sql:17: ERROR:  INSERT has more target columns than expressions
LINE 1: insert into inserttest (col1, col2, col3) values (DEFAULT, D...
                                            ^
insert into inserttest (col1, col2, col3) values (1, 2);
psql:sql/insert.sql:18: ERROR:  INSERT has more target columns than expressions
LINE 1: insert into inserttest (col1, col2, col3) values (1, 2);
                                            ^
insert into inserttest (col1) values (1, 2);
psql:sql/insert.sql:19: ERROR:  INSERT has more expressions than target columns
LINE 1: insert into inserttest (col1) values (1, 2);
                                                 ^
insert into inserttest (col1) values (DEFAULT, DEFAULT);
psql:sql/insert.sql:20: ERROR:  INSERT has more expressions than target columns
LINE 1: insert into inserttest (col1) values (DEFAULT, DEFAULT);
                                                       ^
select * from inserttest;
 col1 | col2 |  col3   
------+------+---------
      |    3 | testing
      |    5 | testing
      |    5 | test
      |    7 | testing
(4 rows)

--
-- VALUES test
--
insert into inserttest values(10, 20, '40'), (-1, 2, DEFAULT),
    ((select 2), (select i from (values(3)) as foo (i)), 'values are fun!');
INSERT 0 3
select * from inserttest;
 col1 | col2 |      col3       
------+------+-----------------
      |    3 | testing
      |    5 | testing
      |    5 | test
      |    7 | testing
   10 |   20 | 40
   -1 |    2 | testing
    2 |    3 | values are fun!
(7 rows)

--
-- TOASTed value test
--
insert into inserttest values(30, 50, repeat('x', 10000));
INSERT 0 1
select col1, col2, char_length(col3) from inserttest;
 col1 | col2 | char_length 
------+------+-------------
      |    3 |           7
      |    5 |           7
      |    5 |           4
      |    7 |           7
   10 |   20 |           2
   -1 |    2 |           7
    2 |    3 |          15
   30 |   50 |       10000
(8 rows)

drop table inserttest;
DROP TABLE
-- direct partition inserts should check partition bound constraint
drop table if exists range_parted;
psql:sql/insert.sql:41: NOTICE:  table "range_parted" does not exist, skipping
DROP TABLE
drop table if exists part1;
psql:sql/insert.sql:42: NOTICE:  table "part1" does not exist, skipping
DROP TABLE
drop table if exists part2;
psql:sql/insert.sql:43: NOTICE:  table "part2" does not exist, skipping
DROP TABLE
drop table if exists part3;
psql:sql/insert.sql:44: NOTICE:  table "part3" does not exist, skipping
DROP TABLE
drop table if exists part4;
psql:sql/insert.sql:45: NOTICE:  table "part4" does not exist, skipping
DROP TABLE
create table range_parted (
	a text,
	b int
) partition by range (a, (b+0));
CREATE TABLE
-- no partitions, so fail
insert into range_parted values ('a', 11);
psql:sql/insert.sql:52: ERROR:  no partition of relation "range_parted" found for row
DETAIL:  Partition key of the failing row contains (a, (b + 0)) = (a, 11).
create table part1 partition of range_parted for values from ('a', 1) to ('a', 10);
CREATE TABLE
create table part2 partition of range_parted for values from ('a', 10) to ('a', 20);
CREATE TABLE
create table part3 partition of range_parted for values from ('b', 1) to ('b', 10);
CREATE TABLE
create table part4 partition of range_parted for values from ('b', 10) to ('b', 20);
CREATE TABLE
-- fail
insert into part1 values ('a', 11);
psql:sql/insert.sql:60: ERROR:  new row for relation "part1" violates partition constraint
DETAIL:  Failing row contains (a, 11).
insert into part1 values ('b', 1);
psql:sql/insert.sql:61: ERROR:  new row for relation "part1" violates partition constraint
DETAIL:  Failing row contains (b, 1).
-- ok
insert into part1 values ('a', 1);
INSERT 0 1
-- fail
insert into part4 values ('b', 21);
psql:sql/insert.sql:65: ERROR:  new row for relation "part4" violates partition constraint
DETAIL:  Failing row contains (b, 21).
insert into part4 values ('a', 10);
psql:sql/insert.sql:66: ERROR:  new row for relation "part4" violates partition constraint
DETAIL:  Failing row contains (a, 10).
-- ok
insert into part4 values ('b', 10);
INSERT 0 1
-- fail (partition key a has a NOT NULL constraint)
insert into part1 values (null);
psql:sql/insert.sql:71: ERROR:  new row for relation "part1" violates partition constraint
DETAIL:  Failing row contains (null, null).
-- fail (expression key (b+0) cannot be null either)
insert into part1 values (1);
psql:sql/insert.sql:73: ERROR:  new row for relation "part1" violates partition constraint
DETAIL:  Failing row contains (1, null).
drop table if exists list_parted;
psql:sql/insert.sql:75: NOTICE:  table "list_parted" does not exist, skipping
DROP TABLE
create table list_parted (
	a text,
	b int
) partition by list (lower(a));
CREATE TABLE
create table part_aa_bb partition of list_parted FOR VALUES IN ('aa', 'bb');
CREATE TABLE
create table part_cc_dd partition of list_parted FOR VALUES IN ('cc', 'dd');
CREATE TABLE
create table part_null partition of list_parted FOR VALUES IN (null);
CREATE TABLE
-- fail
insert into part_aa_bb values ('cc', 1);
psql:sql/insert.sql:85: ERROR:  new row for relation "part_aa_bb" violates partition constraint
DETAIL:  Failing row contains (cc, 1).
insert into part_aa_bb values ('AAa', 1);
psql:sql/insert.sql:86: ERROR:  new row for relation "part_aa_bb" violates partition constraint
DETAIL:  Failing row contains (AAa, 1).
insert into part_aa_bb values (null);
psql:sql/insert.sql:87: ERROR:  new row for relation "part_aa_bb" violates partition constraint
DETAIL:  Failing row contains (null, null).
-- ok
insert into part_cc_dd values ('cC', 1);
INSERT 0 1
insert into part_null values (null, 0);
INSERT 0 1
-- check in case of multi-level partitioned table
create table part_ee_ff partition of list_parted for values in ('ee', 'ff') partition by range (b);
CREATE TABLE
create table part_ee_ff1 partition of part_ee_ff for values from (1) to (10);
CREATE TABLE
create table part_ee_ff2 partition of part_ee_ff for values from (10) to (20);
CREATE TABLE
create table part_xx_yy partition of list_parted for values in ('xx', 'yy') partition by list (a);
CREATE TABLE
create table part_xx_yy_p1 partition of part_xx_yy for values in ('xx');
CREATE TABLE
-- fail
insert into part_ee_ff1 values ('EE', 11);
psql:sql/insert.sql:101: ERROR:  new row for relation "part_ee_ff1" violates partition constraint
DETAIL:  Failing row contains (EE, 11).
-- fail (even the parent's, ie, part_ee_ff's partition constraint applies)
insert into part_ee_ff1 values ('cc', 1);
psql:sql/insert.sql:103: ERROR:  new row for relation "part_ee_ff1" violates partition constraint
DETAIL:  Failing row contains (cc, 1).
-- ok
insert into part_ee_ff1 values ('ff', 1);
INSERT 0 1
insert into part_ee_ff2 values ('ff', 11);
INSERT 0 1
insert into list_parted values ('ab', 21);
psql:sql/insert.sql:107: ERROR:  no partition of relation "list_parted" found for row
DETAIL:  Partition key of the failing row contains (lower(a)) = (ab).
insert into list_parted values ('xx', 1);
INSERT 0 1
insert into list_parted values ('yy', 2);
psql:sql/insert.sql:109: ERROR:  no partition of relation "part_xx_yy" found for row
DETAIL:  Partition key of the failing row contains (a) = (yy).
-- Check tuple routing for partitioned tables
-- fail
insert into range_parted values ('a', 0);
psql:sql/insert.sql:114: ERROR:  no partition of relation "range_parted" found for row
DETAIL:  Partition key of the failing row contains (a, (b + 0)) = (a, 0).
-- ok
insert into range_parted values ('a', 1);
INSERT 0 1
insert into range_parted values ('a', 10);
INSERT 0 1
-- fail
insert into range_parted values ('a', 20);
psql:sql/insert.sql:119: ERROR:  no partition of relation "range_parted" found for row
DETAIL:  Partition key of the failing row contains (a, (b + 0)) = (a, 20).
-- ok
insert into range_parted values ('b', 1);
INSERT 0 1
insert into range_parted values ('b', 10);
INSERT 0 1
-- fail (partition key (b+0) is null)
insert into range_parted values ('a');
psql:sql/insert.sql:124: ERROR:  no partition of relation "range_parted" found for row
DETAIL:  Partition key of the failing row contains (a, (b + 0)) = (a, null).
insert into range_parted values (null, null);
psql:sql/insert.sql:126: ERROR:  no partition of relation "range_parted" found for row
DETAIL:  Partition key of the failing row contains (a, (b + 0)) = (null, null).
insert into range_parted values ('a', null);
psql:sql/insert.sql:127: ERROR:  no partition of relation "range_parted" found for row
DETAIL:  Partition key of the failing row contains (a, (b + 0)) = (a, null).
insert into range_parted values (null, 19);
psql:sql/insert.sql:128: ERROR:  no partition of relation "range_parted" found for row
DETAIL:  Partition key of the failing row contains (a, (b + 0)) = (null, 19).
insert into range_parted values ('b', 20);
psql:sql/insert.sql:129: ERROR:  no partition of relation "range_parted" found for row
DETAIL:  Partition key of the failing row contains (a, (b + 0)) = (b, 20).
-- ok
insert into list_parted values (null, 1);
INSERT 0 1
insert into list_parted (a) values ('aA');
INSERT 0 1
-- fail (partition of part_ee_ff not found in both cases)
insert into list_parted values ('EE', 0);
psql:sql/insert.sql:135: ERROR:  no partition of relation "part_ee_ff" found for row
DETAIL:  Partition key of the failing row contains (b) = (0).
insert into part_ee_ff values ('EE', 0);
psql:sql/insert.sql:136: ERROR:  no partition of relation "part_ee_ff" found for row
DETAIL:  Partition key of the failing row contains (b) = (0).
-- ok
insert into list_parted values ('EE', 1);
INSERT 0 1
insert into part_ee_ff values ('EE', 10);
INSERT 0 1
-- some more tests to exercise tuple-routing with multi-level partitioning
create table part_gg partition of list_parted for values in ('gg') partition by range (b);
CREATE TABLE
create table part_gg1 partition of part_gg for values from (minvalue) to (1);
CREATE TABLE
create table part_gg2 partition of part_gg for values from (1) to (10) partition by range (b);
CREATE TABLE
create table part_gg2_1 partition of part_gg2 for values from (1) to (5);
CREATE TABLE
create table part_gg2_2 partition of part_gg2 for values from (5) to (10);
CREATE TABLE
create table part_ee_ff3 partition of part_ee_ff for values from (20) to (30) partition by range (b);
CREATE TABLE
create table part_ee_ff3_1 partition of part_ee_ff3 for values from (20) to (25);
CREATE TABLE
create table part_ee_ff3_2 partition of part_ee_ff3 for values from (25) to (30);
CREATE TABLE
delete from list_parted;
DELETE 9
insert into list_parted values ('aa'), ('cc');
INSERT 0 2
insert into list_parted select 'Ff', s.a from generate_series(1, 29) s(a);
INSERT 0 29
insert into list_parted select 'gg', s.a from generate_series(1, 9) s(a);
INSERT 0 9
insert into list_parted (b) values (1);
INSERT 0 1
-- direct partition inserts should check hash partition bound constraint
-- Use hand-rolled hash functions and operator classes to get predictable
-- result on different matchines.  The hash function for int4 simply returns
-- the sum of the values passed to it and the one for text returns the length
-- of the non-empty string value passed to it or 0.
create or replace function part_hashint4_noop(value int4, seed int8)
returns int8 as $$
select value + seed;
$$ language sql immutable;
CREATE FUNCTION
create operator class part_test_int4_ops
for type int4
using hash as
operator 1 =,
function 2 part_hashint4_noop(int4, int8);
CREATE OPERATOR CLASS
create or replace function part_hashtext_length(value text, seed int8)
RETURNS int8 AS $$
select length(coalesce(value, ''))::int8
$$ language sql immutable;
CREATE FUNCTION
create operator class part_test_text_ops
for type text
using hash as
operator 1 =,
function 2 part_hashtext_length(text, int8);
CREATE OPERATOR CLASS
drop table if exists hash_parted;
psql:sql/insert.sql:187: NOTICE:  table "hash_parted" does not exist, skipping
DROP TABLE
create table hash_parted (
	a int
) partition by hash (a part_test_int4_ops);
CREATE TABLE
create table hpart0 partition of hash_parted for values with (modulus 4, remainder 0);
CREATE TABLE
create table hpart1 partition of hash_parted for values with (modulus 4, remainder 1);
CREATE TABLE
create table hpart2 partition of hash_parted for values with (modulus 4, remainder 2);
CREATE TABLE
create table hpart3 partition of hash_parted for values with (modulus 4, remainder 3);
CREATE TABLE
insert into hash_parted values(generate_series(1,10));
INSERT 0 10
-- direct insert of values divisible by 4 - ok;
insert into hpart0 values(12),(16);
INSERT 0 2
-- fail;
insert into hpart0 values(11);
psql:sql/insert.sql:201: ERROR:  new row for relation "hpart0" violates partition constraint
DETAIL:  Failing row contains (11).
-- 11 % 4 -> 3 remainder i.e. valid data for hpart3 partition
insert into hpart3 values(11);
INSERT 0 1
-- test \d+ output on a table which has both partitioned and unpartitioned
-- partitions
\d+ list_parted
                                Table "public.list_parted"
 Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
--------+---------+-----------+----------+---------+----------+--------------+-------------
 a      | text    |           |          |         | extended |              | 
 b      | integer |           |          |         | plain    |              | 
Partition key: LIST (lower(a))
Partitions: part_aa_bb FOR VALUES IN ('aa', 'bb'),
            part_cc_dd FOR VALUES IN ('cc', 'dd'),
            part_ee_ff FOR VALUES IN ('ee', 'ff'), PARTITIONED,
            part_gg FOR VALUES IN ('gg'), PARTITIONED,
            part_null FOR VALUES IN (NULL),
            part_xx_yy FOR VALUES IN ('xx', 'yy'), PARTITIONED

-- cleanup
drop table range_parted;
DROP TABLE
drop table list_parted;
DROP TABLE
drop table hash_parted;
DROP TABLE
-- check routing error through a list partitioned table when the key is null
create table lparted_nonullpart (a int, b char) partition by list (b);
CREATE TABLE
create table lparted_nonullpart_a partition of lparted_nonullpart for values in ('a');
CREATE TABLE
insert into lparted_nonullpart values (1);
psql:sql/insert.sql:217: ERROR:  no partition of relation "lparted_nonullpart" found for row
DETAIL:  Partition key of the failing row contains (b) = (null).
drop table lparted_nonullpart;
DROP TABLE
-- check that message shown after failure to find a partition shows the
-- appropriate key description (or none) in various situations
create table key_desc (a int, b int) partition by list ((a+0));
CREATE TABLE
create table key_desc_1 partition of key_desc for values in (1) partition by range (b);
CREATE TABLE
create user regress_insert_other_user;
CREATE ROLE
grant select (a) on key_desc_1 to regress_insert_other_user;
GRANT
grant insert on key_desc to regress_insert_other_user;
GRANT
set role regress_insert_other_user;
SET
-- no key description is shown
insert into key_desc values (1, 1);
psql:sql/insert.sql:231: ERROR:  no partition of relation "key_desc_1" found for row
reset role;
RESET
grant select (b) on key_desc_1 to regress_insert_other_user;
GRANT
set role regress_insert_other_user;
SET
-- key description (b)=(1) is now shown
insert into key_desc values (1, 1);
psql:sql/insert.sql:237: ERROR:  no partition of relation "key_desc_1" found for row
DETAIL:  Partition key of the failing row contains (b) = (1).
-- key description is not shown if key contains expression
insert into key_desc values (2, 1);
psql:sql/insert.sql:240: ERROR:  no partition of relation "key_desc" found for row
reset role;
RESET
revoke all on key_desc from regress_insert_other_user;
REVOKE
revoke all on key_desc_1 from regress_insert_other_user;
REVOKE
drop role regress_insert_other_user;
DROP ROLE
drop table key_desc;
DROP TABLE
drop table key_desc_1;
psql:sql/insert.sql:246: ERROR:  table "key_desc_1" does not exist
-- test minvalue/maxvalue restrictions
create table mcrparted (a int, b int, c int) partition by range (a, abs(b), c);
CREATE TABLE
create table mcrparted0 partition of mcrparted for values from (minvalue, 0, 0) to (1, maxvalue, maxvalue);
psql:sql/insert.sql:250: ERROR:  every bound following MINVALUE must also be MINVALUE
LINE 1: ...partition of mcrparted for values from (minvalue, 0, 0) to (...
                                                             ^
create table mcrparted2 partition of mcrparted for values from (10, 6, minvalue) to (10, maxvalue, minvalue);
psql:sql/insert.sql:251: ERROR:  every bound following MAXVALUE must also be MAXVALUE
LINE 1: ...r values from (10, 6, minvalue) to (10, maxvalue, minvalue);
                                                             ^
create table mcrparted4 partition of mcrparted for values from (21, minvalue, 0) to (30, 20, minvalue);
psql:sql/insert.sql:252: ERROR:  every bound following MINVALUE must also be MINVALUE
LINE 1: ...ition of mcrparted for values from (21, minvalue, 0) to (30,...
                                                             ^
-- check multi-column range partitioning expression enforces the same
-- constraint as what tuple-routing would determine it to be
create table mcrparted0 partition of mcrparted for values from (minvalue, minvalue, minvalue) to (1, maxvalue, maxvalue);
CREATE TABLE
create table mcrparted1 partition of mcrparted for values from (2, 1, minvalue) to (10, 5, 10);
CREATE TABLE
create table mcrparted2 partition of mcrparted for values from (10, 6, minvalue) to (10, maxvalue, maxvalue);
CREATE TABLE
create table mcrparted3 partition of mcrparted for values from (11, 1, 1) to (20, 10, 10);
CREATE TABLE
create table mcrparted4 partition of mcrparted for values from (21, minvalue, minvalue) to (30, 20, maxvalue);
CREATE TABLE
create table mcrparted5 partition of mcrparted for values from (30, 21, 20) to (maxvalue, maxvalue, maxvalue);
CREATE TABLE
-- null not allowed in range partition
insert into mcrparted values (null, null, null);
psql:sql/insert.sql:264: ERROR:  no partition of relation "mcrparted" found for row
DETAIL:  Partition key of the failing row contains (a, abs(b), c) = (null, null, null).
-- routed to mcrparted0
insert into mcrparted values (0, 1, 1);
INSERT 0 1
insert into mcrparted0 values (0, 1, 1);
INSERT 0 1
-- routed to mcparted1
insert into mcrparted values (9, 1000, 1);
INSERT 0 1
insert into mcrparted1 values (9, 1000, 1);
INSERT 0 1
insert into mcrparted values (10, 5, -1);
INSERT 0 1
insert into mcrparted1 values (10, 5, -1);
INSERT 0 1
insert into mcrparted values (2, 1, 0);
INSERT 0 1
insert into mcrparted1 values (2, 1, 0);
INSERT 0 1
-- routed to mcparted2
insert into mcrparted values (10, 6, 1000);
INSERT 0 1
insert into mcrparted2 values (10, 6, 1000);
INSERT 0 1
insert into mcrparted values (10, 1000, 1000);
INSERT 0 1
insert into mcrparted2 values (10, 1000, 1000);
INSERT 0 1
-- no partition exists, nor does mcrparted3 accept it
insert into mcrparted values (11, 1, -1);
psql:sql/insert.sql:285: ERROR:  no partition of relation "mcrparted" found for row
DETAIL:  Partition key of the failing row contains (a, abs(b), c) = (11, 1, -1).
insert into mcrparted3 values (11, 1, -1);
psql:sql/insert.sql:286: ERROR:  new row for relation "mcrparted3" violates partition constraint
DETAIL:  Failing row contains (11, 1, -1).
-- routed to mcrparted5
insert into mcrparted values (30, 21, 20);
INSERT 0 1
insert into mcrparted5 values (30, 21, 20);
INSERT 0 1
insert into mcrparted4 values (30, 21, 20);	-- error
psql:sql/insert.sql:291: ERROR:  new row for relation "mcrparted4" violates partition constraint
DETAIL:  Failing row contains (30, 21, 20).
-- cleanup
drop table mcrparted;
DROP TABLE
-- check that a BR constraint can't make partition contain violating rows
create table brtrigpartcon (a int, b text) partition by list (a);
CREATE TABLE
create table brtrigpartcon1 partition of brtrigpartcon for values in (1);
CREATE TABLE
insert into brtrigpartcon values (1, 'hi there');
INSERT 0 1
insert into brtrigpartcon1 values (1, 'hi there');
INSERT 0 1
-- check that the message shows the appropriate column description in a
-- situation where the partitioned table is not the primary ModifyTable node
create table inserttest3 (f1 text default 'foo', f2 text default 'bar', f3 int);
CREATE TABLE
create role regress_coldesc_role;
CREATE ROLE
grant insert on inserttest3 to regress_coldesc_role;
GRANT
grant insert on brtrigpartcon to regress_coldesc_role;
GRANT
revoke select on brtrigpartcon from regress_coldesc_role;
REVOKE
set role regress_coldesc_role;
SET
with result as (insert into brtrigpartcon values (1, 'hi there') returning 1)
  insert into inserttest3 (f3) select * from result;
INSERT 0 2
reset role;
RESET
-- cleanup
revoke all on inserttest3 from regress_coldesc_role;
REVOKE
revoke all on brtrigpartcon from regress_coldesc_role;
REVOKE
drop role regress_coldesc_role;
DROP ROLE
drop table inserttest3;
DROP TABLE
drop table brtrigpartcon;
DROP TABLE
-- check that "do nothing" BR triggers work with tuple-routing (this checks
-- that estate->es_result_relation_info is appropriately set/reset for each
-- routed tuple)
create table donothingbrtrig_test (a int, b text) partition by list (a);
CREATE TABLE
create table donothingbrtrig_test1 (b text, a int);
CREATE TABLE
create table donothingbrtrig_test2 (c text, b text, a int);
CREATE TABLE
alter table donothingbrtrig_test2 drop column c;
ALTER TABLE
create or replace function donothingbrtrig_func() returns trigger as $$begin raise notice 'b: %', new.b; return NULL; end$$ language plpgsql;
CREATE FUNCTION
--create trigger donothingbrtrig1 before insert on donothingbrtrig_test1 for each row execute procedure donothingbrtrig_func();
--create trigger donothingbrtrig2 before insert on donothingbrtrig_test2 for each row execute procedure donothingbrtrig_func();
--alter table donothingbrtrig_test attach partition donothingbrtrig_test1 for values in (1);
--alter table donothingbrtrig_test attach partition donothingbrtrig_test2 for values in (2);
--insert into donothingbrtrig_test values (1, 'foo'), (2, 'bar');
copy donothingbrtrig_test from stdout;
psql:sql/insert.sql:337: ERROR:  no partition of relation "donothingbrtrig_test" found for row
DETAIL:  Partition key of the failing row contains (a) = (1).
CONTEXT:  COPY donothingbrtrig_test, line 1: "1	baz"
select tableoid::regclass, * from donothingbrtrig_test;
 tableoid | a | b 
----------+---+---
(0 rows)

-- cleanup
drop table donothingbrtrig_test;
DROP TABLE
drop function donothingbrtrig_func();
DROP FUNCTION
-- check multi-column range partitioning with minvalue/maxvalue constraints
create table mcrparted (a text, b int) partition by range(a, b);
CREATE TABLE
create table mcrparted1_lt_b partition of mcrparted for values from (minvalue, minvalue) to ('b', minvalue);
CREATE TABLE
create table mcrparted2_b partition of mcrparted for values from ('b', minvalue) to ('c', minvalue);
CREATE TABLE
create table mcrparted3_c_to_common partition of mcrparted for values from ('c', minvalue) to ('common', minvalue);
CREATE TABLE
create table mcrparted4_common_lt_0 partition of mcrparted for values from ('common', minvalue) to ('common', 0);
CREATE TABLE
create table mcrparted5_common_0_to_10 partition of mcrparted for values from ('common', 0) to ('common', 10);
CREATE TABLE
create table mcrparted6_common_ge_10 partition of mcrparted for values from ('common', 10) to ('common', maxvalue);
CREATE TABLE
create table mcrparted7_gt_common_lt_d partition of mcrparted for values from ('common', maxvalue) to ('d', minvalue);
CREATE TABLE
create table mcrparted8_ge_d partition of mcrparted for values from ('d', minvalue) to (maxvalue, maxvalue);
CREATE TABLE
\d+ mcrparted
                                 Table "public.mcrparted"
 Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
--------+---------+-----------+----------+---------+----------+--------------+-------------
 a      | text    |           |          |         | extended |              | 
 b      | integer |           |          |         | plain    |              | 
Partition key: RANGE (a, b)
Partitions: mcrparted1_lt_b FOR VALUES FROM (MINVALUE, MINVALUE) TO ('b', MINVALUE),
            mcrparted2_b FOR VALUES FROM ('b', MINVALUE) TO ('c', MINVALUE),
            mcrparted3_c_to_common FOR VALUES FROM ('c', MINVALUE) TO ('common', MINVALUE),
            mcrparted4_common_lt_0 FOR VALUES FROM ('common', MINVALUE) TO ('common', 0),
            mcrparted5_common_0_to_10 FOR VALUES FROM ('common', 0) TO ('common', 10),
            mcrparted6_common_ge_10 FOR VALUES FROM ('common', 10) TO ('common', MAXVALUE),
            mcrparted7_gt_common_lt_d FOR VALUES FROM ('common', MAXVALUE) TO ('d', MINVALUE),
            mcrparted8_ge_d FOR VALUES FROM ('d', MINVALUE) TO (MAXVALUE, MAXVALUE)

\d+ mcrparted1_lt_b
                              Table "public.mcrparted1_lt_b"
 Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
--------+---------+-----------+----------+---------+----------+--------------+-------------
 a      | text    |           |          |         | extended |              | 
 b      | integer |           |          |         | plain    |              | 
Partition of: mcrparted FOR VALUES FROM (MINVALUE, MINVALUE) TO ('b', MINVALUE)
Partition constraint: ((a IS NOT NULL) AND (b IS NOT NULL) AND (a < 'b'::text))
Options: shard=1

\d+ mcrparted2_b
                                Table "public.mcrparted2_b"
 Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
--------+---------+-----------+----------+---------+----------+--------------+-------------
 a      | text    |           |          |         | extended |              | 
 b      | integer |           |          |         | plain    |              | 
Partition of: mcrparted FOR VALUES FROM ('b', MINVALUE) TO ('c', MINVALUE)
Partition constraint: ((a IS NOT NULL) AND (b IS NOT NULL) AND (a >= 'b'::text) AND (a < 'c'::text))
Options: shard=1

\d+ mcrparted3_c_to_common
                           Table "public.mcrparted3_c_to_common"
 Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
--------+---------+-----------+----------+---------+----------+--------------+-------------
 a      | text    |           |          |         | extended |              | 
 b      | integer |           |          |         | plain    |              | 
Partition of: mcrparted FOR VALUES FROM ('c', MINVALUE) TO ('common', MINVALUE)
Partition constraint: ((a IS NOT NULL) AND (b IS NOT NULL) AND (a >= 'c'::text) AND (a < 'common'::text))
Options: shard=1

\d+ mcrparted4_common_lt_0
                           Table "public.mcrparted4_common_lt_0"
 Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
--------+---------+-----------+----------+---------+----------+--------------+-------------
 a      | text    |           |          |         | extended |              | 
 b      | integer |           |          |         | plain    |              | 
Partition of: mcrparted FOR VALUES FROM ('common', MINVALUE) TO ('common', 0)
Partition constraint: ((a IS NOT NULL) AND (b IS NOT NULL) AND (a = 'common'::text) AND (b < 0))
Options: shard=1

\d+ mcrparted5_common_0_to_10
                         Table "public.mcrparted5_common_0_to_10"
 Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
--------+---------+-----------+----------+---------+----------+--------------+-------------
 a      | text    |           |          |         | extended |              | 
 b      | integer |           |          |         | plain    |              | 
Partition of: mcrparted FOR VALUES FROM ('common', 0) TO ('common', 10)
Partition constraint: ((a IS NOT NULL) AND (b IS NOT NULL) AND (a = 'common'::text) AND (b >= 0) AND (b < 10))
Options: shard=1

\d+ mcrparted6_common_ge_10
                          Table "public.mcrparted6_common_ge_10"
 Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
--------+---------+-----------+----------+---------+----------+--------------+-------------
 a      | text    |           |          |         | extended |              | 
 b      | integer |           |          |         | plain    |              | 
Partition of: mcrparted FOR VALUES FROM ('common', 10) TO ('common', MAXVALUE)
Partition constraint: ((a IS NOT NULL) AND (b IS NOT NULL) AND (a = 'common'::text) AND (b >= 10))
Options: shard=1

\d+ mcrparted7_gt_common_lt_d
                         Table "public.mcrparted7_gt_common_lt_d"
 Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
--------+---------+-----------+----------+---------+----------+--------------+-------------
 a      | text    |           |          |         | extended |              | 
 b      | integer |           |          |         | plain    |              | 
Partition of: mcrparted FOR VALUES FROM ('common', MAXVALUE) TO ('d', MINVALUE)
Partition constraint: ((a IS NOT NULL) AND (b IS NOT NULL) AND (a > 'common'::text) AND (a < 'd'::text))
Options: shard=1

\d+ mcrparted8_ge_d
                              Table "public.mcrparted8_ge_d"
 Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
--------+---------+-----------+----------+---------+----------+--------------+-------------
 a      | text    |           |          |         | extended |              | 
 b      | integer |           |          |         | plain    |              | 
Partition of: mcrparted FOR VALUES FROM ('d', MINVALUE) TO (MAXVALUE, MAXVALUE)
Partition constraint: ((a IS NOT NULL) AND (b IS NOT NULL) AND (a >= 'd'::text))
Options: shard=1

insert into mcrparted values ('aaa', 0), ('b', 0), ('bz', 10), ('c', -10),
    ('comm', -10), ('common', -10), ('common', 0), ('common', 10),
    ('commons', 0), ('d', -10), ('e', 0);
INSERT 0 11
drop table mcrparted;
DROP TABLE
-- check that wholerow vars in the RETURNING list work with partitioned tables
create table returningwrtest (a int) partition by list (a);
CREATE TABLE
create table returningwrtest1 partition of returningwrtest for values in (1);
CREATE TABLE
insert into returningwrtest values (1) returning returningwrtest;
 returningwrtest 
-----------------
 (1)
(1 row)

INSERT 0 1
