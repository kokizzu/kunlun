--
-- UPDATE syntax tests
--
drop table if exists update_test;
psql:sql/update.sql:4: NOTICE:  table "update_test" does not exist, skipping
DROP TABLE
CREATE TABLE update_test (
    a   INT DEFAULT 10,
    b   INT,
    c   TEXT
);
CREATE TABLE
drop table if exists upsert_test;
psql:sql/update.sql:11: NOTICE:  table "upsert_test" does not exist, skipping
DROP TABLE
CREATE TABLE upsert_test (
    a   INT PRIMARY KEY,
    b   TEXT
);
CREATE TABLE
INSERT INTO update_test VALUES (5, 10, 'foo');
INSERT 0 1
INSERT INTO update_test(b, a) VALUES (15, 10);
INSERT 0 1
SELECT * FROM update_test;
 a  | b  |  c  
----+----+-----
  5 | 10 | foo
 10 | 15 | 
(2 rows)

UPDATE update_test SET a = DEFAULT, b = DEFAULT;
UPDATE 2
SELECT * FROM update_test;
 a  | b |  c  
----+---+-----
 10 |   | foo
 10 |   | 
(2 rows)

-- aliases for the UPDATE target table
UPDATE update_test AS t SET b = 10 WHERE t.a = 10;
UPDATE 2
SELECT * FROM update_test;
 a  | b  |  c  
----+----+-----
 10 | 10 | foo
 10 | 10 | 
(2 rows)

UPDATE update_test t SET b = t.b + 10 WHERE t.a = 10;
UPDATE 2
SELECT * FROM update_test;
 a  | b  |  c  
----+----+-----
 10 | 20 | foo
 10 | 20 | 
(2 rows)

--
-- Test multiple-set-clause syntax
--
INSERT INTO update_test SELECT a,b+1,c FROM update_test;
INSERT 0 2
SELECT * FROM update_test;
 a  | b  |  c  
----+----+-----
 10 | 20 | foo
 10 | 20 | 
 10 | 21 | foo
 10 | 21 | 
(4 rows)

UPDATE update_test SET (c,b,a) = ('bugle', b+11, DEFAULT) WHERE c = 'foo';
UPDATE 2
SELECT * FROM update_test order by 1,2,3;
 a  | b  |   c   
----+----+-------
 10 | 20 | 
 10 | 21 | 
 10 | 31 | bugle
 10 | 32 | bugle
(4 rows)

UPDATE update_test SET (c,b) = ('car', a+b), a = a + 1 WHERE a = 10;
UPDATE 4
SELECT * FROM update_test order by 1,2,3;
 a  | b  |  c  
----+----+-----
 11 | 31 | car
 11 | 32 | car
 11 | 42 | car
 11 | 43 | car
(4 rows)

-- fail, multi assignment to same column:
UPDATE update_test SET (c,b) = ('car', a+b), b = a + 1 WHERE a = 10;
psql:sql/update.sql:47: ERROR:  multiple assignments to same column "b"
-- uncorrelated sub-select:
-- not supported: UPDATE update_test
--  SET (b,a) = (select a,b from update_test where b = 41 and c = 'car')
--  WHERE a = 100 AND b = 20;
--SELECT * FROM update_test order by 1,2,3;
-- correlated sub-select:
--UPDATE update_test o
--  SET (b,a) = (select a+1,b from update_test i
--               where i.a=o.a and i.b=o.b and i.c is not distinct from o.c);
--SELECT * FROM update_test order by 1,2,3;
-- fail, multiple rows supplied:
--UPDATE update_test SET (b,a) = (select a+1,b from update_test);
-- set to null if no rows supplied:
--UPDATE update_test SET (b,a) = (select a+1,b from update_test where a = 1000)
--  WHERE a = 11;
SELECT * FROM update_test order by 1,2,3;
 a  | b  |  c  
----+----+-----
 11 | 31 | car
 11 | 32 | car
 11 | 42 | car
 11 | 43 | car
(4 rows)

-- if an alias for the target table is specified, don't allow references
-- to the original table name
UPDATE update_test AS t SET b = update_test.b + 10 WHERE t.a = 10;
psql:sql/update.sql:68: ERROR:  invalid reference to FROM-clause entry for table "update_test"
LINE 1: UPDATE update_test AS t SET b = update_test.b + 10 WHERE t.a...
                                        ^
HINT:  Perhaps you meant to reference the table alias "t".
-- Make sure that we can update to a TOASTed value.
UPDATE update_test SET c = repeat('x', 10000) WHERE c = 'car';
UPDATE 4
SELECT a, b, char_length(c) FROM update_test;
 a  | b  | char_length 
----+----+-------------
 11 | 42 |       10000
 11 | 31 |       10000
 11 | 43 |       10000
 11 | 32 |       10000
(4 rows)

-- Check multi-assignment with a Result node to handle a one-time filter.
EXPLAIN (VERBOSE, COSTS OFF)
UPDATE update_test t
  SET (a, b) = (SELECT b, a FROM update_test s WHERE s.a = t.a)
  WHERE CURRENT_USER = SESSION_USER;

--not support: UPDATE update_test t
--  SET (a, b) = (SELECT b, a FROM update_test s WHERE s.a = t.a)
--  WHERE CURRENT_USER = SESSION_USER;
SELECT a, b, char_length(c) FROM update_test order by 1,2,3;
 a  | b  | char_length 
----+----+-------------
 11 | 31 |       10000
 11 | 32 |       10000
 11 | 42 |       10000
 11 | 43 |       10000
(4 rows)

DROP TABLE update_test;
DROP TABLE
DROP TABLE upsert_test;
DROP TABLE
---------------------------
-- UPDATE with row movement
---------------------------
-- When a partitioned table receives an UPDATE to the partitioned key and the
-- new values no longer meet the partition's bound, the row must be moved to
-- the correct partition for the new partition key (if one exists). We must
-- also ensure that updatable views on partitioned tables properly enforce any
-- WITH CHECK OPTION that is defined. 
drop table if exists range_parted cascade;
psql:sql/update.sql:98: NOTICE:  table "range_parted" does not exist, skipping
DROP TABLE
CREATE TABLE range_parted (
	a text,
	b bigint,
	c numeric,
	d int,
	e varchar
) PARTITION BY RANGE (a, b);
CREATE TABLE
-- Create partitions intentionally in descending bound order, so as to test
-- that update-row-movement works with the leaf partitions not in bound order.
CREATE TABLE part_b_20_b_30 PARTITION OF range_parted FOR VALUES FROM ('b', 20) TO ('b', 30);
CREATE TABLE
CREATE TABLE part_b_10_b_20 PARTITION OF range_parted FOR VALUES FROM ('b', 10) TO ('b', 20) PARTITION BY RANGE (c);
CREATE TABLE
CREATE TABLE part_b_1_b_10 PARTITION OF range_parted FOR VALUES FROM ('b', 1) TO ('b', 10);
CREATE TABLE
CREATE TABLE part_a_10_a_20 PARTITION OF range_parted FOR VALUES FROM ('a', 10) TO ('a', 20);
CREATE TABLE
CREATE TABLE part_a_1_a_10 PARTITION OF range_parted FOR VALUES FROM ('a', 1) TO ('a', 10);
CREATE TABLE
-- Check that partition-key UPDATE works sanely on a partitioned table that
-- does not have any child partitions.
UPDATE part_b_10_b_20 set b = b - 6;
UPDATE 0
-- Create some more partitions following the above pattern of descending bound
-- order, but let's make the situation a bit more complex by having the
-- attribute numbers of the columns vary from their parent partition.
CREATE TABLE part_c_100_200 PARTITION OF part_b_10_b_20 FOR VALUES FROM (100) TO (200) PARTITION BY range (abs(d));
CREATE TABLE
CREATE TABLE part_d_1_15 PARTITION OF part_c_100_200 FOR VALUES FROM (1) TO (15);
CREATE TABLE
CREATE TABLE part_d_15_20 PARTITION OF part_c_100_200 FOR VALUES FROM (15) TO (20);
CREATE TABLE
CREATE TABLE part_c_1_100 PARTITION OF part_b_10_b_20 FOR VALUES FROM (1) TO (100);
CREATE TABLE
\set init_range_parted 'delete from range_parted; insert into range_parted VALUES (''a'', 1, 1, 1), (''a'', 10, 200, 1), (''b'', 12, 96, 1), (''b'', 13, 97, 2), (''b'', 15, 105, 16), (''b'', 17, 105, 19)'
\set show_data 'select * from range_parted ORDER BY 1, 2, 3, 4, 5, 6'
:init_range_parted;
DELETE 0
INSERT 0 6
:show_data;
psql:sql/update.sql:131: ERROR:  ORDER BY position 6 is not in select list
LINE 1: select * from range_parted ORDER BY 1, 2, 3, 4, 5, 6;
                                                           ^
-- The order of subplans should be in bound order
EXPLAIN (costs off) UPDATE range_parted set c = c - 50 WHERE c > 97;
psql:sql/update.sql:134: ERROR:  Can not update partition key of a remote relation.
-- fail, row movement happens only within the partition subtree.
UPDATE part_c_100_200 set c = c - 20, d = c WHERE c = 105;
psql:sql/update.sql:137: ERROR:  Can not update partition key of a remote relation.
-- fail, no partition key update, so no attempt to move tuple,
-- but "a = 'a'" violates partition constraint enforced by root partition)
UPDATE part_b_10_b_20 set a = 'a';
UPDATE 4
-- ok, partition key update, no constraint violation
UPDATE range_parted set d = d - 10 WHERE d > 10;
psql:sql/update.sql:142: ERROR:  Can not update partition key of a remote relation.
-- ok, no partition key update, no constraint violation
UPDATE range_parted set e = d;
UPDATE 6
-- No row found
UPDATE part_c_1_100 set c = c + 20 WHERE c = 98;
UPDATE 0
-- ok, row movement
UPDATE part_b_10_b_20 set c = c + 20 returning c, b, a;
psql:sql/update.sql:148: ERROR:  Can not update partition key of a remote relation.
:show_data;
psql:sql/update.sql:149: ERROR:  ORDER BY position 6 is not in select list
LINE 1: select * from range_parted ORDER BY 1, 2, 3, 4, 5, 6;
                                                           ^
-- fail, row movement happens only within the partition subtree.
--Crash due to unsupported functionality
--UPDATE part_b_10_b_20 set b = b - 6 WHERE c > 116 returning *;
-- ok, row movement, with subset of rows moved into different partition.
UPDATE range_parted set b = b - 6 WHERE c > 116 returning a, b + c;
psql:sql/update.sql:155: ERROR:  Can not update partition key of a remote relation.
:show_data;
psql:sql/update.sql:157: ERROR:  ORDER BY position 6 is not in select list
LINE 1: select * from range_parted ORDER BY 1, 2, 3, 4, 5, 6;
                                                           ^
-- Common table needed for multiple test scenarios.
drop table if exists mintab;
psql:sql/update.sql:160: NOTICE:  table "mintab" does not exist, skipping
DROP TABLE
CREATE TABLE mintab(c1 int);
CREATE TABLE
INSERT into mintab VALUES (120);
INSERT 0 1
-- update partition key using updatable view.
CREATE VIEW upview AS SELECT * FROM range_parted WHERE (select c > c1 FROM mintab) WITH CHECK OPTION;
psql:sql/update.sql:165: WARNING:  views with CHECK options are not supported, the view will be created but the check constraints will be ignored silently.
CREATE VIEW
-- ok
UPDATE upview set c = 199 WHERE b = 4;
psql:sql/update.sql:167: ERROR:  Can not update partition key of a remote relation.
-- fail, check option violation
UPDATE upview set c = 120 WHERE b = 4;
psql:sql/update.sql:169: ERROR:  Can not update partition key of a remote relation.
-- fail, row movement with check option violation
UPDATE upview set a = 'b', b = 15, c = 120 WHERE b = 4;
psql:sql/update.sql:171: ERROR:  Can not update partition key of a remote relation.
-- ok, row movement, check option passes
UPDATE upview set a = 'b', b = 15 WHERE b = 4;
psql:sql/update.sql:173: ERROR:  Can not update partition key of a remote relation.
:show_data;
psql:sql/update.sql:175: ERROR:  ORDER BY position 6 is not in select list
LINE 1: select * from range_parted ORDER BY 1, 2, 3, 4, 5, 6;
                                                           ^
-- cleanup
DROP VIEW upview;
DROP VIEW
-- RETURNING having whole-row vars.
:init_range_parted;
DELETE 6
INSERT 0 6
UPDATE range_parted set c = 95 WHERE a = 'b' and b > 10 and c > 100 returning (range_parted), *;
psql:sql/update.sql:182: ERROR:  Can not update partition key of a remote relation.
:show_data;
psql:sql/update.sql:183: ERROR:  ORDER BY position 6 is not in select list
LINE 1: select * from range_parted ORDER BY 1, 2, 3, 4, 5, 6;
                                                           ^
-- Transition tables with update row movement
:init_range_parted;
DELETE 6
INSERT 0 6
UPDATE range_parted set c = (case when c = 96 then 110 else c + 1 end ) WHERE a = 'b' and b > 10 and c >= 96;
psql:sql/update.sql:189: ERROR:  Can not update partition key of a remote relation.
:show_data;
psql:sql/update.sql:190: ERROR:  ORDER BY position 6 is not in select list
LINE 1: select * from range_parted ORDER BY 1, 2, 3, 4, 5, 6;
                                                           ^
:init_range_parted;
DELETE 6
INSERT 0 6
UPDATE range_parted set c = c + 50 WHERE a = 'b' and b > 10 and c >= 96;
psql:sql/update.sql:193: ERROR:  Can not update partition key of a remote relation.
:show_data;
psql:sql/update.sql:194: ERROR:  ORDER BY position 6 is not in select list
LINE 1: select * from range_parted ORDER BY 1, 2, 3, 4, 5, 6;
                                                           ^
-- Don't drop trans_updatetrig yet. It is required below.
:init_range_parted;
DELETE 6
INSERT 0 6
UPDATE range_parted set c = (case when c = 96 then 110 else c + 1 end) WHERE a = 'b' and b > 10 and c >= 96;
psql:sql/update.sql:198: ERROR:  Can not update partition key of a remote relation.
:show_data;
psql:sql/update.sql:199: ERROR:  ORDER BY position 6 is not in select list
LINE 1: select * from range_parted ORDER BY 1, 2, 3, 4, 5, 6;
                                                           ^
:init_range_parted;
DELETE 6
INSERT 0 6
UPDATE range_parted set c = c + 50 WHERE a = 'b' and b > 10 and c >= 96;
psql:sql/update.sql:201: ERROR:  Can not update partition key of a remote relation.
:show_data;
psql:sql/update.sql:202: ERROR:  ORDER BY position 6 is not in select list
LINE 1: select * from range_parted ORDER BY 1, 2, 3, 4, 5, 6;
                                                           ^
-- Case where per-partition tuple conversion map array is allocated, but the
-- map is not required for the particular tuple that is routed, thanks to
-- matching table attributes of the partition and the target table.
:init_range_parted;
DELETE 6
INSERT 0 6
UPDATE range_parted set b = 15 WHERE b = 1;
psql:sql/update.sql:208: ERROR:  Can not update partition key of a remote relation.
:show_data;
psql:sql/update.sql:209: ERROR:  ORDER BY position 6 is not in select list
LINE 1: select * from range_parted ORDER BY 1, 2, 3, 4, 5, 6;
                                                           ^
-- RLS policies with update-row-movement
-----------------------------------------
--not support: ALTER TABLE range_parted ENABLE ROW LEVEL SECURITY;
CREATE USER regress_range_parted_user;
CREATE ROLE
GRANT ALL ON range_parted, mintab TO regress_range_parted_user;
GRANT
-- not support: CREATE POLICY seeall ON range_parted AS PERMISSIVE FOR SELECT USING (true);
-- not support: CREATE POLICY policy_range_parted ON range_parted for UPDATE USING (true) WITH CHECK (c % 2 = 0);
:init_range_parted;
DELETE 6
INSERT 0 6
SET SESSION AUTHORIZATION regress_range_parted_user;
SET
-- This should fail with RLS violation error while moving row from
-- part_a_10_a_20 to part_d_1_15, because we are setting 'c' to an odd number.
UPDATE range_parted set a = 'b', c = 151 WHERE a = 'a' and c = 200;
psql:sql/update.sql:224: ERROR:  Can not update partition key of a remote relation.
RESET SESSION AUTHORIZATION;
RESET
:init_range_parted;
DELETE 6
INSERT 0 6
SET SESSION AUTHORIZATION regress_range_parted_user;
SET
UPDATE range_parted set a = 'b', c = 151 WHERE a = 'a' and c = 200;
psql:sql/update.sql:230: ERROR:  Can not update partition key of a remote relation.
RESET SESSION AUTHORIZATION;
RESET
:init_range_parted;
DELETE 6
INSERT 0 6
SET SESSION AUTHORIZATION regress_range_parted_user;
SET
UPDATE range_parted set a = 'b', c = 150 WHERE a = 'a' and c = 200;
psql:sql/update.sql:235: ERROR:  Can not update partition key of a remote relation.
-- Cleanup
RESET SESSION AUTHORIZATION;
RESET
DROP FUNCTION func_d_1_15();
psql:sql/update.sql:239: ERROR:  function func_d_1_15() does not exist
-- Policy expression contains SubPlan
RESET SESSION AUTHORIZATION;
RESET
:init_range_parted;
DELETE 6
INSERT 0 6
--CREATE POLICY policy_range_parted_subplan on range_parted
--    AS RESTRICTIVE for UPDATE USING (true)
--    WITH CHECK ((SELECT range_parted.c <= c1 FROM mintab));
SET SESSION AUTHORIZATION regress_range_parted_user;
SET
-- fail, mintab has row with c1 = 120
UPDATE range_parted set a = 'b', c = 122 WHERE a = 'a' and c = 200;
psql:sql/update.sql:249: ERROR:  Can not update partition key of a remote relation.
-- ok
UPDATE range_parted set a = 'b', c = 120 WHERE a = 'a' and c = 200;
psql:sql/update.sql:251: ERROR:  Can not update partition key of a remote relation.
-- RLS policy expression contains whole row.
RESET SESSION AUTHORIZATION;
RESET
:init_range_parted;
DELETE 6
INSERT 0 6
--CREATE POLICY policy_range_parted_wholerow on range_parted AS RESTRICTIVE for UPDATE USING (true)
--   WITH CHECK (range_parted = row('b', 10, 112, 1, NULL)::range_parted);
SET SESSION AUTHORIZATION regress_range_parted_user;
SET
-- ok, should pass the RLS check
UPDATE range_parted set a = 'b', c = 112 WHERE a = 'a' and c = 200;
psql:sql/update.sql:261: ERROR:  Can not update partition key of a remote relation.
RESET SESSION AUTHORIZATION;
RESET
:init_range_parted;
DELETE 6
INSERT 0 6
SET SESSION AUTHORIZATION regress_range_parted_user;
SET
-- fail, the whole row RLS check should fail
UPDATE range_parted set a = 'b', c = 116 WHERE a = 'a' and c = 200;
psql:sql/update.sql:266: ERROR:  Can not update partition key of a remote relation.
-- Cleanup
RESET SESSION AUTHORIZATION;
RESET
--DROP POLICY policy_range_parted ON range_parted;
--DROP POLICY policy_range_parted_subplan ON range_parted;
--DROP POLICY policy_range_parted_wholerow ON range_parted;
REVOKE ALL ON range_parted, mintab FROM regress_range_parted_user;
REVOKE
DROP USER regress_range_parted_user;
DROP ROLE
DROP TABLE mintab;
DROP TABLE
:init_range_parted;
DELETE 6
INSERT 0 6
UPDATE range_parted set c = c - 50 WHERE c > 97;
psql:sql/update.sql:280: ERROR:  Can not update partition key of a remote relation.
:show_data;
psql:sql/update.sql:281: ERROR:  ORDER BY position 6 is not in select list
LINE 1: select * from range_parted ORDER BY 1, 2, 3, 4, 5, 6;
                                                           ^
-- Creating default partition for range
:init_range_parted;
DELETE 6
INSERT 0 6
\d+ part_def
psql:sql/update.sql:285: error: Did not find any relation named "part_def".
insert into range_parted values ('c', 9);
psql:sql/update.sql:286: ERROR:  no partition of relation "range_parted" found for row
DETAIL:  Partition key of the failing row contains (a, b) = (c, 9).
-- ok
update part_def set a = 'd' where a = 'c';
psql:sql/update.sql:288: ERROR:  relation "part_def" does not exist
LINE 1: update part_def set a = 'd' where a = 'c';
               ^
-- fail
update part_def set a = 'a' where a = 'd';
psql:sql/update.sql:290: ERROR:  relation "part_def" does not exist
LINE 1: update part_def set a = 'a' where a = 'd';
               ^
:show_data;
psql:sql/update.sql:292: ERROR:  ORDER BY position 6 is not in select list
LINE 1: select * from range_parted ORDER BY 1, 2, 3, 4, 5, 6;
                                                           ^
-- Update row movement from non-default to default partition.
-- fail, default partition is not under part_a_10_a_20;
UPDATE part_a_10_a_20 set a = 'ad' WHERE a = 'a';
UPDATE 1
-- ok
UPDATE range_parted set a = 'ad' WHERE a = 'a';
psql:sql/update.sql:298: ERROR:  Can not update partition key of a remote relation.
UPDATE range_parted set a = 'bd' WHERE a = 'b';
psql:sql/update.sql:299: ERROR:  Can not update partition key of a remote relation.
:show_data;
psql:sql/update.sql:300: ERROR:  ORDER BY position 6 is not in select list
LINE 1: select * from range_parted ORDER BY 1, 2, 3, 4, 5, 6;
                                                           ^
-- Update row movement from default to non-default partitions.
-- ok
UPDATE range_parted set a = 'a' WHERE a = 'ad';
psql:sql/update.sql:303: ERROR:  Can not update partition key of a remote relation.
UPDATE range_parted set a = 'b' WHERE a = 'bd';
psql:sql/update.sql:304: ERROR:  Can not update partition key of a remote relation.
:show_data;
psql:sql/update.sql:305: ERROR:  ORDER BY position 6 is not in select list
LINE 1: select * from range_parted ORDER BY 1, 2, 3, 4, 5, 6;
                                                           ^
-- Cleanup: range_parted no longer needed.
DROP TABLE range_parted;
DROP TABLE
drop table if exists list_parted;
psql:sql/update.sql:310: NOTICE:  table "list_parted" does not exist, skipping
DROP TABLE
CREATE TABLE list_parted (
	a text,
	b int
) PARTITION BY list (a);
CREATE TABLE
CREATE TABLE list_part1  PARTITION OF list_parted for VALUES in ('a', 'b');
CREATE TABLE
INSERT into list_part1 VALUES ('a', 1);
INSERT 0 1
DROP TABLE list_parted;
DROP TABLE
--------------
-- Some more update-partition-key test scenarios below. This time use list
-- partitions.
--------------
-- Setup for list partitions
CREATE TABLE list_parted (a numeric, b int, c int8) PARTITION BY list (a);
CREATE TABLE
CREATE TABLE sub_parted PARTITION OF list_parted for VALUES in (1) PARTITION BY list (b);
CREATE TABLE
CREATE TABLE sub_part1 PARTITION OF sub_parted for VALUES in (1);
CREATE TABLE
CREATE TABLE sub_part2 PARTITION OF sub_parted for VALUES in (2);
CREATE TABLE
CREATE TABLE list_part1 PARTITION OF list_parted for VALUES in (2,3);;
CREATE TABLE
INSERT into list_parted VALUES (2,5,50);
INSERT 0 1
INSERT into list_parted VALUES (3,6,60);
INSERT 0 1
INSERT into sub_parted VALUES (1,1,60);
INSERT 0 1
INSERT into sub_parted VALUES (1,2,10);
INSERT 0 1
-- Test partition constraint violation when intermediate ancestor is used and
-- constraint is inherited from upper root.
UPDATE sub_parted set a = 2 WHERE c = 10;
UPDATE 1
-- Test update-partition-key, where the unpruned partitions do not have their
-- partition keys updated.
SELECT * FROM list_parted WHERE a = 2 ORDER BY 1;
           a            | b | c  
------------------------+---+----
 2.00000000000000000000 | 5 | 50
(1 row)

UPDATE list_parted set b = c + a WHERE a = 2;
psql:sql/update.sql:343: ERROR:  Can not update partition key of a remote relation.
SELECT * FROM list_parted WHERE a = 2 ORDER BY 1;
           a            | b | c  
------------------------+---+----
 2.00000000000000000000 | 5 | 50
(1 row)

SELECT * FROM list_parted ORDER BY 1, 2, 3;
           a            | b | c  
------------------------+---+----
 1.00000000000000000000 | 1 | 60
 2.00000000000000000000 | 2 | 10
 2.00000000000000000000 | 5 | 50
 3.00000000000000000000 | 6 | 60
(4 rows)

UPDATE list_parted set c = 70 WHERE b  = 1;
UPDATE 1
SELECT * FROM list_parted ORDER BY 1, 2, 3;
           a            | b | c  
------------------------+---+----
 1.00000000000000000000 | 1 | 70
 2.00000000000000000000 | 2 | 10
 2.00000000000000000000 | 5 | 50
 3.00000000000000000000 | 6 | 60
(4 rows)

UPDATE list_parted set b = 1 WHERE c = 70;
psql:sql/update.sql:351: ERROR:  Can not update partition key of a remote relation.
SELECT * FROM list_parted ORDER BY 1, 2, 3;
           a            | b | c  
------------------------+---+----
 1.00000000000000000000 | 1 | 70
 2.00000000000000000000 | 2 | 10
 2.00000000000000000000 | 5 | 50
 3.00000000000000000000 | 6 | 60
(4 rows)

UPDATE list_parted set b = 1 WHERE c = 70;
psql:sql/update.sql:353: ERROR:  Can not update partition key of a remote relation.
SELECT * FROM list_parted ORDER BY 1, 2, 3;
           a            | b | c  
------------------------+---+----
 1.00000000000000000000 | 1 | 70
 2.00000000000000000000 | 2 | 10
 2.00000000000000000000 | 5 | 50
 3.00000000000000000000 | 6 | 60
(4 rows)

-- UPDATE partition-key with FROM clause. If join produces multiple output
-- rows for the same row to be modified, we should tuple-route the row only
-- once. There should not be any rows inserted.
drop table if exists non_parted;
psql:sql/update.sql:359: NOTICE:  table "non_parted" does not exist, skipping
DROP TABLE
CREATE TABLE non_parted (id int);
CREATE TABLE
INSERT into non_parted VALUES (1), (1), (1), (2), (2), (2), (3), (3), (3);
INSERT 0 9
-- not supported: UPDATE list_parted t1 set a = 2 FROM non_parted t2 WHERE t1.a = t2.id and a = 1;
SELECT * FROM list_parted ORDER BY 1, 2, 3;
           a            | b | c  
------------------------+---+----
 1.00000000000000000000 | 1 | 70
 2.00000000000000000000 | 2 | 10
 2.00000000000000000000 | 5 | 50
 3.00000000000000000000 | 6 | 60
(4 rows)

DROP TABLE non_parted;
DROP TABLE
-- Cleanup: list_parted no longer needed.
DROP TABLE list_parted;
DROP TABLE
-- create custom operator class and hash function, for the same reason
-- explained in alter_table.sql
create or replace function dummy_hashint4(a int4, seed int8) returns int8 as
$$ begin return (a + seed); end; $$ language 'plpgsql' immutable;
CREATE FUNCTION
create operator class custom_opclass for type int4 using hash as
operator 1 = , function 2 dummy_hashint4(int4, int8);
CREATE OPERATOR CLASS
drop table if exists hash_parted;
psql:sql/update.sql:375: NOTICE:  table "hash_parted" does not exist, skipping
DROP TABLE
create table hash_parted (
	a int,
	b int
) partition by hash (a custom_opclass, b custom_opclass);
CREATE TABLE
create table hpart1 partition of hash_parted for values with (modulus 2, remainder 1);
CREATE TABLE
create table hpart2 partition of hash_parted for values with (modulus 4, remainder 2);
CREATE TABLE
create table hpart3 partition of hash_parted for values with (modulus 8, remainder 0);
CREATE TABLE
create table hpart4 partition of hash_parted for values with (modulus 8, remainder 4);
CREATE TABLE
insert into hpart1 values (1, 1);
INSERT 0 1
insert into hpart2 values (2, 5);
INSERT 0 1
insert into hpart4 values (3, 4);
INSERT 0 1
-- fail
update hpart1 set a = 3, b=4 where a = 1;
UPDATE 1
-- ok, row movement
update hash_parted set b = b - 1 where b = 1;
psql:sql/update.sql:391: ERROR:  Can not update partition key of a remote relation.
-- ok
update hash_parted set b = b + 8 where b = 1;
psql:sql/update.sql:393: ERROR:  Can not update partition key of a remote relation.
-- cleanup
drop table hash_parted;
DROP TABLE
drop operator class custom_opclass using hash;
DROP OPERATOR CLASS
drop function dummy_hashint4(a int4, seed int8);
DROP FUNCTION
